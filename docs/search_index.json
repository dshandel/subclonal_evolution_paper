[["index.html", "Pre-existing Radioresistant Subclones Determine Radioresistance in Rectal Cancer Organoids 1 Introduction", " Pre-existing Radioresistant Subclones Determine Radioresistance in Rectal Cancer Organoids Daan Andel 2024-02-19 1 Introduction This book includes all the scripts used to generate the statistics and plots presented in the paper “Pre-existing Radioresistant Subclones Determine Radioresistance in Rectal Cancer Organoids.” The scripts are arranged in a loose chronological order, corresponding to the flow of the paper. The source code referenced within the scripts can be located in the ‘R’ folder on the GitHub page and also in the final chapter of this book. Paper: https://doi.org/10.1016/j.celrep.2024.113735 GitHub: https://github.com/dshandel/subclonal_evolution_paper "],["in-vitro-radiation-response-and-clinical-data.html", "2 In vitro radiation response and clinical data 2.1 Progression-free survival 2.2 In vitro dose-response", " 2 In vitro radiation response and clinical data 2.1 Progression-free survival # Libraries and sources library(readxl) library(tidyverse) library(ggplot2) library(ggfortify) library(survival) library(survminer) library(survMisc) library(cowplot) ######## # Data # ######## # Loading survival data from time of surgery surg_surv &lt;- as.data.frame(read_excel(&quot;../cna_analysis/data/clinical_and_dr/data_survival_progression_with_death_as_progression.xlsx&quot;, sheet = &quot;surg_surv&quot;)) # Loading progression data from time of surgery surg_prog &lt;- as.data.frame(read_excel(&quot;../cna_analysis/data/clinical_and_dr/data_survival_progression_with_death_as_progression.xlsx&quot;, sheet = &quot;surg_prog&quot;)) ####### # Run # ####### ## Survival from time of surgery ## surg_surv_sum &lt;- Surv(time = surg_surv$time, event = surg_surv$status == 2) # Fit without strata (~1) surg_surv_fit &lt;- survfit(surg_surv_sum ~ 1) # Median survival from time of surgery surv_median(surg_surv_fit)[1,2] ## [1] 1857 ## Progression from time of surgery ## surg_prog_sum &lt;- Surv(time = surg_prog$time, event = surg_prog$status == 2) # Fit without strata (~1) surg_prog_fit &lt;- survfit(surg_prog_sum ~ 1) # Median progression from time of surgery surv_median(surg_prog_fit)[1,2] ## [1] 1857 #### PROGRESSION #### # Constructing a dataframe for annotating labels anno_df_prog &lt;- data.frame(label = surg_prog$organoid, time = surg_prog$time) # sort by time anno_df_prog &lt;- anno_df_prog[order(anno_df_prog$time),] # make temp df with survival/prob data temp_df_prob_prog &lt;- data.frame(time = surg_prog_fit$time, prob = surg_prog_fit$surv ) # join together anno_df_prog &lt;- left_join(anno_df_prog, temp_df_prob_prog) # Plotting progression free survival prog_p &lt;- ggsurvplot(surg_prog_fit, data = surg_prog, conf.int = F, palette = c(&quot;#00887d&quot;), ggtheme = theme_cowplot(), legend = &#39;none&#39;, censor.size = 8, xlim = c(0,2200), ylab = &#39;Progression-free survival probability&#39;, xlab = &#39;Time from surgery (days)&#39;) # adding labels prog_p$plot &lt;- prog_p$plot + annotate(&quot;text&quot;, x = anno_df_prog$time + c(350, 350, 350, -150,50,250,350,0), y = anno_df_prog$prob + c(0.1,0.1,0.1, -0.05, 0.05, -0.05, 0.28,-0.05), label = anno_df_prog$label) + theme(aspect.ratio = 5/3) + coord_cartesian(clip = &#39;off&#39;) prog_p 2.2 In vitro dose-response # Libraries and sources library(tidyverse) # for wrangling data library(readxl) # for reading excel files library(DescTools) # for computing AUCs with AUC() function) library(drc) # for fitting dose response library(cowplot) library(wesanderson) source(&#39;R/auc_rad.R&#39;) source(&#39;R/fitter_rad.R&#39;) source(&#39;R/ic50_rad.R&#39;) source(&#39;R/relativize_dr.R&#39;) 2.2.1 Dose-response plot ################ # Loading data # ################ d &lt;- data.frame(read_excel(&#39;../cna_analysis/data/clinical_and_dr/resistancy_organoids.xlsx&#39;)) # remove fluke experiment (can&#39;t be fitted by the drc package in metricsandfits.R) d &lt;- subset(d, expcode != &#39;cva0028&#39;) # remove dose 1, 10,12 d &lt;- subset(d, dose %in% c(0,2,4,6,8)) # only include organoids that were not radiated d &lt;- subset(d, rec_rad == 0) ############## # Relativize # ############## # Relativizing the data # split per experiment per_exp &lt;- split(d, f = d$expcode, drop = TRUE) # apply relative function to every instance in per_exp rel_vector_unrad &lt;- lapply(per_exp, relative, rad = F) # join the dataframes togheter d_nonrad = do.call(rbind, rel_vector_unrad) #remove rownames rownames(d_nonrad) &lt;- NULL # pool d_rad and d_nonrad, if not possible, make d d_nonrad # try to bind d_rad and d_nonrad. If d_rad is empty (this is the case when # rec_rad does not have ones, make d the same as d_nonrad) d &lt;- d_nonrad ################ # Loading data # ################ load(&quot;../cna_analysis/rda/clinical_and_dr/wrangled-data.rda&quot;) # load the wrangled data, data is saved under &#39;d&#39; # defining experiment number for reference exp_numb &lt;- unique(d$expcode) exp_numb &lt;- paste(unlist(exp_numb), collapse=&#39;&#39;) ################## ### Metric AUC ### ################## # split per experiment per_exp &lt;- split(d, f = d$expcode, drop = TRUE) # apply relative function to every instance in per_exp AUC_vector &lt;- lapply(per_exp, AUC_fun) # join the dataframes togheter AUC = do.call(rbind, AUC_vector) # remove rownames rownames(AUC) &lt;- NULL ####### # Fit # ####### # apply fit function to every instance in per_exp fit_vector &lt;- lapply(per_exp, fitter) # join the dataframes toghether fit = do.call(rbind, fit_vector) # remove rownames rownames(fit) &lt;- NULL fit$rec_rad = 0 # remove rownames rownames(fit) &lt;- NULL ################## # relative IC50s # ################## ## relative under curve for unrad # apply relative function to every instance in per_exp IC50_vector &lt;- lapply(per_exp, IC50_fun, rad = 0) # join the dataframes togheter IC50= do.call(rbind, IC50_vector) metrics = cbind(AUC, IC50) metrics$rec_rad &lt;- 0 # compute mean of rel_AUC metrics_pooled &lt;- metrics %&gt;% group_by(cline) %&gt;% summarise_at(vars(rel_AUC), funs(mean(., na.rm=TRUE))) metrics_pooled$expcode &lt;- exp_numb # compute mean of rel_AUC metrics_pooled &lt;- metrics %&gt;% group_by(cline) %&gt;% summarise_at(vars(rel_AUC), funs(mean(., na.rm=TRUE))) # summary statistics median(metrics$rel_AUC) ## [1] 0.5648321 min(metrics$rel_AUC) ## [1] 0.304031 max(metrics$rel_AUC) ## [1] 0.8152938 ######## # Data # ######## load(&quot;../cna_analysis/rda/clinical_and_dr/wrangled-data.rda&quot;) # load the wrangled data, data is saved under &#39;d&#39; load(&quot;../cna_analysis/rda/clinical_and_dr/fitted-data.rda&quot;) # load the wrangled data, data is saved under &#39;fit&#39; load(&#39;../cna_analysis/rda/clinical_and_dr/metrics_data.rda&#39;) # load the metrics data ########### # Wrangle # ########### ### define two dataframes, one from rad one without rad: fit &lt;- subset(fit, rec_rad == 0) exp_numb &lt;- unique(d$expcode) exp_numb &lt;- paste(unlist(exp_numb), collapse=&#39;&#39;) # new data with doses. Note: lowest dose is not # log 0 but log(&#39;very small number&#39;) because otherwise this will hamper the scaling in ggplot later on. d$dose0 &lt;- d$dose d$dose0[d$dose0 == 0] &lt;- 0.00000001 # representative expcodes # makeing helper column to extract representative expcodes d$cline_expcode &lt;- paste0(d$cline, &#39;_&#39;, d$expcode) fit$cline_expcode &lt;- paste0(fit$cline, &#39;_&#39;, fit$expcode) # subsetting cline_expcode_pick &lt;- c( &#39;HUB005_cva0025&#39;, &#39;HUB183_cva0025&#39;, &#39;HUB015_cva0023&#39;, &#39;HUB175_cva0024&#39;, &#39;HUB181I_cva0021&#39;, &#39;HUB197_cva0030&#39;, &#39;HUB106_cva0020&#39;, &#39;HUB062_cva0023&#39;, &#39;HUB112_cva0112&#39;) d &lt;- subset(d, cline_expcode %in% cline_expcode_pick) fit &lt;- subset(fit, cline_expcode %in% cline_expcode_pick) # add resistantcy group for colour coding resistant &lt;- c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB015&#39;) sensitive &lt;- c(&#39;HUB197&#39;, &#39;HUB106&#39;, &#39;HUB062&#39;) d$resistancy_group &lt;- ifelse( d$cline %in% resistant, &#39;Resistant&#39;, ifelse(d$cline %in% sensitive, &#39;Sensitive&#39;, &#39;Intermediate&#39;) ) fit$resistancy_group &lt;- ifelse( fit$cline %in% resistant, &#39;Resistant&#39;, ifelse(fit$cline %in% sensitive, &#39;Sensitive&#39;, &#39;Intermediate&#39;) ) # Make cline a factor and specify order by decreasing AUC mean d$cline &lt;- factor(d$cline, levels = c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB015&#39;, &#39;HUB112&#39;, &#39;HUB175&#39;, &#39;HUB181I&#39;, &#39;HUB106&#39;, &#39;HUB197&#39;, &#39;HUB062&#39;)) d$resistancy_group &lt;- factor(d$resistancy_group, levels = c(&#39;Resistant&#39;, &#39;Intermediate&#39;, &#39;Sensitive&#39;)) ggplot(NULL, aes(x = dose0, y = relative_mean, group = cline, col = resistancy_group)) + geom_point(data= d, size =3, aes(shape = cline)) + geom_errorbar(data = d, aes(ymin=relative_mean-relative_sem,ymax=relative_mean+relative_sem), width=0.1) + geom_line(data = d) + # geom_line(data=fit, aes(x=dose, y=pred), # size = 1) + # adding log x-axis coord_trans(#x=&quot;log10&quot;, xlim = c(0.00000001, 8), ylim = c(0, 1.1)) + scale_x_continuous(breaks = c(0, 2,4,6,8)) + scale_y_continuous(expand = c(0,0)) + theme_cowplot() + ylab(&#39;Normalized viability&#39;) + xlab(&#39;Dose (Gy)&#39;) + theme( legend.title = element_blank(), aspect.ratio = 5 / 3) + scale_shape_manual(values=seq(0,8)) + scale_colour_manual( values = c( Resistant = &#39;#DE3163&#39;, Sensitive = &#39;#5090CD&#39;, Intermediate = &#39;grey75&#39; ), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length( unique(d$resistancy_group) ))), shape = c(rep(19, length( unique(d$resistancy_group) ))) )) ) 2.2.2 rAUC across multiple experiments ######## # Data # ######## load(&#39;../cna_analysis/rda/clinical_and_dr/metrics_data.rda&#39;) # load the wrangled data, data is saved under &#39;metrics&#39; exp_numb &lt;- unique(metrics$expcode) exp_numb &lt;- paste(unlist(exp_numb), collapse = &#39;&#39;) ########### # Wrangle # ########### # Make cline a factor and specify order by decreasing AUC mean metrics$cline &lt;- factor( metrics$cline, levels = metrics %&gt;% group_by(cline) %&gt;% summarize(mean_auc = mean(rel_AUC)) %&gt;% arrange(-mean_auc) %&gt;% pull(cline) ) # add resistantcy group for colour coding resistant &lt;- c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB015&#39;) sensitive &lt;- c(&#39;HUB197&#39;, &#39;HUB106&#39;, &#39;HUB062&#39;) metrics$resistancy_group &lt;- ifelse( metrics$cline %in% resistant, &#39;Resistant&#39;, ifelse(metrics$cline %in% sensitive, &#39;Sensitive&#39;, &#39;Intermediate&#39;) ) # changing order of resistancy_group metrics$resistancy_group &lt;- factor(metrics$resistancy_group, levels = c(&quot;Resistant&quot;, &quot;Intermediate&quot;, &quot;Sensitive&quot;)) ######## # Plot # ######## ggplot(metrics, aes(x = cline, y = rel_AUC, group = cline)) + geom_boxplot(aes(fill = resistancy_group)) + geom_jitter(height = 0, width = 0.1, size = 2) + theme_cowplot() + scale_fill_manual( values = c( Resistant = &#39;#DE3163&#39;, Sensitive = &#39;#5090CD&#39;, Intermediate = &#39;grey75&#39; ), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length( unique(metrics$resistancy_group) ))), shape = c(rep(19, length( unique(metrics$resistancy_group) ))) )) ) + xlab(&#39;&#39;) + ylab(&#39;Relative AUC&#39;) + theme( legend.title = element_blank(), aspect.ratio = 5 / 3, axis.text.x = element_text(angle = 45, hjust = 1) ) + coord_cartesian(clip = &#39;off&#39;) + scale_y_continuous(limits = c(0,1)) # statistical test to compare top three radioresistant and radiosensitive organoids # note that in the paper, the p-value was added manually. # Make cline a factor and specify order by decreasing AUC mean metrics$cline &lt;- factor( metrics$cline, levels = metrics %&gt;% group_by(cline) %&gt;% summarize(mean_auc = mean(rel_AUC)) %&gt;% arrange(-mean_auc) %&gt;% pull(cline) ) # add resistancy group for colour coding resistant &lt;- c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB015&#39;) sensitive &lt;- c(&#39;HUB197&#39;, &#39;HUB106&#39;, &#39;HUB062&#39;) metrics$resistancy_group &lt;- ifelse( metrics$cline %in% resistant, &#39;Resistant&#39;, ifelse(metrics$cline %in% sensitive, &#39;Sensitive&#39;, &#39;Intermediate&#39;) ) # changing order of resistancy_group metrics$resistancy_group &lt;- factor(metrics$resistancy_group, levels = c(&quot;Resistant&quot;, &quot;Intermediate&quot;, &quot;Sensitive&quot;)) ####### # Run # ####### # t.test (by just taking the average of each biological replicate). t_df &lt;- metrics %&gt;% group_by(cline) %&gt;% summarize(rAUC= mean(rel_AUC), stdev = sd(rel_AUC)) t_df$resistancy_group &lt;- ifelse( t_df$cline %in% resistant, &#39;Resistant&#39;, ifelse(t_df$cline %in% sensitive, &#39;Sensitive&#39;, &#39;Intermediate&#39;) ) # Highly significant p-value. t.test(subset(t_df, resistancy_group == &#39;Resistant&#39;)$rAUC, subset(t_df, resistancy_group == &#39;Sensitive&#39;)$rAUC, paired = F) ## ## Welch Two Sample t-test ## ## data: subset(t_df, resistancy_group == &quot;Resistant&quot;)$rAUC and subset(t_df, resistancy_group == &quot;Sensitive&quot;)$rAUC ## t = 12.615, df = 3.725, p-value = 0.0003428 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 0.2154863 0.3417958 ## sample estimates: ## mean of x mean of y ## 0.6692538 0.3906127 2.2.3 Recovery statistics after 10 Gy radiation ######## # Data # ######## df &lt;- as.data.frame(read_excel(&quot;../cna_analysis/data/clinical_and_dr/ 10gy_recovery_data.xlsx&quot;)) ########### # Wrangle # ########### df_res &lt;- subset(df, resistancy_group == &#39;Resistant&#39;) df_sens &lt;- subset(df, resistancy_group == &#39;Sensitive&#39;) ############## # Statistics # ############## # Resistant mean_days_res &lt;- mean(as.numeric(df_res$days_to_full_recovery), na.rm = T) mean_days_res ## [1] 30.66667 sd_days_res &lt;- sd(as.numeric(df_res$days_to_full_recovery), na.rm = T) sd_days_res ## [1] 11.54701 # Sensitive mean_days_sens &lt;- mean(as.numeric(df_sens$days_to_full_recovery), na.rm = T) mean_days_sens ## [1] 49 sd_days_sens &lt;- sd(as.numeric(df_sens$days_to_full_recovery), na.rm = T) sd_days_sens ## [1] 23.64318 2.2.4 Persisters versus shifters dose-response plots ######## # Data # ######## d &lt;- as.data.frame(read_excel(&quot;../cna_analysis/data/clinical_and_dr/parental_vs_radiated.xlsx&quot;)) ############## # Relativize # ############## # split per experiment per_exp &lt;- split(d, f = d$expcode, drop = TRUE) # for radiation rel_vector_unrad &lt;- lapply(per_exp, relative, rad = F) # join the dataframes togheter d_nonrad = do.call(rbind, rel_vector_unrad) # for radiation rel_vector_rad &lt;- lapply(per_exp, relative, rad = T) # for radation d_rad = do.call(rbind, rel_vector_rad) # try to bind d_rad and d_nonrad. If d_rad is empty (this is the case when # rec_rad does not have ones, make d the same as d_nonrad) d &lt;- try(rbind(d_rad, d_nonrad)) if(&quot;try-error&quot; %in% class(d)) d &lt;- d_nonrad ########### # Wrangle # ########### # making helper column to extract representative expcodes d$cline_expcode &lt;- paste0(d$cline, &#39;_&#39;, d$expcode, &#39;_&#39;, d$rec_rad) # subsetting cline_expcode_pick &lt;- c(&#39;HUB005_cva0026_0&#39;, &#39;HUB005_cva0026_1&#39;, &#39;HUB183_cva0025_0&#39;, &#39;HUB183_cva0025_1&#39;, &#39;HUB106_cva0028_0&#39;, &#39;HUB106_cva0028_1&#39;, &#39;HUB197_cva0117_0&#39;, &#39;HUB197_cva0117_1&#39;, &#39;HUB062_cva0061_a_0&#39;, &#39;HUB062_cva0061_b_1&#39;) d &lt;- subset(d, cline_expcode %in% cline_expcode_pick) d$persister_group &lt;- ifelse( d$cline %in% c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB106&#39;), &#39;Persister&#39;, &#39;Shifter&#39;) d$rad &lt;- ifelse( d$rec_rad == 0, &#39;Parental&#39;, &#39;Recurrence&#39; ) # new data with doses. Note: lowest dose is not # log 0 but log(&#39;very small number&#39;) because otherwise this will hamper the scaling in ggplot later on. d$dose0 &lt;- d$dose d$dose0[d$dose0 == 0] &lt;- 0.00000001 ########### # Wrangle # ########### s &lt;- subset(d, persister_group == &#39;Shifter&#39;) ggplot(NULL, aes(x = dose0, y = relative_mean, group = interaction(cline,rad), col = rad)) + geom_point(data= s, size =3, aes(shape = cline)) + geom_errorbar(data = s, aes(ymin=relative_mean-relative_sem,ymax=relative_mean+relative_sem), width=0.1) + geom_line(data = s) + coord_trans(#x=&quot;log10&quot;, xlim = c(0.00000001, 8), ylim = c(0, 1.2)) + scale_x_continuous(breaks = c(0, 2,4,6,8)) + scale_y_continuous(expand = c(0,0), breaks = c(0,0.2, 0.4,0.6,0.8,1.0,1.2)) + theme_cowplot() + ylab(&#39;Normalized viability&#39;) + xlab(&#39;Dose (Gy)&#39;) + theme( legend.title = element_blank(), aspect.ratio = 5 / 3) + scale_shape_manual(values=seq(0,8)) + labs(title = &#39;Shifters&#39;) + scale_colour_manual( values = c( Parental = &#39;#999999&#39;, Recurrence = &quot;#E69F00&quot; ), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length( unique(d$rad) ))), shape = c(rep(19, length( unique(d$rad) ))) )) ) p &lt;- subset(d, persister_group == &#39;Persister&#39;) ggplot(NULL, aes(x = dose0, y = relative_mean, group = interaction(cline,rad), col = rad)) + geom_point(data= p, size =3, aes(shape = cline)) + geom_errorbar(data = p, aes(ymin=relative_mean-relative_sem,ymax=relative_mean+relative_sem), width=0.1) + geom_line(data = p) + coord_trans(#x=&quot;log10&quot;, xlim = c(0.00000001, 8), ylim = c(0, 1.2)) + scale_x_continuous(breaks = c(0, 2,4,6,8)) + scale_y_continuous(expand = c(0,0), breaks = c(0,0.2, 0.4,0.6,0.8,1.0,1.2)) + theme_cowplot() + ylab(&#39;Normalized viability&#39;) + xlab(&#39;Dose (Gy)&#39;) + theme( legend.title = element_blank(), aspect.ratio = 5 / 3) + scale_shape_manual(values=seq(0,8)) + labs(title = &#39;Persisters&#39;) + scale_colour_manual( values = c( Parental = &#39;#999999&#39;, Recurrence = &quot;#E69F00&quot; ), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length( unique(d$rad) ))), shape = c(rep(19, length( unique(d$rad) ))) )) ) "],["subclonal-dynamics.html", "3 Subclonal dynamics 3.1 AneuFinder run 3.2 Quality selection 3.3 Summary statistics of copy number alterations 3.4 PCA and K-means plots 3.5 Subclone selection 3.6 Single cell copy number heatmap plots 3.7 Fisher’s exact test 3.8 MEDICC2", " 3 Subclonal dynamics # Libraries and sources library(tidyverse) library(AneuFinder) library(GenomeInfoDb) library(BSgenome.Hsapiens.UCSC.hg38) library(stringr) source(&#39;R/plot_pca_kmeans.R&#39;) source(&#39;R/quality_functions.R&#39;) source(&#39;R/divide_subclone_functions.R&#39;) source(&#39;R/plot_genomeheatmap.R&#39;) source(&#39;R/fisher_test.R&#39;) 3.1 AneuFinder run ########### # Folders # ########### # define bamdirectory bamDirectory &lt;- &quot;../cna_analysis/data/subclonal_dynamics/single_cell_bams&quot; # generates novel directories from bam-file directory to store analysis files inputdirs &lt;- list.dirs(bamDirectory, recursive = F) outputdirs &lt;- list.dirs(bamDirectory, full.names = F, recursive = F) outputdirs &lt;- paste0(&quot;rda/subclonal_dynamics/standard_aneufinder_output_pairedend_5kb/&quot;, outputdirs) # define location for correction: mappability &lt;- &quot;data/subclonal_dynamics/correctionfiles/bothlymphsdiploidref.bed&quot; blacklist &lt;- &quot;data/subclonal_dynamics/correctionfiles/GRCh38_blacklist_bothlymphsdiploidref.bed&quot; # creating a results folder in the working directory names &#39;result&#39; dir.create(path = &#39;rda/subclonal_dynamics/standard_aneufinder_output_pairedend_5kb&#39;) # creating folders for each plate in the standard_aneufinder_output folder. for (i in 1:length(outputdirs)) { dir.create(path = outputdirs[i]) } ####### # Run # ####### # iterates through bam-file directories and analyses results for (i in 4:length(inputdirs)) { BamFolder &lt;- paste0(inputdirs[i], &#39;/split_cells&#39;) Aneufinder( # specifying input and outputfolder inputfolder = BamFolder, outputfolder = outputdirs[i], # general settings numCPU = 10, reuse.existing.files = TRUE, # specifying binning options binsizes = 5e+05, # 500000 stepsizes = 5e+05, variable.width.reference = mappability, reads.per.bin = NULL, pairedEndReads = T, assembly = &#39;hg38&#39;, chromosomes = c( &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;11&#39;, &#39;12&#39;, &#39;13&#39;, &#39;14&#39;, &#39;15&#39;, &#39;16&#39;, &#39;17&#39;, &#39;18&#39;, &#39;19&#39;, &#39;20&#39;, &#39;21&#39;, &#39;22&#39;, &#39;X&#39; ), remove.duplicate.reads = F, min.mapq = 10, blacklist = blacklist, reads.store = T, use.bamsignals = F, # specifying correction options correction.method = &#39;GC&#39;, GC.BSgenome = BSgenome.Hsapiens.UCSC.hg38, #mappability.reference = NULL, #specofying model options method = c(&#39;edivisive&#39;), eps = 0.1, max.time = 60, max.iter = -1, num.trials = 15, states = c( &#39;zero-inflation&#39;, &#39;0-somy&#39;, &#39;1-somy&#39;, &#39;2-somy&#39;, &#39;3-somy&#39;, &#39;4-somy&#39;, &#39;5-somy&#39;, &#39;6-somy&#39;, &#39;7-somy&#39;, &#39;8-somy&#39;, &#39;9-somy&#39;, &#39;+10-somy&#39; ), #most.frequent.state = &#39;2-somy&#39;, # maybe this should be changed given some organoids seem triploid. #most.frequent.state.strandseq = &#39;1-somy&#39;, #specifying how to detect sister chromatid exchanges #resolution = c(3,6), #min.segwidth = 4, #bw = 4e+06, #pval = 0.05, # plotting options cluster.plots = T ) } 3.2 Quality selection ############### # Description # ############### # Single cell karyotyping is inherently noisy data. This script runs # some of the in-build quality checks provided by AneuFinder ######### # Paths # ######### # defining rdabasedirectory rdaBaseDirectory &lt;- &quot;../cna_analysis/rda/subclonal_dynamics/standard_aneufinder_output_pairedend_5kb&quot; # list all folders within base directory (each folder contains folders the AneuFinder output: MODELS, plots etc..) # the files we need are in the MODELS folder inputdirs &lt;- list.dirs(rdaBaseDirectory, recursive = F) # define the model we want to use (this can be &#39;dnacopy, edivisive, or HMM&#39;) model = &#39;edivisive&#39; modeldirs &lt;- list.dirs(rdaBaseDirectory, recursive = F) ####### # Run # ####### # run for edivisive cl_list_edivisive &lt;- list() for (i in 1:(length(inputdirs))) { # function cl_list_edivisive[[paste0(&#39;kra&#39;, str_extract(pattern = &#39;\\\\d{3}&#39;, inputdirs[i]))]] &lt;- quality_check(inputdir = inputdirs[i], model = &#39;edivisive&#39;) } ######## # Save # ######## save(cl_list_edivisive, file = &#39;../cna_analysis/rda/subclonal_dynamics/cl_list_edivisive_paired.rda&#39;) ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/cl_list_edivisive_paired.rda&#39;) ################# # Quality check # ################# qual_summary &lt;- lapply(cl_list_edivisive, check_quality) ####### # Run # ####### select_files_edivisive &lt;- lapply(cl_list_edivisive, quality_select, spik = 0.7, bhat = 0) ######## # Save # ######## save(select_files_edivisive, file = &#39;../cna_analysis/rda/subclonal_dynamics/select_files_edivisive.rda&#39;) ############### # Description # ############### # After AneuFinder&#39;s inbuild quaility selection, there are still some evident # noisy single cells, that appear on the heatmap as if having very high and # unstructured ploidy. These single cell&#39;s will be removed manually here. The cells # were selected by inspecting standard AneuFinder heatmaps on the post-quality # selected files (code not shown). ######## # Data # ######## # loading files after quality selection load(&#39;../cna_analysis/rda/subclonal_dynamics/select_files_edivisive.rda&#39;) ########## # Select # ########## # removing karyotypes that are clearly artefacts. The karyotypes are # selected based on the figures in figs -&gt; genomeheatmap_afterqc -&gt; edivisive kra003_remove &lt;- as.character(c( 272, 122 , 33 , 198 , 372, 116 , 105 , 104, 175 , 341 , 30, 12 , 280 , 215 , 31 , 139 , 295 , 370 , 337 , 307 , 170 ,80 , 357 , 34, 21 , 60 , 129 , 318 , 39 , 365, 113 , 89 , 4 , 57 , 162 , 20 , 135 , 235 , 377 , 181 , 46 , 84 , 186 , 81, 257 , 225 , 191 , 269)) kra004_remove &lt;- as.character(c(266, 251, 375, 256, 303, 179, 160, 290, 368, 28, 334, 211, 261, 58, 133, 115, 161, 20, 162, 112, 314, 181, 264, 268, 268, 30, 127, 98, 191, 383, 232, 104, 350, 163, 377, 323, 333, 224, 242, 184, 244, 277, 102, 21, 93, 149, 101, 332, 188, 225, 135)) kra005_remove &lt;- as.character(c(89, 159, 61, 155, 146, 141, 30, 174, 95, 262, 264, 48, 152, 103, 92, 116, 297, 333)) kra006_remove &lt;- as.character(c(380, 176, 328, 255, 4, 60, 264, 111, 173)) kra007_remove &lt;- as.character(c(37, 366, 213, 262, 83, 78, 10, 351)) ## diploid subclone91, 363, 275)) kra008_remove &lt;- as.character(c(70, 143, 77, 144, 146, 189, 35, 170, 30, 119, 65, 51, 107, 362, 58 ,125, 66 ,210 ,160 ,186, 102, 37, 226, 183, 59, 159, 46, 87, 118, 285, 69, 109)) # diploid subclone # 287, 302, 212, 15, # 115, 166, 126, 17, 95, 231, 19, 104, # 86, 138, 105, 116, 81 ,130, 88, 61)) kra009_remove &lt;- as.character(c(239, 347, 94, 65, 91, 163, 246, 6 ,116, 330, 126, 76, 54, 57, 107 ,181, 154, 137, 60, 114, 55, 81, 179, 241, 75, 142, 329, 323)) # diploid subclone kra009 74, 59, 375, 112, 92, 99, # 105 kra010_remove &lt;- as.character(c(363, 217, 242, 238, 27, 46, 189, 28, 216, 84, 234, 71, 95, 60, 86, 181, 172, 42, 355, 58, 43, 132, 262, 176, 143,311, 203, 297,307, 3, 227, 72, 177, 115, 54, 258)) kra022_remove &lt;- as.character(c(5, 31, 161)) # kra003_subclone&lt;- as.character(c(372, 173, 274, 108, 39, 289)) kra023_remove &lt;- as.character(c(96, 199, 246, 135, 104, 5)) # kra004_subclone&lt;- as.character(c(92, 102, 252, 181, # 264, 258, 290, 268) kra024_remove &lt;- as.character(c(193, 344, 337, 356, 85,86,309,52, 188,374, 176,53, 87,169,36,115, 45,281,66)) # kra005_subclone &lt;- as.character(c(297, 92, 113, 103, # 152, 48, 333)) kra025_remove &lt;- as.character(c(141, 257,85,183,127)) # kra006_subclone &lt;- as.character(c(380)) kra026_remove &lt;- as.character(c(318, 287, 260, 208, 247, 75, 285, 376, 238, 200, 215, 362, 49)) # kra007_subclone &lt;- as.character(c(318, 292, 381, 319, # 198, 208, 351, 353, # 285, 379)) kra027_remove &lt;- as.character(c(339, 375, 141, 126, 346, 204, 69, 343, 377, 364, 298, 79)) # kra008_subclone &lt;- as.character(c(69, 87, 60, 61, # 143, 35, 241, 202)) kra028_remove &lt;- as.character(c(37, 178, 167, 225, 125, 90, 249, 50,66, 327 )) # kra009_subclone1 &lt;- as.character(c(375)) kra029_remove &lt;- as.character(c(14, 277, 353, 203, 137 )) kra030_remove &lt;- as.character(c(341, 177, 111, 157, 226, 209, 150, 301, 158, 121, 273, 190, 47, 18 )) kra031_remove &lt;- as.character(c(159, 217, 261, 122, 60, 201, 153)) kra032_remove &lt;- as.character(c(349, 347, 58, 370, 284, 366, 326, 373, 306, 27, 138, 113, 348, 22, 24, 103, 218, 181)) # kra010 has three subclones!! # kra010_subclone1 &lt;- as.character(c(355,34,166,139, # 19, 213, 357, 57, # 72)) # kra010_subclone2 &lt;- 317 t/m 304 # kra010_subclone2 &lt; 235 t/m 176 ########## # Remove # ########## kra003 &lt;- remove_selection(select_files_edivisive$kra003, kra003_remove) kra004 &lt;- remove_selection(select_files_edivisive$kra004, kra004_remove) kra005 &lt;- remove_selection(select_files_edivisive$kra005, kra005_remove) kra006 &lt;- remove_selection(select_files_edivisive$kra006, kra006_remove) kra007 &lt;- remove_selection(select_files_edivisive$kra007, kra007_remove) kra008 &lt;- remove_selection(select_files_edivisive$kra008, kra008_remove) kra009 &lt;- remove_selection(select_files_edivisive$kra009, kra009_remove) kra010 &lt;- remove_selection(select_files_edivisive$kra010, kra010_remove) kra022 &lt;- remove_selection(select_files_edivisive$kra022, kra022_remove) kra023 &lt;- remove_selection(select_files_edivisive$kra023, kra023_remove) kra024 &lt;- remove_selection(select_files_edivisive$kra024, kra024_remove) kra025 &lt;- remove_selection(select_files_edivisive$kra025, kra025_remove) kra026 &lt;- remove_selection(select_files_edivisive$kra026, kra026_remove) kra027 &lt;- remove_selection(select_files_edivisive$kra027, kra027_remove) kra028 &lt;- remove_selection(select_files_edivisive$kra028, kra028_remove) kra029 &lt;- remove_selection(select_files_edivisive$kra029, kra029_remove) kra030 &lt;- remove_selection(select_files_edivisive$kra030, kra030_remove) kra031 &lt;- remove_selection(select_files_edivisive$kra031, kra031_remove) kra032 &lt;- remove_selection(select_files_edivisive$kra032, kra032_remove) man_select_files_edivisive &lt;- list(kra003 = kra003, kra004 = kra004, kra005 = kra005, kra006 = kra006, kra007 = kra007, kra008 = kra008, kra009 = kra009, kra010 = kra010, kra022 = kra022, kra023 = kra023, kra024 = kra024, kra025 = kra025, kra026 = kra026, kra027 = kra027, kra028 = kra028, kra029 = kra029, kra030 = kra030, kra031 = kra031, kra032 = kra032 ) ######## # Save # ######## save(man_select_files_edivisive, file = &#39;../cna_analysis/rda/subclonal_dynamics/man_select_files_edivisive.rda&#39; ) 3.3 Summary statistics of copy number alterations ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/man_select_files_edivisive.rda&#39; ) ########### # Wrangle # ########### # removing HUB181I kra024 en kra025 man_select_files_edivisive &lt;- man_select_files_edivisive[!names(man_select_files_edivisive) %in% c(&#39;kra024&#39;, &#39;kra025&#39;)] # !!! GITHUB SPECIFIC CODE !!! # # adding &#39;../cna_analysis/&#39; to each path within man_select_files_edivisive man_select_files_edivisive &lt;- lapply(man_select_files_edivisive, function(x) paste0(&quot;../cna_analysis/&quot;, x)) ####### # Run # ####### # loading segment data from files files_loaded &lt;- loadFromFiles(unlist(man_select_files_edivisive), check.class=c(&#39;GRanges&#39;, &#39;GRangesList&#39;, &#39;aneuHMM&#39;, &#39;aneuBiHMM&#39;)) # Computing the total number of cells sequenced length(files_loaded) ## [1] 2944 # computing the total sum of unique CNAs per single cell and store in a vector cna_vector &lt;- sapply(files_loaded, function(file) { seg_grange &lt;- file$segments cnas_grange &lt;- seg_grange[seg_grange$copy.number != 2,] return(length(cnas_grange)) }) # Computing the mean CNA per single cell mean(cna_vector) ## [1] 26.98709 # Computing the standard deviation of CNAs per single cell. sd(cna_vector) ## [1] 11.74091 3.4 PCA and K-means plots ######## # Plot # ######## # HUB183 # ###################################################################### # PCA # hub183_pca &lt;- draw_pca( man_select_files_edivisive$kra003, man_select_files_edivisive$kra004, size = 1, legend_position = c(0.65, 0.8) ) hub183_pca # K-means # hub183_kmeans &lt;- k_cluster( man_select_files_edivisive$kra003, man_select_files_edivisive$kra004, cluster = 1, cols = c(&quot;#C6CDF7&quot;), labels = c(&#39;A&#39;), legend_position = c(0.8, 0.85), normalize = T, return_elbow = F ) hub183_kmeans # HUB005 # ###################################################################### # PCA # hub005_pca &lt;- draw_pca( man_select_files_edivisive$kra005, man_select_files_edivisive$kra006, size = 1, legend_position = c(0.65, 0.85) ) hub005_pca # K-means # hub005_kmeans &lt;- k_cluster( man_select_files_edivisive$kra005, man_select_files_edivisive$kra006, cluster = 3, cols = c(&#39;#809aa6&#39;, # greyblue &quot;#D69C4E&quot;, # brown, &quot;#046C9A&quot;), #darkblue labels = c(&#39;A.b&#39;, &#39;B&#39;, &#39;A.a&#39;), legend_position = c(0.8, 0.85), normalize = T, return_elbow = F ) hub005_kmeans # HUB106 # ###################################################################### # PCA # hub106_pca &lt;- draw_pca( man_select_files_edivisive$kra007, man_select_files_edivisive$kra008, size = 1, legend_position = c(0.65, 0.95) ) hub106_pca # K-means # hub106_kmeans &lt;- k_cluster( man_select_files_edivisive$kra007, man_select_files_edivisive$kra008, cluster = 3, cols = c(&quot;#E6A0C4&quot;, # pink &quot;#D8A499&quot;, #brownpink &quot;#7294D4&quot;), # blue labels = c(&#39;A&#39;, &#39;C&#39;, &#39;B&#39;), legend_position = c(0.8, 0.85), normalize = T, return_elbow = F ) hub106_kmeans # HUB062 # ###################################################################### ### Biological replicate 1 ### # PCA # hub062_pca_double &lt;- draw_pca_double( man_select_files_edivisive$kra009, man_select_files_edivisive$kra010, man_select_files_edivisive$kra030, size = 1, legend_position = c(0.05, 0.2) ) hub062_pca_double # &#39;zoom&#39; hub062_pca_double_zoom &lt;- draw_pca_double( man_select_files_edivisive$kra009, man_select_files_edivisive$kra010, man_select_files_edivisive$kra030, size = 15, legend_position = c(-0.05, 0.25) ) + coord_cartesian(xlim = c(-0.016, 0.030), ylim = c(0, 0.06)) + theme( axis.line = element_blank(), axis.text.x = element_blank(), axis.text.y = element_blank(), axis.ticks = element_blank(), axis.title.x = element_blank(), axis.title.y = element_blank(), legend.position = &quot;none&quot;, panel.background = element_blank(), panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.background = element_blank() ) hub062_pca_double_zoom # K-means # hub062_kmeans_double &lt;- k_cluster_double( man_select_files_edivisive$kra009, man_select_files_edivisive$kra010, man_select_files_edivisive$kra030, cluster = 3, cols = c(&quot;#F1BB7B&quot;, #orange like &quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;), #brownish labels = c(&#39;C&#39;, &#39;A&#39;, &#39;B&#39;), legend_position = c(0.05, 0.2), normalize = T, return_elbow = F ) hub062_kmeans_double ### Biological replicate 2 ### # PCA # hub062_pca_rep2 &lt;- draw_pca( man_select_files_edivisive$kra028, man_select_files_edivisive$kra032, size = 1, legend_position = c(0.05, 0.9) ) hub062_pca_rep2 # K-means # hub062_kmeans_rep2 &lt;- k_cluster( man_select_files_edivisive$kra028, man_select_files_edivisive$kra032, cluster = 3, cols = c(&quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;, #brownish &quot;#F1BB7B&quot;), #orange like labels = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), legend_position = c(0.05, 0.9), normalize = T ) hub062_kmeans_rep2 # HUB015 # ###################################################################### # PCA # hub015_pca &lt;- draw_pca( man_select_files_edivisive$kra022, # 10 gy radiated man_select_files_edivisive$kra023, # 0 gy control size = 1, legend_position = c(0.05, 0.8), ssdna004 = T ) # coordinates do not correspond with coordinates in pc1 and pc2! hub015_pca # K-means # hub015_kmeans &lt;- k_cluster( man_select_files_edivisive$kra022, man_select_files_edivisive$kra023, cluster = 3, cols = c(&quot;#f5de90&quot;, &#39;#E1AF00&#39;, &#39;#F21A00&#39;), # red labels = c( &#39;A.a&#39;,&#39;A.b&#39;, &#39;B&#39;), legend_position = c(0.05, 0.8), normalize = T, return_elbow = F ) hub015_kmeans # HUB197 # ###################################################################### # PCA # hub197_pca &lt;- draw_pca( man_select_files_edivisive$kra026, # 10 gy man_select_files_edivisive$kra027, # 0 gy # 0 Gy size = 1, legend_position = c(0.7, 0.8), ssdna004 = T ) hub197_pca # K-means # hub197_kmeans &lt;- k_cluster( man_select_files_edivisive$kra026, man_select_files_edivisive$kra027, cluster = 3, cols = c(&quot;#0B775E&quot;, &#39;#E1BD6D&#39;, &#39;#35274A&#39; ), labels = c(&#39;C&#39;, &#39;B&#39;, &#39;A&#39;), legend_position = c(0.7, 0.8), normalize = T ) hub197_kmeans ####### # END # ####### 3.5 Subclone selection 3.5.1 Selecting subclones #################### # Define subclones # #################### # volgorde: HUB183, 005, 106, 062, 015, 197, 181i # HUB183 # ###################################################################### # Pre-rad # ########### # (kra003) has one clones hub183_prerad_a &lt;- man_select_files_edivisive$kra003 # post-rad # ############ hub183_postrad_a &lt;- man_select_files_edivisive$kra004 # HUB005 # ###################################################################### # pre-rad # ########### hub005_prerad_a.a &lt;- extract_square(man_select_files_edivisive$kra005, NULL, square = c(0.037, -0.0096), x = &#39;&gt;&#39;, y = &#39;&lt;&#39;) # 161 is added erroneously here hub005_prerad_a.a &lt;- hub005_prerad_a.a[hub005_prerad_a.a != 161] hub005_prerad_b &lt;- extract_square(man_select_files_edivisive$kra005, NULL, square = c(0.037, 0.2), x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub005_prerad_a.b &lt;- as.numeric(extract_other_cells(&#39;kra005&#39;, c(hub005_prerad_a.a, hub005_prerad_b))) # here we are going to locate the single cell bam files belonging to one clone. hub005_prerad_a.a &lt;- unlist(sapply(hub005_prerad_a.a, l_g, kra_num = &#39;KRA-005&#39;, list_cells = man_select_files_edivisive$kra005)) hub005_prerad_a.b &lt;- unlist(sapply(hub005_prerad_a.b, l_g, kra_num = &#39;KRA-005&#39;, list_cells = man_select_files_edivisive$kra005)) hub005_prerad_b &lt;- unlist(sapply(hub005_prerad_b, l_g, kra_num = &#39;KRA-005&#39;, list_cells = man_select_files_edivisive$kra005)) # quick check if we did alright (should be TRUE) length(man_select_files_edivisive$kra005) == length(hub005_prerad_a.a) + length(hub005_prerad_a.b) + length(hub005_prerad_b) # postrad # ########### hub005_postrad_b &lt;- extract_square(man_select_files_edivisive$kra006, NULL, square = c(-0.06, 0.25), # groter # kleiner x = &#39;&gt;&#39;, y = &#39;&lt;&#39;) hub005_postrad_a.b &lt;- c(238, 260) hub005_postrad_a.a &lt;- as.numeric(extract_other_cells(&#39;kra006&#39;, c(hub005_postrad_b, hub005_postrad_a.b))) # here we are going to locate the single cell bam files belonging to one clone. hub005_postrad_b &lt;- unlist(sapply(hub005_postrad_b, l_g, kra_num = &#39;KRA-006&#39;, list_cells = man_select_files_edivisive$kra006)) hub005_postrad_a.a &lt;- unlist(sapply(hub005_postrad_a.a, l_g, kra_num = &#39;KRA-006&#39;, list_cells = man_select_files_edivisive$kra006)) hub005_postrad_a.b &lt;- unlist(sapply(hub005_postrad_a.b, l_g, kra_num = &#39;KRA-006&#39;, list_cells = man_select_files_edivisive$kra006)) # quick check if we did it alright length(man_select_files_edivisive$kra006) == length(hub005_postrad_b) + length(hub005_postrad_a.a) + length(hub005_postrad_a.b) # HUB106 # ###################################################################### # prerad # ########## hub106_prerad_a &lt;- extract_square(man_select_files_edivisive$kra007, NULL, square = c(-0.006, 0.2), x = &#39;&gt;&#39;, y = &#39;&lt;&#39;) hub106_prerad_b &lt;- extract_square(man_select_files_edivisive$kra007, NULL, square = c(-0.006, 0.2), x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub106_prerad_c &lt;- extract_square(man_select_files_edivisive$kra007, NULL, square = c(-0.3, 0.2), x = &#39;&gt;&#39;, y = &#39;&gt;&#39;) hub106_prerad_a &lt;- unlist(sapply(hub106_prerad_a, l_g, kra_num = &#39;KRA-007&#39;, list_cells = man_select_files_edivisive$kra007)) hub106_prerad_b &lt;- unlist(sapply(hub106_prerad_b, l_g, kra_num = &#39;KRA-007&#39;, list_cells = man_select_files_edivisive$kra007)) hub106_prerad_c &lt;- unlist(sapply(hub106_prerad_c, l_g, kra_num = &#39;KRA-007&#39;, list_cells = man_select_files_edivisive$kra007)) # quick check length(man_select_files_edivisive$kra007) == length(hub106_prerad_a) + length(hub106_prerad_b) + length(hub106_prerad_c) # postrad # ########### hub106_postrad_c &lt;- extract_square(man_select_files_edivisive$kra008, NULL, square = c(-0.1, 0.2), x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub106_postrad_a &lt;- extract_square(man_select_files_edivisive$kra008, NULL, square = c(-0.1, -0.014), x = &#39;&gt;&#39;, y = &#39;&lt;&#39;) remove_a &lt;- c(349, 164) add_a &lt;- c(382, 12, 16) hub106_postrad_a &lt;- hub106_postrad_a[!hub106_postrad_a %in% remove_a] hub106_postrad_a &lt;- c(hub106_postrad_a, add_a) hub106_postrad_b &lt;- extract_square(man_select_files_edivisive$kra008, NULL, square = c(-0.1, -0.014), x = &#39;&gt;&#39;, y = &#39;&gt;&#39;) remove_b &lt;- add_a add_b &lt;- remove_a hub106_postrad_b &lt;- hub106_postrad_b[!hub106_postrad_b %in% remove_b] hub106_postrad_b &lt;- c(hub106_postrad_b, add_b) hub106_postrad_a &lt;- unlist(sapply(hub106_postrad_a, l_g, kra_num = &#39;KRA-008&#39;, list_cells = man_select_files_edivisive$kra008)) hub106_postrad_b &lt;- unlist(sapply(hub106_postrad_b, l_g, kra_num = &#39;KRA-008&#39;, list_cells = man_select_files_edivisive$kra008)) hub106_postrad_c &lt;- unlist(sapply(hub106_postrad_c, l_g, kra_num = &#39;KRA-008&#39;, list_cells = man_select_files_edivisive$kra008)) length(man_select_files_edivisive$kra008) == length(hub106_postrad_a) + length(hub106_postrad_b) + length(hub106_postrad_c) # HUB106 # ###################################################################### ########################## # biological replicate 1 # ########################## # prerad # ########## hub062_prerad_a &lt;- c(257, 352) hub062_prerad_c &lt;- c(59, 99, 74, 105, 375, 112, 92) hub062_prerad_b &lt;- as.numeric(extract_other_cells(&#39;kra009&#39;, c(hub062_prerad_a, hub062_prerad_c))) hub062_prerad_a &lt;- unlist(sapply(hub062_prerad_a, l_g, kra_num = &#39;KRA-009&#39;, list_cells = man_select_files_edivisive$kra009)) hub062_prerad_b &lt;- unlist(sapply(hub062_prerad_b, l_g, kra_num = &#39;KRA-009&#39;, list_cells = man_select_files_edivisive$kra009)) hub062_prerad_c &lt;- unlist(sapply(hub062_prerad_c, l_g, kra_num = &#39;KRA-009&#39;, list_cells = man_select_files_edivisive$kra009)) length(man_select_files_edivisive$kra009) == length(hub062_prerad_a) + length(hub062_prerad_b) + length(hub062_prerad_c) # counting percentage of subclone a length(hub062_prerad_a) / (length(hub062_prerad_a) + length(hub062_prerad_b) + length(hub062_prerad_c)) *100 # postrad cycle 1 # ################### hub062_postrad_c &lt;- c(57, 19, 69, 139, 17, 160, 244) hub062_postrad_b &lt;- extract_square(man_select_files_edivisive$kra010, NULL, square = c(0.2, 0), x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub062_postrad_a &lt;- as.numeric(extract_other_cells(&#39;kra010&#39;, c(hub062_postrad_c, hub062_postrad_b))) hub062_postrad_a &lt;- unlist(sapply(hub062_postrad_a, l_g, kra_num = &#39;KRA-010&#39;, list_cells = man_select_files_edivisive$kra010)) hub062_postrad_b &lt;- unlist(sapply(hub062_postrad_b, l_g, kra_num = &#39;KRA-010&#39;, list_cells = man_select_files_edivisive$kra010)) hub062_postrad_c &lt;- unlist(sapply(hub062_postrad_c, l_g, kra_num = &#39;KRA-010&#39;, list_cells = man_select_files_edivisive$kra010)) length(man_select_files_edivisive$kra010) == length(hub062_postrad_a) + length(hub062_postrad_b) + length(hub062_postrad_c) # counting percentage of subclone a length(hub062_postrad_a) / (length(hub062_postrad_b) + length(hub062_postrad_b) + length(hub062_postrad_c)) *100 # postrad cycle 2 # ################### hub062_postrad_c2_c &lt;- c(221) hub062_postrad_c2_a &lt;- as.numeric(extract_other_cells(&#39;kra030&#39;, c(hub062_postrad_c2_c))) hub062_postrad_c2_c &lt;- unlist(sapply(hub062_postrad_c2_c, l_g, kra_num = &#39;KRA-030&#39;, list_cells = man_select_files_edivisive$kra030)) hub062_postrad_c2_a &lt;- unlist(sapply(hub062_postrad_c2_a, l_g, kra_num = &#39;KRA-030&#39;, list_cells = man_select_files_edivisive$kra030)) length(man_select_files_edivisive$kra030) == length(hub062_postrad_c2_c) + length(hub062_postrad_c2_a) ########################## # biological replicate 2 # ########################## # prerad # ######### hub062biological_prerad_b &lt;- extract_square(man_select_files_edivisive$kra028, NULL, square = c(0.1, -0.1), x = &#39;&lt;&#39;, y = &#39;&gt;&#39; ) hub062biological_prerad_c &lt;- extract_square(man_select_files_edivisive$kra028, NULL, square = c(0.1, 0.2), x = &#39;&gt;&#39;, y = &#39;&lt;&#39; ) hub062biological_prerad_a &lt;- extract_square(man_select_files_edivisive$kra028, NULL, square = c(0.1, -0.1), x = &#39;&lt;&#39;, y = &#39;&lt;&#39; ) hub062biological_prerad_a &lt;- unlist(sapply(hub062biological_prerad_a, l_g, kra_num = &#39;KRA-028&#39;, list_cells = man_select_files_edivisive$kra028)) hub062biological_prerad_b &lt;- unlist(sapply(hub062biological_prerad_b, l_g, kra_num = &#39;KRA-028&#39;, list_cells = man_select_files_edivisive$kra028)) hub062biological_prerad_c &lt;- unlist(sapply(hub062biological_prerad_c, l_g, kra_num = &#39;KRA-028&#39;, list_cells = man_select_files_edivisive$kra028)) length(man_select_files_edivisive$kra028) == length(hub062biological_prerad_a)+ length(hub062biological_prerad_b)+length(hub062biological_prerad_c) # postrad # ########### hub062biological_postrad_a &lt;- man_select_files_edivisive$kra032 # HUB106 # ###################################################################### # pre-rad # ########### hub015_prerad_b &lt;- c(233) hub015_prerad_a.b &lt;- extract_other_cells(&#39;kra023&#39;, c(hub015_prerad_b)) hub015_prerad_a.b &lt;- unlist(sapply(hub015_prerad_a.b, l_g, kra_num = &#39;KRA-023&#39;, list_cells = man_select_files_edivisive$kra023)) hub015_prerad_b &lt;- unlist(sapply(hub015_prerad_b, l_g, kra_num = &#39;KRA-023&#39;, list_cells = man_select_files_edivisive$kra023)) length(man_select_files_edivisive$kra023) == length(hub015_prerad_a.b) + length(hub015_prerad_b) # post-rad # ############ hub015_postrad_b &lt;- extract_square(man_select_files_edivisive$kra022, NULL, square = c(-0.1, 0.15), # kleiner # kleiner x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub015_postrad_a.a &lt;- extract_square(man_select_files_edivisive$kra022, NULL, square = c(-0.1, 0), x = &#39;&gt;&#39;, # groter # kleiner y = &#39;&lt;&#39; ) hub015_postrad_a.b &lt;- extract_other_cells(&#39;kra022&#39;, c(hub015_postrad_b, hub015_postrad_a.a)) hub015_postrad_a.a &lt;- unlist(sapply(hub015_postrad_a.a, l_g, kra_num = &#39;KRA-022&#39;, list_cells = man_select_files_edivisive$kra022)) hub015_postrad_a.b &lt;- unlist(sapply(hub015_postrad_a.b, l_g, kra_num = &#39;KRA-022&#39;, list_cells = man_select_files_edivisive$kra022)) hub015_postrad_b &lt;- unlist(sapply(hub015_postrad_b, l_g, kra_num = &#39;KRA-022&#39;, list_cells = man_select_files_edivisive$kra022)) length(man_select_files_edivisive$kra022) == length(hub015_postrad_a.a) + length(hub015_postrad_a.b) + length(hub015_postrad_b) # HUB197 # ###################################################################### # prerad # ########## hub197_prerad_a &lt;- c(279, 240, 7, 242, 177, 372, 338, 255, 308, 209, 334, 153, 266, 181, 284, 238, 370, 275, 272, 362, 231, 355, 226, 269) hub197_prerad_b &lt;- c(364, 298, 47, 111, 74, 341, 369, 179, 371, 363, 270, 374, 368, 235, 259, 79, 197, 316, 365, 167) hub197_prerad_c &lt;- as.numeric(extract_other_cells(&#39;kra027&#39;, c(hub197_prerad_a, hub197_prerad_b))) hub197_prerad_a &lt;- unlist(sapply(hub197_prerad_a, l_g, kra_num = &#39;KRA-027&#39;, list_cells = man_select_files_edivisive$kra027)) hub197_prerad_b &lt;- unlist(sapply(hub197_prerad_b, l_g, kra_num = &#39;KRA-027&#39;, list_cells = man_select_files_edivisive$kra027)) hub197_prerad_c &lt;- unlist(sapply(hub197_prerad_c, l_g, kra_num = &#39;KRA-027&#39;, list_cells = man_select_files_edivisive$kra027)) length(man_select_files_edivisive$kra027) == length(hub197_prerad_a) + length(hub197_prerad_b) + length(hub197_prerad_c) # postrad # hub197_postrad_a &lt;- man_select_files_edivisive$kra026 # HUB181I # ###################################################################### # prerad # ########## hub181i_prerad_a &lt;- extract_square(man_select_files_edivisive$kra025, NULL, square = c(0, 0.1), # kleiner # kleiner x = &#39;&lt;&#39;, # groter # kleiner y = &#39;&lt;&#39; ) hub181i_prerad_b &lt;- extract_other_cells(&#39;kra025&#39;, c(hub181i_prerad_a)) hub181i_prerad_a &lt;- unlist(sapply(hub181i_prerad_a, l_g, kra_num = &#39;KRA-025&#39;, list_cells = man_select_files_edivisive$kra025)) hub181i_prerad_b &lt;- unlist(sapply(hub181i_prerad_b, l_g, kra_num = &#39;KRA-025&#39;, list_cells = man_select_files_edivisive$kra025)) length(man_select_files_edivisive$kra025) == length(hub181i_prerad_a) + length(hub181i_prerad_b) # postrad # ########### hub181i_postrad_a &lt;- extract_square(man_select_files_edivisive$kra024, NULL, square = c(-0.05, 0.15), # kleiner # kleiner x = &#39;&lt;&#39;, # groter # kleiner y = &#39;&lt;&#39; ) hub181i_postrad_b &lt;- as.numeric(extract_other_cells(&#39;kra024&#39;, c(hub181i_postrad_a))) hub181i_postrad_a &lt;- unlist(sapply(hub181i_postrad_a, l_g, kra_num = &#39;KRA-024&#39;, list_cells = man_select_files_edivisive$kra024)) hub181i_postrad_b &lt;- unlist(sapply(hub181i_postrad_b, l_g, kra_num = &#39;KRA-024&#39;, list_cells = man_select_files_edivisive$kra024)) length(man_select_files_edivisive$kra024) == length(hub181i_postrad_a) + length(hub181i_postrad_b) #################### # Subclone listing # #################### subclone_list &lt;- list(hub183_prerad_a, hub183_postrad_a, hub005_prerad_a.a, hub005_prerad_a.b, hub005_prerad_b, hub005_postrad_a.a, hub005_postrad_a.b, hub005_postrad_b, hub106_prerad_a, hub106_prerad_b, hub106_prerad_c, hub106_postrad_a, hub106_postrad_b, hub106_postrad_c, hub062_prerad_a, hub062_prerad_b,hub062_prerad_c, hub062_postrad_a, hub062_postrad_b,hub062_postrad_c, hub062_postrad_c2_a, hub062_postrad_c2_c, hub015_prerad_a.b, hub015_prerad_b, hub015_postrad_a.a, hub015_postrad_a.b, hub015_postrad_b, hub181i_prerad_a, hub181i_prerad_b, hub181i_postrad_a, hub181i_postrad_b, hub197_prerad_a, hub197_prerad_b, hub197_prerad_c, hub197_postrad_a, hub062biological_prerad_a,hub062biological_prerad_b,hub062biological_prerad_c, hub062biological_postrad_a ) names(subclone_list) &lt;- c(&#39;hub183_prerad_a&#39;, &#39;hub183_postrad_a&#39;, &#39;hub005_prerad_a.a&#39;, &#39;hub005_prerad_a.b&#39;, &#39;hub005_prerad_b&#39;, &#39;hub005_postrad_a.a&#39;, &#39;hub005_postrad_a.b&#39;, &#39;hub005_postrad_b&#39;, &#39;hub106_prerad_a&#39;, &#39;hub106_prerad_b&#39;, &#39;hub106_prerad_c&#39;, &#39;hub106_postrad_a&#39;, &#39;hub106_postrad_b&#39;, &#39;hub106_postrad_c&#39;, &#39;hub062_prerad_a&#39;, &#39;hub062_prerad_b&#39;, &#39;hub062_prerad_c&#39;, &#39;hub062_postrad_a&#39;, &#39;hub062_postrad_b&#39;, &#39;hub062_postrad_c&#39;, &#39;hub062_postrad_c2_a&#39;,&#39;hub062_postrad_c2_c&#39;, &#39;hub015_prerad_a.b&#39;, &#39;hub015_prerad_b&#39;, &#39;hub015_postrad_a.a&#39;, &#39;hub015_postrad_a.b&#39;, &#39;hub015_postrad_b&#39;, &quot;hub181i_prerad_a&quot;, &quot;hub181i_prerad_b&quot;, &quot;hub181i_postrad_a&quot;, &quot;hub181i_postrad_b&quot;, &quot;hub197_prerad_a&quot;, &quot;hub197_prerad_b&quot;, &quot;hub197_prerad_c&quot;, &quot;hub197_postrad_a&quot;, &#39;hub062biological_prerad_a&#39;,&#39;hub062biological_prerad_b&#39;,&#39;hub062biological_prerad_c&#39;, &#39;hub062biological_postrad_a&#39; ) 3.5.2 Subclone statistics # !!! This code was slightly adjusted so to run in Rmarkdown #################### # Subclone listing # #################### subclone_list &lt;- c(&#39;hub183_prerad_a&#39;, &#39;hub183_postrad_a&#39;, &#39;hub005_prerad_a.a&#39;, &#39;hub005_prerad_a.b&#39;, &#39;hub005_prerad_b&#39;, &#39;hub005_postrad_a.a&#39;, &#39;hub005_postrad_a.b&#39;, &#39;hub005_postrad_b&#39;, &#39;hub106_prerad_a&#39;, &#39;hub106_prerad_b&#39;, &#39;hub106_prerad_c&#39;, &#39;hub106_postrad_a&#39;, &#39;hub106_postrad_b&#39;, &#39;hub106_postrad_c&#39;, &#39;hub062_prerad_a&#39;, &#39;hub062_prerad_b&#39;, &#39;hub062_prerad_c&#39;, &#39;hub062_postrad_a&#39;, &#39;hub062_postrad_b&#39;, &#39;hub062_postrad_c&#39;, &#39;hub062_postrad_c2_a&#39;,&#39;hub062_postrad_c2_c&#39;, &#39;hub015_prerad_a.b&#39;, &#39;hub015_prerad_b&#39;, &#39;hub015_postrad_a.a&#39;, &#39;hub015_postrad_a.b&#39;, &#39;hub015_postrad_b&#39;, &quot;hub181i_prerad_a&quot;, &quot;hub181i_prerad_b&quot;, &quot;hub181i_postrad_a&quot;, &quot;hub181i_postrad_b&quot;, &quot;hub197_prerad_a&quot;, &quot;hub197_prerad_b&quot;, &quot;hub197_prerad_c&quot;, &quot;hub197_postrad_a&quot;, &#39;hub062biological_prerad_a&#39;,&#39;hub062biological_prerad_b&#39;,&#39;hub062biological_prerad_c&#39;, &#39;hub062biological_postrad_a&#39; ) ############## # Statistics # ############## # extract only prerad subclones bl &lt;- subclone_list[grep(pattern = &#39;prerad&#39;, subclone_list)] # remove biological replicate bl &lt;- bl[1:(length(bl)-3)] # cell line list cline &lt;- c(&#39;hub183&#39;, &#39;hub005&#39;, &#39;hub106&#39;, &#39;hub062&#39;, &#39;hub015&#39;, &#39;hub197&#39;) subclones_per_organoids &lt;- unlist(lapply(cline, function(x){ length(grep(x, bl)) })) # note that 005 and 015 have sub sub clone (variance less than 5%) so we should see them as one. # hub005 subclones_per_organoids[2] &lt;- subclones_per_organoids[2] - 1 # computing mean number of clones per organoid mean(subclones_per_organoids) ## [1] 2.333333 # computing standard deviation of clones per organoids sd(subclones_per_organoids) ## [1] 0.8164966 3.6 Single cell copy number heatmap plots ######## # Data # ######## load(&#39;..cna/analysis/rda/subclonal_dynamics/subclone_list.rda&#39;) ####### # Run # ####### # list of patterns to grepl unique sets clines &lt;- c(&#39;hub183&#39;, &#39;hub005&#39;, &#39;hub106&#39;, &#39;hub062_&#39;, &#39;hub015&#39;, &#39;hub181i&#39;,&#39;hub197&#39;, &#39;hub062biological&#39;) subclone_classes &lt;- lapply(clines, subclone_classes_for_genomeheatmap, list_of_subclones = subclone_list) ######## # Save # ######## save(subclone_classes, file = &#39;../cna_analysis/rda/subclonal_dynamics/subclone_classes.rda&#39;) ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/man_select_files_edivisive.rda&#39;) load(&#39;../cna_analysis/rda/subclonal_dynamics/subclone_classes.rda&#39;) ######### # Paths # ######### paths &lt;- &#39;figs/subclonal_dynamics&#39; # HUB183 # ###################################################################### # prerad # hub183_prerad &lt;- subclone_classes[[1]][grepl(subclone_classes[[1]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub183_prerad$path, path = paths, classes_daan = hub183_prerad$class, class.col = c(&quot;#C6CDF7&quot;), name = &#39;hub183_gwh_prerad&#39; ) HUB183 baseline hub183_postrad &lt;- subclone_classes[[1]][grepl(subclone_classes[[1]]$class, pattern = &#39;postrad&#39;), ] # postrad # genomeheatmap( selected.files = hub183_postrad$path, path = paths, classes_daan = hub183_postrad$class, class.col = c(&quot;#C6CDF7&quot;), name = &#39;hub183_gwh_postrad&#39; ) HUB183 recurrence # HUB005 # ###################################################################### # prerad # hub005_prerad &lt;- subclone_classes[[2]][grepl(subclone_classes[[2]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub005_prerad$path, path = paths, classes_daan = hub005_prerad$class, name = &#39;hub005_gwh_prerad&#39;, class.col = c(&quot;#046C9A&quot;, #darkblue &#39;#809aa6&#39;, # greyblue &quot;#D69C4E&quot;) # brown ) HUB005 baseline # postrad # hub005_postrad &lt;- subclone_classes[[2]][grepl(subclone_classes[[2]]$class, pattern = &#39;postrad&#39;), ] genomeheatmap( selected.files = hub005_postrad$path, path = paths, classes_daan = hub005_postrad$class, name = &#39;hub005_gwh_postrad&#39;, class.col = c(&#39;#046C9A&#39;, &#39;#809aa6&#39;, &#39;#D69C4E&#39; )) HUB005 recurrence # HUB106 # ###################################################################### # prerad # hub106_prerad &lt;- subclone_classes[[3]][grepl(subclone_classes[[3]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub106_prerad$path, path = paths, classes_daan = hub106_prerad$class, name = &#39;hub106_gwh_prerad&#39;, class.col = c(&quot;#E6A0C4&quot;, # pink &quot;#7294D4&quot;, # blue &quot;#D8A499&quot;) #brownpink ) HUB106 baseline # postrad # hub106_postrad &lt;- subclone_classes[[3]][grepl(subclone_classes[[3]]$class, pattern = &#39;postrad&#39;), ] genomeheatmap( selected.files = hub106_postrad$path, path = paths, classes_daan = hub106_postrad$class, name = &#39;hub106_gwh_postrad&#39;, class.col = c(&quot;#E6A0C4&quot;, # pink &quot;#7294D4&quot;, # blue &quot;#D8A499&quot;) #brownpink) ) HUB106 recurrence # HUB062 # ###################################################################### ### Biological replicate 1 ### # prerad # hub062_prerad &lt;- subclone_classes[[4]][grepl(subclone_classes[[4]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub062_prerad$path, path = paths, classes_daan = hub062_prerad$class, name = &#39;hub062_gwh_prerad&#39;, class.col = c(&quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;, #brownish &quot;#F1BB7B&quot;) # orange ) HUB062 baseline # postrad cycle 1 # hub062_postrad &lt;- subclone_classes[[4]][grepl(subclone_classes[[4]]$class, pattern = &#39;postrad&#39;), ] # remove postrad_c2 hub062_postrad &lt;- hub062_postrad[!grepl(hub062_postrad$class, pattern = &#39;postrad_c2&#39;), ] genomeheatmap( selected.files = hub062_postrad$path, path = paths, name = &#39;hub062_gwh_postrad_c1&#39;, classes_daan = hub062_postrad$class, class.col = c(&quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;, #brownish &quot;#F1BB7B&quot;) # orange ) HUB062 recurrence hub062_postrad_c2 &lt;- subclone_classes[[4]][grepl(subclone_classes[[4]]$class, pattern = &#39;postrad_c2&#39;), ] # postrad cycle 2 # genomeheatmap( selected.files = hub062_postrad_c2$path, path = paths, name = &#39;hub062_gwh_postrad_c2&#39;, classes_daan = hub062_postrad_c2$class, class.col = c(&quot;#FD6467&quot;, # pinkish red &quot;#F1BB7B&quot;) # orange ) HUB062 recurrence Cycle 2 # prerad # hub062_biological_prerad &lt;- subclone_classes[[8]][grepl(subclone_classes[[8]]$class, pattern = &#39;prerad&#39;),] genomeheatmap(selected.files = hub062_biological_prerad$path, path = paths, classes_daan= hub062_biological_prerad$class, name = &#39;hub062_gwh_prerad_rep2&#39;, class.col = c( &quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;, #brownish &quot;#F1BB7B&quot; #orange like )) HUB062 baseline rep2 # postrad # hub062_biological_postrad &lt;- subclone_classes[[8]][grepl(subclone_classes[[8]]$class, pattern = &#39;postrad&#39;),] genomeheatmap(selected.files = hub062_biological_postrad$path, path = paths, name = &#39;hub062_gwh_postrad_rep2&#39;, classes_daan= hub062_biological_postrad$class, class.col = c( &quot;#FD6467&quot; )) HUB062 recurrence rep2 # HUB015 # ###################################################################### # prerad # hub015_prerad &lt;- subclone_classes[[5]][grepl(subclone_classes[[5]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub015_prerad$path, path = paths, classes_daan = hub015_prerad$class, name = &#39;hub015_gwh_prerad&#39;, class.col = c(&#39;#E1AF00&#39;, &#39;#F21A00&#39;) ) HUB015 baseline # postrad hub015_postrad &lt;- subclone_classes[[5]][grepl(subclone_classes[[5]]$class, pattern = &#39;postrad&#39;), ] genomeheatmap( selected.files = hub015_postrad$path, path = paths, classes_daan = hub015_postrad$class, name = &#39;hub015_gwh_postrad&#39;, class.col = c(&#39;#f5de90&#39;, &#39;#E1AF00&#39;, &#39;#F21A00&#39;)) HUB015 recurrence # HUB197 # ###################################################################### # prerad # hub197_prerad &lt;- subclone_classes[[7]][grepl(subclone_classes[[7]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub197_prerad$path, path = paths, classes_daan = hub197_prerad$class, name = &#39;hub197_gwh_prerad&#39;, class.col = c(&quot;#35274A&quot;, # purp &quot;#E1BD6D&quot;, # sand &#39;#0B775E&#39; # green ) ) HUB197 baseline # postrad # hub197_postrad &lt;- subclone_classes[[7]][grepl(subclone_classes[[7]]$class, pattern = &#39;postrad&#39;), ] genomeheatmap( selected.files = hub197_postrad$path, path = paths, name = &#39;hub197_gwh_postrad&#39;, classes_daan = hub197_postrad$class, class.col = c(&quot;#35274A&quot;) ) HUB197 recurrence 3.7 Fisher’s exact test ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/subclone_classes.rda&#39;) ####### # Run # ####### # For HUB183, Fisher&#39;s test will produces an error, because HUB183 has only 1 subclone before and after treatment # Computing Fisher&#39;s exact test to compare HUB005 prerad versus postrad HUB005 &lt;- perform_fisher( subclone_classes[[2]], population1 = unique(subclone_classes[[2]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[2]]$class))], population2 = unique(subclone_classes[[2]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[2]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB106 prerad versus postrad HUB106 &lt;- perform_fisher( subclone_classes[[3]], population1 = unique(subclone_classes[[3]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[3]]$class))], population2 = unique(subclone_classes[[3]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[3]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB062 prerad versus HUB062 postrad cycle 1 HUB062_cycle1 &lt;- perform_fisher( subclone_classes[[4]], population1 = unique(subclone_classes[[4]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[4]]$class))], population2 = unique(subclone_classes[[4]]$class)[!grepl(&#39;prerad|postrad_c2&#39;, unique(subclone_classes[[4]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB062 postrad cycle 1 versus HUB062 postrad cycle 1 HUB062_cycle2 &lt;- perform_fisher( subclone_classes[[4]], population1 = unique(subclone_classes[[4]]$class)[!grepl(&#39;prerad|postrad_c2&#39;, unique(subclone_classes[[4]]$class))], population2 = unique(subclone_classes[[4]]$class)[grepl(&#39;postrad_c2&#39;, unique(subclone_classes[[4]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB015 prerad versus postrad HUB015 &lt;- perform_fisher( subclone_classes[[5]], population1 = unique(subclone_classes[[5]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[5]]$class))], population2 = unique(subclone_classes[[5]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[5]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB197 prerad versus postrad HUB197 &lt;- perform_fisher( subclone_classes[[7]], population1 = unique(subclone_classes[[7]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[7]]$class))], population2 = unique(subclone_classes[[7]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[7]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB062 prerad versus postrad in biological replicate 2 HUB062_replicate2 &lt;- perform_fisher( subclone_classes[[7]], population1 = unique(subclone_classes[[7]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[7]]$class))], population2 = unique(subclone_classes[[7]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[7]]$class))] ) ############################ # Multiple test correction # ############################ # comparing pre and post rad for all the rest p_val_rest &lt;- c(NA, HUB005, HUB106, HUB062_cycle1, HUB062_cycle2, HUB015, HUB197, HUB062_replicate2) org_names &lt;- c(&#39;HUB183&#39;, &#39;HUB005&#39;, &#39;HUB106&#39;, &#39;HUB062_cycle1&#39;, &#39;HUB062_cycle2&#39;, &#39;HUB015&#39;, &#39;HUB197&#39;, &#39;HUB062_replicate2&#39;) p_val_adjust &lt;- p.adjust(p_val_rest, method = &#39;bonferroni&#39;, n = length(p_val_rest)) names(p_val_adjust) &lt;- org_names p_val_adjust ## HUB183 HUB005 HUB106 HUB062_cycle1 ## NA 1.000000e+00 2.015762e-02 1.564551e-17 ## HUB062_cycle2 HUB015 HUB197 HUB062_replicate2 ## 1.162420e-26 6.787625e-03 1.989615e-71 1.989615e-71 ####### # END # ####### 3.8 MEDICC2 3.8.1 Wrangle ############### # Description # ############### # Producing tsv files in MEDICC2 format. # Input file should be tsv format and the # following columns: sample_id, chrom, start, end # as well as columns for the copy numbers. # the data all should have equal bins. ### NOTE #### # This script was rerun for each pre- and post treatment organoid, by changing # each &#39;kra&#39; number. ############# # Libraries # ############# library(AneuFinder) library(tidyverse) library(stringr) ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/man_select_files_edivisive.rda&#39; ) ####### # UC # ###### names(man_select_files_edivisive) kra_003 &lt;-loadFromFiles(man_select_files_edivisive$kra003, check.class = c(&quot;aneuHMM&quot;, &quot;aneuBiHMM&quot;)) kra_004 &lt;-loadFromFiles(man_select_files_edivisive$kra004, check.class = c(&quot;aneuHMM&quot;, &quot;aneuBiHMM&quot;)) pick_bin &lt;- function(files){ # select binned data gr_range &lt;- files$bins # convert to dataframe gr_df &lt;- as.data.frame(gr_range) # select columns gr_df &lt;- gr_df %&gt;% select(&#39;seqnames&#39;, &#39;start&#39;, &#39;end&#39;, &#39;copy.number&#39;) # add sample id sample_id &lt;- str_remove(files$ID, &#39;single.SCC-scKaryo-UMC-&#39;) %&gt;% str_remove(&#39;.bam&#39;) gr_df$sample_id &lt;- sample_id # add &#39;chrom&#39; to seqnames gr_df$seqnames &lt;- paste0(&#39;chrom&#39;, gr_df$seqnames) # change colnames colnames(gr_df) &lt;- c(&#39;chrom&#39;, &#39;start&#39;, &#39;end&#39;, &#39;cn&#39;, &#39;sample_id&#39;) # return return(gr_df) } df_003 &lt;- lapply(kra_003, pick_bin) df_004 &lt;- lapply(kra_004, pick_bin) # combined dfs df_all_003 &lt;- bind_rows(df_003, .id = &quot;remove_me&quot;) df_all_004 &lt;- bind_rows(df_004, .id = &quot;remove_me&quot;) # binding df_all &lt;- rbind(df_all_003, df_all_004) # remove column remove me df_all &lt;- df_all %&gt;% select(-c(&#39;remove_me&#39;)) # saving a tsv file write.table(df_all, file=&#39;../cna_analysis/rda/medicc2/hub183.tsv&#39;, quote=FALSE, sep=&#39;\\t&#39;, row.names = F) 3.8.2 MEDICC2 run This for loop (bash) was used to run MEDICC2 on each .tsv filed as produced in the code under MEDICC2 -&gt; Wrangle above. The output of this code is not shown, as it comprises many documents and figures. The ‘…profiles_heatmap.pdf’ files were used in figures S1 and S2 of the manuscript. #!/bin/bash # Check if the correct number of arguments are provided if [ &quot;$#&quot; -ne 1 ]; then echo &quot;Usage: $0 input_folder&quot; exit 1 fi input_folder=&quot;$1&quot; output_folder=&quot;${input_folder}/output&quot; # Create the output folder if it doesn&#39;t exist mkdir -p &quot;$output_folder&quot; # Iterate through each .tsv file in the input folder for tsv_file in &quot;${input_folder}&quot;/*.tsv; do # Extract the filename without extension filename=$(basename -- &quot;$tsv_file&quot;) filename_without_extension=&quot;${filename%.*}&quot; # Create a folder with the name of the .tsv file output_subfolder=&quot;${output_folder}/${filename_without_extension}&quot; mkdir -p &quot;$output_subfolder&quot; # Run the function x (replace this with the actual command you want to run) time medicc2 &quot;$tsv_file&quot; &quot;$output_subfolder&quot; --total-copy-numbers --input-allele-columns cn --events --n-cores 8 done "],["copy-number-analyses.html", "4 Copy number analyses 4.1 Colorectal cancer-specific arm-level copy number alterations per organoid 4.2 Copy number alterations per subclone", " 4 Copy number analyses # Libraries and sources library(tidyverse) library(openxlsx) library(GenomicRanges) source(&#39;R/find_specific_cna_sc.R&#39;) source(&#39;R/get_cytoband_coverage.R&#39;) source(&#39;R/get_genes.R&#39;) source(&#39;R/get_oncogenes.R&#39;) source(&#39;R/plot_genes_karyotype.R&#39;) 4.1 Colorectal cancer-specific arm-level copy number alterations per organoid ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/man_select_files_edivisive.rda&#39;) # !!! GITHUB SPECIFIC CODE !!! # # adding &#39;../cna_analysis/&#39; to each path within man_select_files_edivisive man_select_files_edivisive &lt;- lapply(man_select_files_edivisive, function(x) paste0(&quot;../cna_analysis/&quot;, x)) ########### # Wrangle # ########### # extract only prerad clines # prerad clines kra_list &lt;- c(&quot;kra003&quot;, &quot;kra005&quot;, &quot;kra007&quot;, &quot;kra009&quot;, &quot;kra023&quot;, &quot;kra025&quot;, &quot;kra027&quot;) ####### # Run # ####### ## finding common CNAs within each subclone for each organoids. common_cnas &lt;- find_specific_cna_sc( list_resistant = man_select_files_edivisive[kra_list], # make sure to input this as a list! list_sensitive = NULL, perc_cutoff_within_subclone_resistant = 0.8, # CNA needs to be in 80% of the cells or more perc_cutoff_within_subclone_sensitive = NULL, per_cutoff_across_subclone_resistant = NULL, per_cutoff_across_subclone_sensitive = NULL, return_cnas_per_subclone = T ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 80% of single cells within each resistant subclone, and by % of single cells within each sensitive subclone&quot; ## mapping CNA to cytoband location # for amplifications amplifications &lt;- lapply(common_cnas$amplifications, get_cytoband_coverage) # Extract frequency of arm level amplifications n indicates the how many # organoids contain the CNA arm_amp &lt;- lapply(amplifications, function(x) { return(x[[2]]) }) %&gt;% bind_rows(.id = &quot;cline&quot;) %&gt;% group_by(cline, chromosome, arm) %&gt;% count(percentage_arm_affected &gt; 0.8) %&gt;% arrange(desc(n)) %&gt;% ungroup(cline) %&gt;% count(chromosome) %&gt;% arrange(desc(n)) %&gt;% mutate(freq = n / 7) DT::datatable(arm_amp, caption = &quot;Arm-level amplifications in organoids&quot;) # for deletions deletions &lt;- lapply(common_cnas$deletions, get_cytoband_coverage) # Extract frequency of arm level deletions. n indicates the how many # organoids contain the CNA arm_del &lt;- lapply(deletions, function(x) { return(x[[2]]) }) %&gt;% bind_rows(.id = &quot;cline&quot;) %&gt;% group_by(cline, chromosome, arm) %&gt;% count(percentage_arm_affected &gt; 0.8) %&gt;% arrange(desc(n)) %&gt;% ungroup(cline) %&gt;% count(chromosome) %&gt;% arrange(desc(n)) %&gt;% mutate(freq = n / 7) DT::datatable(arm_del, caption = &quot;Arm-level deletions in organoids&quot;) ####### # End # ####### 4.2 Copy number alterations per subclone 4.2.1 Copy number alterations specific to HUB062A ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/subclone_list.rda&#39;) # !!! GITHUB SPECIFIC CODE !!! # # adding &#39;../cna_analysis/&#39; to each path within man_select_files_edivisive subclone_list &lt;- lapply(subclone_list, function(x) paste0(&quot;../cna_analysis/&quot;, x)) ########### # Wrangle # ########### # extracting resistant and sensitive subclones of hub062 hub062 &lt;- names(subclone_list)[grepl(&#39;hub062&#39;, names(subclone_list))] res &lt;- hub062[grepl(&#39;hub062_postrad_a&#39;, hub062)] sens &lt;- hub062[grepl(&#39;hub062_postrad_b|hub062_postrad_c&#39;, hub062)] # remove cycle 2 sens &lt;- sens[!grepl(&#39;c2&#39;, sens)] ####### # Run # ####### ## finding common CNAs within each subclone for each organoids. hub062a_specific_cnas &lt;- find_specific_cna_sc( list_resistant = subclone_list[res], list_sensitive = subclone_list[sens], perc_cutoff_within_subclone_resistant = 0.6, perc_cutoff_within_subclone_sensitive = 0.6, per_cutoff_across_subclone_resistant = 0.2, per_cutoff_across_subclone_sensitive = 0.2, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 60 and 60% of single cells within resistant and sensitive subclones, respectively, and that are shared by 20 and 20% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; ## mapping CNA to cytoband location # for amplifications ampl_hub062a &lt;- get_cytoband_coverage(hub062a_specific_cnas$unique_resistant_ampl) DT::datatable(as.data.frame(ampl_hub062a[[1]]), caption = &quot;HUB062A-specific amplifications (exact location)&quot;) del_hub062a &lt;- get_cytoband_coverage(hub062a_specific_cnas$unique_resistant_del) # No HUB062A-specific deletions were found. ####### # Run # ####### # All genes # ############# genes_ampl_hub062a &lt;- get_genes(ampl_hub062a[[1]]) DT::datatable(as.data.frame(genes_ampl_hub062a), caption = &quot;Genes on HUB062A-specific amplifications&quot;) # Oncogenes # ############# oncogenes_ampl_hub062a &lt;- get_oncogenes(ampl_hub062a[[1]]) DT::datatable(as.data.frame(oncogenes_ampl_hub062a), caption = &quot;Oncogenes on HUB062A-specific amplifications&quot;) ######## # Data # ######## load(&#39;../cna_analysis/rda/cna_analysis/hub062a_specific_cnas_genes.rda&#39;) ########### # Wrangle # ########### # plot_genes_karyotype needs a GRange with seqnames, ranges, strand and hgnc_symbol # add ampl/del column oncogenes_ampl_hub062a$cn &lt;- &#39;amplified&#39; # bind dataframes oncogenes &lt;- oncogenes_ampl_hub062a # extract needed columns keep &lt;- c(&#39;Gene Symbol&#39;, &#39;chromosome_name&#39;, &#39;start_position&#39;, &#39;end_position&#39;, &#39;cn&#39;) oncogenes &lt;- oncogenes[, keep] # rename colnames(oncogenes) &lt;- c(&#39;hgnc_symbol&#39;, &#39;seqnames&#39;, &#39;start&#39;, &#39;end&#39;, &#39;cn&#39;) # convert to dataframe onco_grange &lt;- makeGRangesFromDataFrame(oncogenes) # metadata is deleted onco_grange$hgnc_symbol &lt;- oncogenes$hgnc_symbol onco_grange$cn &lt;- oncogenes$cn ########################## # Choose genes to depict # ########################## oncogenes_ampl_hub062a &lt;- oncogenes_ampl_hub062a[order(oncogenes_ampl_hub062a$`Genome Location`),] show_oncogenes_ampl &lt;- c(&#39;FANCF&#39;, &#39;CREB3L1&#39;, &#39;DDB2&#39;, &#39;HRAS&#39;, &#39;CCND1&#39;, &#39;NF1&#39;, &#39;FANCG&#39;, &#39;JAK2&#39;, &#39;AR&#39;) show_oncogenes &lt;- c(show_oncogenes_ampl) ######## # PLOT # ######## plot_genes_karyotype( onco_grange, show_genes = show_oncogenes, dist = -45, show_chromosomes = c( &quot;chr9&quot;, &quot;chr10&quot;, &quot;chr11&quot;, &quot;chr12&quot;, &quot;chr13&quot;, &quot;chr14&quot;, &quot;chr15&quot;, &quot;chr16&quot;, &quot;chr17&quot;, &quot;chr18&quot;, &quot;chr19&quot;, &quot;chr20&quot;, &quot;chr21&quot;, &quot;chr22&quot;, &quot;chrX&quot; ) ) 4.2.2 Copy number alterations specific to resistant subclones ######## # Data # ######## load(&#39;../cna_analysis/rda/cna_analysis/hub062a_specific_cnas.rda&#39;) ########### # Wrangle # ########### # extracting resistant and sensitive subclones of hub062 # excluding HUB197, as here subclones were probably not selected on the basis of CNAs # but on the basis of the presence of WGD! resistant &lt;- names(subclone_list)[c(grep(&#39;hub005_prerad_b&#39;, names(subclone_list)), grep(&#39;hub183_prerad&#39;, names(subclone_list)), grep(&#39;hub062_postrad_a&#39;, names(subclone_list)) )] # in resistant, # in resistant, hub005 a.a and a.b need to be joined together, as they are no subclones hub005_prerad_a.a_a.b &lt;- c(subclone_list$hub005_prerad_a.a, subclone_list$hub005_prerad_a.b) # joining the combined clones to resistant res_list &lt;- subclone_list[resistant] res_list[[&#39;hub005_prerad_a.a_a.b&#39;]] &lt;- hub005_prerad_a.a_a.b # comparing resistant to sensitive lines yields to many results. rest &lt;- names(subclone_list)[c(grep(&#39;hub106_prerad&#39;, names(subclone_list)), grep(&#39;hub062_prerad_b&#39;, names(subclone_list)), grep(&#39;hub062_prerad_c&#39;, names(subclone_list)), grep(&#39;hub197_prerad_b&#39;, names(subclone_list)) )] rest_list &lt;- subclone_list[rest] ####### # Run # ####### ## finding common CNAs within each subclone for each organoid. resistant_specific_cnas &lt;- find_specific_cna_sc( list_resistant = res_list, list_sensitive = rest_list, perc_cutoff_within_subclone_resistant = 0.6, # needs to be present in 60% or more cells per subclone perc_cutoff_within_subclone_sensitive = 0.6, per_cutoff_across_subclone_resistant = 0.8, # if present in 80% of the subclones, it will be called a CNA and might thus be resistant-specific (depending on if it is also found in sensitive subclones) per_cutoff_across_subclone_sensitive = 0.1, # if present in 20%, it is already called a CNA in sensitive subclones and thus wont be detected as a resistant specific CNA return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 60 and 60% of single cells within resistant and sensitive subclones, respectively, and that are shared by 80 and 10% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; ## mapping CNA to cytoband location # for amplifications ampl_resistant &lt;- get_cytoband_coverage(resistant_specific_cnas$unique_resistant_ampl) del_resistant &lt;- get_cytoband_coverage(resistant_specific_cnas$unique_resistant_del) # Both ampl_resistant and del_resistant are empty, no resistance specific cnas # shared by subclones was found 4.2.3 Newly acquired copy number alterations ############### # Description # ############### # We are going to define the presence of &#39;new&#39; CNAs after radiation therapy. # I define the following rules: # (i) Analysis will be done within subclone # (ii) A &#39;new&#39; CNA will be called new only if it was not found before radiation # (iii) I exclude all subclones where the numbers of cells within a subclone is lower than 5. # (iv) Because in essence, all cells are related to each other (even those in distinct) # subclones, I am going to compare each post-rad subclone to all pooled subclones before # radiation. # (v) We are looking for acquired CNAs; CNAs that could explain why cells with that # CNA propagated. Therefore, the CNA has to be present in at least 50% of the cells. ########### # Wrangle # ########### # remove subclones with fewer than 5 cells pre-or post rad. lapply(subclone_list, length) ## $hub183_prerad_a ## [1] 127 ## ## $hub183_postrad_a ## [1] 110 ## ## $hub005_prerad_a.a ## [1] 25 ## ## $hub005_prerad_a.b ## [1] 13 ## ## $hub005_prerad_b ## [1] 118 ## ## $hub005_postrad_a.a ## [1] 17 ## ## $hub005_postrad_a.b ## [1] 2 ## ## $hub005_postrad_b ## [1] 70 ## ## $hub106_prerad_a ## [1] 64 ## ## $hub106_prerad_b ## [1] 59 ## ## $hub106_prerad_c ## [1] 4 ## ## $hub106_postrad_a ## [1] 60 ## ## $hub106_postrad_b ## [1] 103 ## ## $hub106_postrad_c ## [1] 18 ## ## $hub062_prerad_a ## [1] 2 ## ## $hub062_prerad_b ## [1] 127 ## ## $hub062_prerad_c ## [1] 7 ## ## $hub062_postrad_a ## [1] 39 ## ## $hub062_postrad_b ## [1] 38 ## ## $hub062_postrad_c ## [1] 7 ## ## $hub062_postrad_c2_a ## [1] 187 ## ## $hub062_postrad_c2_c ## [1] 1 ## ## $hub015_prerad_a.b ## [1] 276 ## ## $hub015_prerad_b ## [1] 1 ## ## $hub015_postrad_a.a ## [1] 110 ## ## $hub015_postrad_a.b ## [1] 157 ## ## $hub015_postrad_b ## [1] 14 ## ## $hub181i_prerad_a ## [1] 72 ## ## $hub181i_prerad_b ## [1] 233 ## ## $hub181i_postrad_a ## [1] 72 ## ## $hub181i_postrad_b ## [1] 239 ## ## $hub197_prerad_a ## [1] 24 ## ## $hub197_prerad_b ## [1] 17 ## ## $hub197_prerad_c ## [1] 91 ## ## $hub197_postrad_a ## [1] 252 ## ## $hub062biological_prerad_a ## [1] 14 ## ## $hub062biological_prerad_b ## [1] 205 ## ## $hub062biological_prerad_c ## [1] 13 ## ## $hub062biological_postrad_a ## [1] 178 remove_me &lt;- c(&#39;hub005_prerad_a.b&#39;, &#39;hub005_postrad_a.b&#39;, # because only 2 cells in hub005_postrad_a.b &#39;hub062_prerad_a&#39;, # only 2 cells, here I am going to compare C1 vs C2, so # I don&#39;t remove hub062_postrad_a &#39;hub015_prerad_b&#39;, &#39;hub015_postrad_b&#39;, # only 1 cell in prerad &#39;hub197_prerad_b&#39;,&#39;hub197_prerad_b&#39;, # extinction &#39;hub197_prerad_c&#39;,&#39;hub197_postrad_c&#39; # extinction ) subclone_list &lt;- subclone_list[!(names(subclone_list) %in% remove_me)] ############# # Variables # ############# # Percentage of cells cut-off pcc &lt;- 0.5 ######## # RUNS # ######## # HUB183 # ###################################################################### # Extract HUB183 hub183 &lt;- names(subclone_list)[grepl(&#39;hub183&#39;, names(subclone_list))] # combine prerad subclones and a.b hub183_prerad_subclones &lt;- hub183[grepl(&#39;prerad&#39;, hub183)] # get each postrad subclone individually hub183_postrad_a &lt;- hub183[grepl(&#39;hub183_postrad_a&#39;, hub183)] # no new genomic aberrations hub183_postrad_a &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub183_postrad_a], list_sensitive = subclone_list[hub183_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # HUB005 # ###################################################################### # Extract HUB005 hub005 &lt;- names(subclone_list)[grepl(&#39;hub005&#39;, names(subclone_list))] # combine prerad subclones and a.b hub005_prerad_subclones &lt;- hub005[grepl(&#39;prerad&#39;, hub005)] # get each postrad subclone individually hub005_postrad_a.a &lt;- hub005[grepl(&#39;hub005_postrad_a.a&#39;, hub005)] hub005_postrad_b &lt;- hub005[grepl(&#39;hub005_postrad_b&#39;, hub005)] # no new CNAs hub005_postrad_a.a &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub005_postrad_a.a], list_sensitive = subclone_list[hub005_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # no new CNAs hub005_postrad_b &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub005_postrad_b], list_sensitive = subclone_list[hub005_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # HUB015 # ###################################################################### # Extract HUB015 hub015 &lt;- names(subclone_list)[grepl(&#39;hub015&#39;, names(subclone_list))] # combine prerad subclones and a.b hub015_prerad_subclones &lt;- hub015[grepl(&#39;prerad&#39;, hub015)] # get each postrad subclone individually hub015_postrad_a.a &lt;- hub015[grepl(&#39;hub015_postrad_a.a&#39;, hub015)] hub015_postrad_a.b &lt;- hub015[grepl(&#39;hub015_postrad_a.b&#39;, hub015)] hub015_postrad_b &lt;- hub015[grepl(&#39;hub015_postrad_b&#39;, hub015)] # hub015_postrad_a.a: new deletion on 4q hub015_postrad_a.a &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub015_postrad_a.a], list_sensitive = subclone_list[hub015_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # HUB015 has a new deletion following radiation in 4q DT::datatable(as.data.frame(get_cytoband_coverage(hub015_postrad_a.a$unique_resistant_del)[[1]])) # This deletion contains the following oncogenes DT::datatable(get_oncogenes(get_cytoband_coverage(hub015_postrad_a.a$unique_resistant_del)[[1]])) # hub015_postrad_a.a: no new amplificatoins no new deletions hub015_postrad_a.b &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub015_postrad_a.b], list_sensitive = subclone_list[hub015_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # # HUB106 # ###################################################################### # Extract HUB106 hub106 &lt;- names(subclone_list)[grepl(&#39;hub106&#39;, names(subclone_list))] # combine prerad subclones and a.b hub106_prerad_subclones &lt;- hub106[grepl(&#39;prerad&#39;, hub106)] # get each postrad subclone individually hub106_postrad_a &lt;- hub106[grepl(&#39;hub106_postrad_a&#39;, hub106)] hub106_postrad_b &lt;- hub106[grepl(&#39;hub106_postrad_b&#39;, hub106)] hub106_postrad_c &lt;- hub106[grepl(&#39;hub106_postrad_c&#39;, hub106)] # no new CNAs hub106_postrad_a &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub106_postrad_a], list_sensitive = subclone_list[hub106_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # no new CNAs hub106_postrad_b &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub106_postrad_b], list_sensitive = subclone_list[hub106_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # no new CNAs hub106_postrad_c &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub106_postrad_c], list_sensitive = subclone_list[hub106_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # HUB062 # ###################################################################### hub062 &lt;- names(subclone_list)[grepl(&#39;hub062&#39;, names(subclone_list))] # combine prerad subclones and a.b hub062_prerad_subclones &lt;- hub062[grepl(&#39;prerad&#39;, hub062)] # get each postrad subclone individually hub062_postrad_a &lt;- hub062[grepl(&#39;hub062_postrad_a&#39;, hub062)] hub062_postrad_b &lt;- hub062[grepl(&#39;hub062_postrad_b&#39;, hub062)] hub062_postrad_c &lt;- hub062[grepl(&#39;hub062_postrad_c&#39;, hub062)] hub062biological_postrad_a &lt;- hub062[grepl(&#39;hub062biological_postrad_a&#39;, hub062)] hub062_postrad_c2_a &lt;- hub062[grepl(&#39;hub062_postrad_c2_a&#39;, hub062)] hub062_postrad_c2_c &lt;- hub062[grepl(&#39;hub062_postrad_c2_c&#39;, hub062)] # No new CNAs hub062_postrad_a &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub062_postrad_a], list_sensitive = subclone_list[hub062_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # No new CNAs hub062_postrad_b &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub062_postrad_b], list_sensitive = subclone_list[hub062_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # No new CNAs hub062_postrad_c &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub062_postrad_c], list_sensitive = subclone_list[hub062_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # No new CNAs hub062biological_postrad_a &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub062biological_postrad_a], list_sensitive = subclone_list[hub062_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # No new CNAs hub062_postrad_c2_a &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub062_postrad_c2_a], list_sensitive = subclone_list[hub062_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; # No new CNAs hub062_postrad_c2_c &lt;- find_specific_cna_sc( list_resistant = subclone_list[hub062_postrad_c2_c], list_sensitive = subclone_list[hub062_prerad_subclones], perc_cutoff_within_subclone_resistant = pcc, perc_cutoff_within_subclone_sensitive = 0.001, per_cutoff_across_subclone_resistant = 0.001, per_cutoff_across_subclone_sensitive = 0.001, return_cnas_per_subclone = F ) ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted segment info from files&quot; ## [1] &quot;Computing (this may take some minutes)...&quot; ## [1] &quot;Extracted CNAs that are shared by 50 and 0.1% of single cells within resistant and sensitive subclones, respectively, and that are shared by 0.1 and 0.1% across resistant and sensitive subclones, respectively.&quot; ## [1] &quot;Computing (few seconds)...&quot; ## [1] &quot;Identified amplifications and deletions that are unique to resistant or sensitive subclones&quot; 4.2.4 CCLE PTPN13 and AFF1 analysis library(tidyverse) ### PTPN13 ### ############### # ABSOLUTE DATA GENERATED HERE: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6697103/ cnv_ccle &lt;- as.data.frame(readr::read_csv(&quot;../cna_analysis/data/cna_analysis/Copy_Number_(Absolute).csv&quot;)) load(&#39;../cna_analysis/rda/cna_analysis/ccle_rad_data.rda&#39;) t &lt;- subset(cnv_ccle, colnames(cnv_ccle) == &#39;PTPN13&#39;) t &lt;- cnv_ccle %&gt;% select(c(&quot;...1&quot;, &#39;PTPN13&#39;)) colnames(t) &lt;- c(&#39;DepMap_ID&#39;, &#39;PTPN13&#39;) testy &lt;- left_join(t, rad_df, by = &#39;DepMap_ID&#39;) testy &lt;- subset(testy, resistancy_group %in% c(&#39;Resistant&#39;, &#39;Sensitive&#39;)) # running a logistic regression testy$del &lt;- ifelse(testy$PTPN13 &lt; 2, &#39;1&#39;, &#39;0&#39;) # if resistancy group == sensitive -&gt; numeric is reduced, meaning less deletions. # Resistant groups have more deletions. # t &lt;- glm(as.numeric(as.factor(testy$del)) ~ as.factor(testy$resistancy_group)) # # controlling for primary_tumor, subtype # resistancy group: still more deletions in the resistant group. t &lt;- glm(as.numeric(as.factor(testy$del)) ~ as.factor(testy$resistancy_group) + as.factor(testy$primary_disease) + as.factor(testy$subtype_disease)) tabol &lt;- table(testy$resistancy_group, testy$PTPN13) # Percentage deleted resistant tabol[1,1] / (tabol[1,1] + tabol[1,2] + tabol[1,3] + tabol[1,4] + tabol[1,5])*100 ## [1] 15.38462 # Percentage deleted sensitive tabol[2,1] / (tabol[2,1] + tabol[2,2] + tabol[2,3] + tabol[2,4] + tabol[2,5])*100 ## [1] 4.854369 # showing p value for PTPN13. t &lt;- summary(t) t &lt;- t$coefficients t[2,] ## Estimate Std. Error t value Pr(&gt;|t|) ## -0.167454345 0.059919597 -2.794650710 0.005935705 ### AFF1 ### ############### # exclude regions of interest t &lt;- subset(cnv_ccle, colnames(cnv_ccle) == &#39;AFF1&#39;) t &lt;- as.data.frame(cnv_ccle) %&gt;% dplyr::select(c(&quot;...1&quot;, &#39;AFF1&#39;)) colnames(t) &lt;- c(&#39;DepMap_ID&#39;, &#39;AFF1&#39;) testy &lt;- left_join(t, rad_df, by = &#39;DepMap_ID&#39;) testy &lt;- subset(testy, resistancy_group %in% c(&#39;Resistant&#39;, &#39;Sensitive&#39;)) # running a logistic regression testy$del &lt;- ifelse(testy$AFF1 &lt; 2, &#39;1&#39;, &#39;0&#39;) # if resistancy group == sensitive -&gt; numeric is reduced, meaning less deletions. # Resistant groups have more deletions. # t &lt;- glm(as.numeric(as.factor(testy$del)) ~ as.factor(testy$resistancy_group)) # # controlling for primary_tumor, subtype # resistancy group: still more deletions in the resistant group. t &lt;- glm(as.numeric(as.factor(testy$del)) ~ as.factor(testy$resistancy_group) + as.factor(testy$primary_disease) + as.factor(testy$subtype_disease)) tabol &lt;- table(testy$resistancy_group, testy$AFF1) # Percentage deleted resistant tabol[1,1] / (tabol[1,1] + tabol[1,2] + tabol[1,3] + tabol[1,4] + tabol[1,5])*100 ## [1] 15.38462 # Percentage deleted sensitive tabol[2,1] / (tabol[2,1] + tabol[2,2] + tabol[2,3] + tabol[2,4] + tabol[2,5])*100 ## [1] 3.883495 # showing p value for AFF1 t &lt;- summary(t) t &lt;- t$coefficients t[2,] ## Estimate Std. Error t value Pr(&gt;|t|) ## -0.17117146 0.05852904 -2.92455615 0.00403370 "],["copy-number-pattern-analyses.html", "5 Copy number pattern analyses 5.1 Single cell analyses 5.2 CCLE analysis", " 5 Copy number pattern analyses # Libraries and sources library(stringr) library(tidyverse) library(cowplot) library(ggpubr) library(ggbeeswarm) library(nord) library(readxl) library(AneuFinder) source(&#39;R/cin_signature_ccle.R&#39;) source(&#39;R/cna_profiler.R&#39;) source(&#39;../cna_analysis/R/calculate_heterogeneity_score.R&#39;) source(&#39;../cna_analysis/R/shifters.R&#39;) 5.1 Single cell analyses 5.1.1 Heterogeneity score ####### # Run # ####### # create_cn_matrix cannot run when a subclone exist of just 1 clone i &lt;- which(sapply(subclone_list, length) &gt; 1) subclone_list &lt;- subclone_list[i] subclone_cn_matrix &lt;- sapply(subclone_list, create_cn_matrix) ######## # Data # ######## load(&#39;../cna_analysis/rda/cin_analysis/subclone_cn_matrices.rda&#39;) ####### # Run # ####### clust_and_shift_subclones &lt;- sapply(subclone_cn_matrix, cluster_and_shift_transitions, max_dist = 5000000) ######## # Data # ######## load(&#39;../cna_analysis/rda/cin_analysis/clust_and_shift_subclones.rda&#39;) load(&#39;../cna_analysis/rda/subclonal_dynamics/subclone_list.rda&#39;) ########### # Wrangle # ########### # !!! GITHUB SPECIFIC CODE !!! # # adding &#39;../cna_analysis/&#39; to each path within man_select_files_edivisive subclone_list &lt;- lapply(subclone_list, function(x) paste0(&quot;../cna_analysis/&quot;, x)) # removing clones with size 1 or less i &lt;- which(sapply(subclone_list, length) &gt; 1) # adding subclone size to the dataframe subclone_list &lt;- subclone_list[i] ####### # Run # ####### hetscore &lt;- lapply(clust_and_shift_subclones[1,], FUN = calculate_heterogeneity_score, min_num = 1) ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ## Start | calculate_heterogeneity_score ## End | calculate_heterogeneity_score ########### # Wrangle # ########### list_of_dataframes &lt;- lapply(hetscore, function(list_of_hetscores) { return(list_of_hetscores$genomewide) }) # bind them into one df aneu_het_score &lt;- bind_rows(list_of_dataframes) # add subclone full name aneu_het_score$full_id &lt;- colnames(clust_and_shift_subclones) # include only those organoids that we are interested in for this analysis aneu_het_score &lt;- aneu_het_score[!grepl(pattern = &#39;biological|c2&#39;, aneu_het_score$full_id ),] # add organoids id aneu_het_score$cline &lt;- str_extract(pattern = &#39;hub\\\\d{3}&#39;, aneu_het_score$full_id ) # add radiation status aneu_het_score$rad &lt;- str_extract(pattern = &#39;prerad|postrad&#39;, aneu_het_score$full_id) # add subclone_id aneu_het_score$subclone &lt;- str_extract(aneu_het_score$full_id, &quot;_(.*)&quot;) aneu_het_score$subclone &lt;- str_replace(aneu_het_score$full_id, pattern = &#39;_prerad_|_postrad_&#39;, replacement = &#39;&#39;) # ####### # # Run # # ####### # # adding aneuploidy scores # kars &lt;- sapply(subclone_list[aneu_het_score$full_id], karyotypeMeasures) # # ########### # # Wrangle # # ########### # ## Print the scores in one data.frame # kars_list &lt;- list() # for (i in 1:dim(kars)[2]) { # kars_list[[colnames(kars)[i]]] &lt;- kars[1,i] # } # # kars_df &lt;- data.frame(value = unlist(kars_list)) # # # every uneven row is aneuploidy # i_uneven &lt;- seq_len(nrow(kars_df)) %% 2 # Create row indicator # kars_df &lt;- kars_df[i_uneven == 1, ] # # # binding heterogeneity score dataframe and kars_df together # aneu_het_score$aneuploidy &lt;- kars_df # # rename full_id -&gt; unique_id aneu_het_score &lt;- aneu_het_score %&gt;% rename(&quot;full_id&quot; = &quot;unique_id&quot; ) ################ ### BASELINE ### ################ ########### # Wrangle # ########### res_df &lt;- subset(aneu_het_score, unique_id %in% aneu_het_score$unique_id[c( grep(&#39;hub005&#39;, aneu_het_score$unique_id), grep(&#39;hub183&#39;, aneu_het_score$unique_id), grep(&#39;hub015&#39;, aneu_het_score$unique_id), grep(&#39;hub062_prerad_a&#39;, aneu_het_score$unique_id), grep(&#39;hub197_prerad_a&#39;, aneu_het_score$unique_id) )]) %&gt;% mutate(resistancy_group = &#39;Resistant&#39;) sens_df &lt;- subset(aneu_het_score, unique_id %in% aneu_het_score$unique_id[c( grep(&#39;hub106&#39;, aneu_het_score$unique_id), grep(&#39;hub197&#39;, aneu_het_score$unique_id), grep(&#39;hub062_prerad_b&#39;, aneu_het_score$unique_id), grep(&#39;hub062_postrad_b&#39;, aneu_het_score$unique_id), grep(&#39;hub062_prerad_c&#39;, aneu_het_score$unique_id), grep(&#39;hub062_postrad_c&#39;, aneu_het_score$unique_id) )]) %&gt;% mutate(resistancy_group = &#39;Sensitive&#39;) %&gt;% filter(unique_id != &#39;hub197_prerad_a&#39;) df &lt;- rbind(res_df, sens_df) # remove postrad except df &lt;- df %&gt;% filter(rad != &#39;postrad&#39;) %&gt;% rbind(df %&gt;% filter(unique_id == &#39;hub062_postrad_a&#39;)) ################# # Heterogeneity # ################# # Statistics # ############## mwu_het &lt;- compare_means( Heterogeneity_2 ~ resistancy_group, data = df, method = &quot;t.test&quot;, paired = F ) # make y positon empty vector, and convert p to scientific notation with 1 decimal het_y &lt;- 0.7 mwu_het &lt;- mwu_het %&gt;% mutate(y.position = c(het_y), empty = &#39; &#39;) %&gt;% mutate(p = format(p, digits = 2)) %&gt;% mutate(p = as.numeric(p)) %&gt;% mutate(p = format(p, scientific = T)) %&gt;% mutate(p = sub(&quot;e&quot;, &quot;%.% 10^&quot;, p)) # Plot # ######## ggplot(data = df, aes(x = as.factor(resistancy_group), y = Heterogeneity_2)) + theme_cowplot() + geom_boxplot(aes(fill = resistancy_group), outlier.shape = NA) + scale_fill_manual(values = c(Resistant = &#39;#DE3163&#39;, Sensitive = &#39;#5090CD&#39;)) + xlab(&#39;&#39;) + ylab(&#39;Heterogeneity&#39;) + stat_pvalue_manual(mwu_het, label = &#39;empty&#39;) + annotate( &#39;text&#39;, x = 1.5, y = het_y * 1.0571, label = paste0(&quot;italic(P)==&quot;, mwu_het$p), parse = T ) + theme( axis.text.x = element_text(angle = 45, hjust=1), legend.position = &quot;none&quot;, aspect.ratio = 5 / 1.5) 5.1.2 MEDICC2 intraclone variability ######## # Data # ######## load(&#39;../cna_analysis/rda/cin_analysis/aneu_het_score.rda&#39;) ################ ### BASELINE ### ################ ########### # Wrangle # ########### res_df &lt;- subset(aneu_het_score, unique_id %in% aneu_het_score$unique_id[c( grep(&#39;hub005&#39;, aneu_het_score$unique_id), grep(&#39;hub183&#39;, aneu_het_score$unique_id), grep(&#39;hub015&#39;, aneu_het_score$unique_id), grep(&#39;hub062_prerad_a&#39;, aneu_het_score$unique_id), grep(&#39;hub197_prerad_a&#39;, aneu_het_score$unique_id) )]) %&gt;% mutate(resistancy_group = &#39;Resistant&#39;) sens_df &lt;- subset(aneu_het_score, unique_id %in% aneu_het_score$unique_id[c( grep(&#39;hub106&#39;, aneu_het_score$unique_id), grep(&#39;hub197&#39;, aneu_het_score$unique_id), grep(&#39;hub062_prerad_b&#39;, aneu_het_score$unique_id), grep(&#39;hub062_postrad_b&#39;, aneu_het_score$unique_id), grep(&#39;hub062_prerad_c&#39;, aneu_het_score$unique_id), grep(&#39;hub062_postrad_c&#39;, aneu_het_score$unique_id) )]) %&gt;% mutate(resistancy_group = &#39;Sensitive&#39;) %&gt;% filter(unique_id != &#39;hub197_prerad_a&#39;) df &lt;- rbind(res_df, sens_df) # remove postrad except df &lt;- df %&gt;% filter(rad != &#39;postrad&#39;) %&gt;% rbind(df %&gt;% filter(unique_id == &#39;hub062_postrad_a&#39;)) # make sure to have the same subclones to work with unique(df$unique_id) ## [1] &quot;hub183_prerad_a&quot; &quot;hub005_prerad_a.a&quot; &quot;hub005_prerad_a.b&quot; &quot;hub005_prerad_b&quot; ## [5] &quot;hub062_prerad_a&quot; &quot;hub015_prerad_a.a&quot; &quot;hub197_prerad_a&quot; &quot;hub106_prerad_a&quot; ## [9] &quot;hub106_prerad_b&quot; &quot;hub106_prerad_c&quot; &quot;hub062_prerad_b&quot; &quot;hub062_prerad_c&quot; ## [13] &quot;hub197_prerad_b&quot; &quot;hub197_prerad_c&quot; ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/subclone_list.rda&#39;) ############ # Function # ############ pairwise_mean_subclone &lt;- function(pair_dist_df, list_of_subclone) { samples &lt;- str_match(list_of_subclone, &quot;single.SCC-scKaryo-UMC-\\\\s*(.*?)\\\\s*.bam&quot;)[,2] df_subset_row &lt;- subset(pair_dist_df, sample_id %in% samples) df_subset_row_col &lt;- df_subset_row[, samples] df_mat &lt;- as.matrix(df_subset_row_col) return(mean(df_mat)) } pairwise_mean_subclone_ssdna004 &lt;- function(pair_dist_df, list_of_subclone) { samples &lt;- str_match(list_of_subclone, &quot;method-edivisive/\\\\s*(.*?)\\\\s*.bam&quot;)[,2] df_subset_row &lt;- subset(pair_dist_df, sample_id %in% samples) df_subset_row_col &lt;- df_subset_row[, samples] df_mat &lt;- as.matrix(df_subset_row_col) return(mean(df_mat)) } ######## # Runs # ######## hub183 &lt;- read_delim(&quot;../cna_analysis/rda/medicc2/hub183/hub183_pairwise_distances.tsv&quot;, delim = &quot;\\t&quot;, escape_double = FALSE, trim_ws = TRUE) hub183_prerad_a &lt;- pairwise_mean_subclone(hub183, subclone_list$hub183_prerad_a) hub005 &lt;- read_delim(&quot;../cna_analysis/rda/medicc2/hub005/hub005_pairwise_distances.tsv&quot;, delim = &quot;\\t&quot;, escape_double = FALSE, trim_ws = TRUE) hub005_prerad_a.a &lt;- pairwise_mean_subclone(hub005, subclone_list$hub005_prerad_a.a) hub005_prerad_a.b &lt;- pairwise_mean_subclone(hub005, subclone_list$hub005_prerad_a.b) hub005_prerad_b &lt;- pairwise_mean_subclone(hub005, subclone_list$hub005_prerad_b) hub062 &lt;- read_delim(&quot;../cna_analysis/rda/medicc2/hub062/hub062_pairwise_distances.tsv&quot;, delim = &quot;\\t&quot;, escape_double = FALSE, trim_ws = TRUE) hub062_prerad_a &lt;- pairwise_mean_subclone(hub062, subclone_list$hub062_prerad_a) hub062_prerad_b &lt;- pairwise_mean_subclone(hub062, subclone_list$hub062_prerad_b) hub062_prerad_c &lt;- pairwise_mean_subclone(hub062, subclone_list$hub062_prerad_c) hub015 &lt;- read_delim(&quot;../cna_analysis/rda/medicc2/hub015/hub015_pairwise_distances.tsv&quot;, delim = &quot;\\t&quot;, escape_double = FALSE, trim_ws = TRUE) # thsi is actually a.b but it is called wrong in dataframe df, they correspond to the same # clone though. hub015_prerad_a.a &lt;- pairwise_mean_subclone_ssdna004(hub015, subclone_list$hub015_prerad_a.b ) hub106 &lt;- read_delim(&quot;../cna_analysis/rda/medicc2/hub106/hub106_pairwise_distances.tsv&quot;, delim = &quot;\\t&quot;, escape_double = FALSE, trim_ws = TRUE) hub106_prerad_a &lt;- pairwise_mean_subclone(hub106, subclone_list$hub106_prerad_a) hub106_prerad_b &lt;- pairwise_mean_subclone(hub106, subclone_list$hub106_prerad_b) hub106_prerad_c &lt;- pairwise_mean_subclone(hub106, subclone_list$hub106_prerad_c) hub197 &lt;- read_delim(&quot;../cna_analysis/rda/medicc2/hub197/hub197_pairwise_distances.tsv&quot;, delim = &quot;\\t&quot;, escape_double = FALSE, trim_ws = TRUE) hub197_prerad_a &lt;- pairwise_mean_subclone_ssdna004(hub197, subclone_list$hub197_prerad_a) hub197_prerad_b &lt;- pairwise_mean_subclone_ssdna004(hub197, subclone_list$hub197_prerad_b) hub197_prerad_c &lt;- pairwise_mean_subclone_ssdna004(hub197, subclone_list$hub197_prerad_c) ### dataframe df_pwd &lt;- data.frame(unique_id = c(&#39;hub183_prerad_a&#39;, &#39;hub005_prerad_a.a&#39;, &#39;hub005_prerad_a.b&#39;, &#39;hub005_prerad_b&#39;, &#39;hub062_prerad_a&#39;, &#39;hub062_prerad_b&#39;, &#39;hub062_prerad_c&#39;, &#39;hub015_prerad_a.a&#39;, &#39;hub106_prerad_a&#39;, &#39;hub106_prerad_b&#39;, &#39;hub106_prerad_c&#39;, &#39;hub197_prerad_a&#39;, &#39;hub197_prerad_b&#39;, &#39;hub197_prerad_c&#39;), pwd_mean = c(hub183_prerad_a, hub005_prerad_a.a, hub005_prerad_a.b, hub005_prerad_b, hub062_prerad_a, hub062_prerad_b, hub062_prerad_c, hub015_prerad_a.a, hub106_prerad_a, hub106_prerad_b, hub106_prerad_c, hub197_prerad_a, hub197_prerad_b, hub197_prerad_c)) df &lt;- left_join(df, df_pwd) # Statistics # ############## mwu_het &lt;- compare_means( pwd_mean ~ resistancy_group, data = df, method = &quot;t.test&quot;, paired = F ) # make y positon empty vector, and convert p to scientific notation with 1 decimal het_y &lt;- 80 mwu_het &lt;- mwu_het %&gt;% mutate(y.position = c(het_y), empty = &#39; &#39;) %&gt;% mutate(p = format(p, digits = 2)) %&gt;% mutate(p = as.numeric(p)) %&gt;% mutate(p = format(p, scientific = T)) %&gt;% mutate(p = sub(&quot;e&quot;, &quot;%.% 10^&quot;, p)) ggplot(data = df, aes(x = as.factor(resistancy_group), y = pwd_mean)) + theme_cowplot() + geom_boxplot(aes(fill = resistancy_group), outlier.shape = NA) + scale_fill_manual(values = c(Resistant = &#39;#DE3163&#39;, Sensitive = &#39;#5090CD&#39;)) + xlab(&#39;&#39;) + ylab(&#39;Intraclone variability (MEDICC2)&#39;) + stat_pvalue_manual(mwu_het, label = &#39;empty&#39;) + annotate( &#39;text&#39;, x = 1.5, y = het_y + 3, label = paste0(&quot;italic(P)==&quot;, mwu_het$p), parse = T ) + theme( axis.text.x = element_text(angle = 45, hjust=1), legend.position = &quot;none&quot;, aspect.ratio = 5 / 1.5) 5.1.3 Copy number length analysis ######## # Data # ######## load(&#39;../cna_analysis/rda/cin_analysis/subclone_cn_matrices.rda&#39;) ####### # Run # ####### cna_profile_per_subclone_output &lt;- lapply(subclone_cn_matrix, cna_profiler) ########### # Wrangle # ########### # binding togehter cna_df &lt;- bind_rows(cna_profile_per_subclone_output, .id = &quot;unique_id&quot;) # add radiation status cna_df$rad &lt;- str_extract(pattern = &#39;prerad|postrad&#39;, cna_df$unique_id) ######## # Data # ######## load(&#39;../cna_analysis/rda/cin_analysis/cna_profiles.rda&#39;) ################ ### BASELINE ### ################ ########### # Wrangle # ########### # include only those organoids that we are interested in for this analysis cna_df &lt;- cna_df[!grepl(pattern = &#39;biological|c2&#39;, cna_df$unique_id ),] res_df &lt;- subset(cna_df, unique_id %in% cna_df$unique_id[c( grep(&#39;hub005&#39;, cna_df$unique_id), grep(&#39;hub183&#39;, cna_df$unique_id), grep(&#39;hub015&#39;, cna_df$unique_id), grep(&#39;hub062_prerad_a&#39;, cna_df$unique_id), grep(&#39;hub197_prerad_a&#39;, cna_df$unique_id) )]) %&gt;% mutate(resistancy_group = &#39;Resistant&#39;) sens_df &lt;- subset(cna_df, unique_id %in% cna_df$unique_id[c( grep(&#39;hub106&#39;, cna_df$unique_id), grep(&#39;hub197&#39;, cna_df$unique_id), grep(&#39;hub062_prerad_b&#39;, cna_df$unique_id), grep(&#39;hub062_postrad_b&#39;, cna_df$unique_id), grep(&#39;hub062_prerad_c&#39;, cna_df$unique_id), grep(&#39;hub062_postrad_c&#39;, cna_df$unique_id) )]) %&gt;% mutate(resistancy_group = &#39;Sensitive&#39;) %&gt;% filter(unique_id != &#39;hub197_prerad_a&#39;) df &lt;- rbind(res_df, sens_df) # remove postrad df &lt;- df %&gt;% filter(rad != &#39;postrad&#39;) %&gt;% rbind(df %&gt;% filter(unique_id == &#39;hub062_postrad_a&#39; )) # making bins df_scna &lt;- df %&gt;% mutate(scna = ifelse(fraction &lt; 0.3, &#39;fCNA&#39;, ifelse(fraction &gt; &#39;0.98&#39;, &#39;arm&#39;, &#39;lCNA&#39;))) %&gt;% group_by(cell_id, rad, resistancy_group) %&gt;% count(scna) ######## # Plot # ######## # Boxplot # ########### ### STATISTICS PER CELL ### stat &lt;- compare_means( n ~ resistancy_group, group.by = c(&#39;scna&#39;), data = df_scna, method = &quot;wilcox.test&quot;, paired = F ) y.post = c(40, 35, 30) stat &lt;- stat %&gt;% mutate(y.position = y.post, empty = &#39; &#39;) %&gt;% mutate(p = format(p, digits = 2)) %&gt;% mutate(p = as.numeric(p)) %&gt;% mutate(p = format(p, scientific = T)) %&gt;% mutate(p = sub(&quot;e&quot;, &quot;%.% 10^&quot;, p)) stat &lt;- within(stat, p[p.signif == &#39;ns&#39;] &lt;- &#39;ns&#39;) # Plot ggplot(df_scna, aes(x= as.factor(scna), y = n, group = interaction(scna, resistancy_group))) + geom_point(aes(alpha= 1, col = resistancy_group), position=position_jitterdodge(1, jitter.width = 0.1)) + guides(alpha = &#39;none&#39;) + scale_colour_manual(values=c(Resistant = &#39;#DE3163&#39;, Sensitive =&#39;#5090CD&#39;)) + geom_boxplot(outlier.shape = NA, aes(fill = resistancy_group)) + theme_cowplot() + scale_fill_manual(values=c(Resistant = &#39;#DE3163&#39;, Sensitive =&#39;#5090CD&#39;), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length(unique(df_scna$resistancy_group)))), shape = c(rep(19, length(unique(df_scna$resistancy_group))))))) + # stat_summary(alpha = 0.8, fun.y=mean, position = position_dodge(0.75), geom=&quot;point&quot;, shape=18, size=2, color=&quot;#2E3440&quot;, fill=&quot;#2E3440&quot;) + labs(x=expression(atop(&quot; &quot;)), y=expression(atop(&quot;CNA count (per single cell)&quot;))) + theme(legend.title=element_blank(), aspect.ratio = 5/3, axis.text.x = element_text(angle = 45, hjust = 1)) + scale_x_discrete(limits = c(&#39;fCNA&#39;, &#39;lCNA&#39;, &#39;arm&#39;), labels=c(&quot;fCNA&quot; = &quot;focal CNA&quot;, &quot;lCNA&quot; = &quot;large CNA&quot;, &quot;arm&quot; = &quot;arm/chromosome CNA&quot;)) + # adding P value to fSCNA annotate(linewidth = 0.25,&quot;segment&quot;, x = 0.8125, xend = 1.1875, y = y.post[1], yend = y.post[1]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 0.8125, xend = 0.8125, y = y.post[1], yend = y.post[1]-1.05) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.1875, xend = 1.1875, y = y.post[1], yend = y.post[1]-1.05) + annotate( &#39;text&#39;, x = 1.3, y = y.post[1] +2.284, label = paste0(&quot;italic(P)==&quot;, stat$p[2]), parse = T ) + # adding P value to lSCNA annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.8125, xend = 2.1875, y = y.post[2], yend = y.post[2]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.8125, xend = 1.8125, y = y.post[2], yend = (y.post[2]-1.05)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.1875, xend = 2.1875, y = y.post[2], yend = (y.post[2]-1.05)) + annotate( &#39;text&#39;, x = 2.2, y = y.post[2] + 2.284, label = paste0(&quot;italic(P)==&quot;, stat$p[3]), parse = T ) + # adding P value to arm annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.8125, xend = 3.1875, y = y.post[3], yend = y.post[3]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.8125, xend = 2.8125, y = y.post[3], yend = (y.post[3]-1.05)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 3.1875, xend = 3.1875, y = y.post[3], yend = (y.post[3]-1.05)) + annotate( &#39;text&#39;, x = 3.2, y = y.post[3] + 2.284, label = paste0(&quot;italic(P)==&quot;, stat$p[1]), parse = T ) + coord_cartesian(clip = &#39;off&#39;) # making sure the p values don&#39;t can&#39;t clipped when going out of the plot margin #################### ### RAD RESPONSE ### #################### res_df &lt;- subset(cna_df, unique_id %in% cna_df$unique_id[c( grep(&#39;hub005&#39;, cna_df$unique_id), grep(&#39;hub183&#39;, cna_df$unique_id), grep(&#39;hub015&#39;, cna_df$unique_id), grep(&#39;hub062_prerad_a&#39;, cna_df$unique_id), grep(&#39;hub062_postrad_a&#39;, cna_df$unique_id), grep(&#39;hub197_prerad_a&#39;, cna_df$unique_id), grep(&#39;hub197_postrad_a&#39;, cna_df$unique_id) )]) %&gt;% mutate(resistancy_group = &#39;Resistant&#39;) sens_df &lt;- subset(cna_df, unique_id %in% cna_df$unique_id[c( grep(&#39;hub106&#39;, cna_df$unique_id), grep(&#39;hub062_prerad_b&#39;, cna_df$unique_id), grep(&#39;hub062_postrad_b&#39;, cna_df$unique_id), grep(&#39;hub062_prerad_c&#39;, cna_df$unique_id), grep(&#39;hub062_postrad_c&#39;, cna_df$unique_id) )]) %&gt;% mutate(resistancy_group = &#39;Sensitive&#39;) df &lt;- rbind(res_df, sens_df) # making bins df_scna &lt;- df %&gt;% mutate(scna = ifelse(fraction &lt; 0.3, &#39;fCNA&#39;, ifelse(fraction &gt; &#39;0.98&#39;, &#39;arm&#39;, &#39;lCNA&#39;))) %&gt;% group_by(cell_id, rad, resistancy_group) %&gt;% count(scna) df_scna %&gt;% ungroup() %&gt;% group_by(scna, rad, resistancy_group) %&gt;% summarize(mean = mean(n), median = median(n)) ## # A tibble: 12 × 5 ## # Groups: scna, rad [6] ## scna rad resistancy_group mean median ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 arm postrad Resistant 9.42 9 ## 2 arm postrad Sensitive 15.9 17 ## 3 arm prerad Resistant 9.36 7 ## 4 arm prerad Sensitive 15.7 15 ## 5 fCNA postrad Resistant 6.86 6 ## 6 fCNA postrad Sensitive 10.0 9 ## 7 fCNA prerad Resistant 6.14 6 ## 8 fCNA prerad Sensitive 7.05 7 ## 9 lCNA postrad Resistant 6.93 7 ## 10 lCNA postrad Sensitive 11.6 11 ## 11 lCNA prerad Resistant 5.06 4 ## 12 lCNA prerad Sensitive 8.65 8 # changing levels df_scna$scna &lt;- factor(df_scna$scna,levels = c(&quot;fCNA&quot;, &quot;lCNA&quot;, &quot;arm&quot;)) df_scna$rad &lt;- factor(df_scna$rad , levels = c(&#39;prerad&#39;,&#39;postrad&#39;)) # Statistics # ############## stat &lt;- compare_means( data = df_scna, n ~ rad, group.by = c(&#39;scna&#39;, &#39;resistancy_group&#39;), method = &quot;wilcox.test&quot;, paired = F ) y.post = c(32, 32, 28, 32, 32, 36) stat &lt;- stat %&gt;% mutate(y.position = y.post, empty = &#39; &#39;) %&gt;% mutate(p = format(p, digits = 2)) %&gt;% mutate(p = as.numeric(p)) %&gt;% mutate(p = format(p, scientific = T)) %&gt;% mutate(p = sub(&quot;e&quot;, &quot;%.% 10^&quot;, p)) stat &lt;- within(stat, p[p.signif == &#39;ns&#39;] &lt;- &#39;ns&#39;) ### Resistant ### ggplot(subset(df_scna, resistancy_group == &#39;Resistant&#39;), aes(x= as.factor(scna), y = n, group = interaction(scna, rad))) + geom_jitter(aes(alpha= 0.8, col = rad), position=position_jitterdodge()) + guides(alpha = &#39;none&#39;, col = &#39;none&#39;) + scale_colour_manual(values=c(prerad = &quot;#999999&quot;, postrad =&quot;#E69F00&quot;)) + geom_boxplot(outlier.shape = NA, aes(fill = rad)) + stat_summary(alpha = 0.8, fun.y=mean, position = position_dodge(0.75), geom=&quot;point&quot;, shape=18, size=2, color=&quot;#2E3440&quot;, fill=&quot;#2E3440&quot;) + theme_cowplot() + scale_fill_manual(values=c(prerad = &quot;#999999&quot;, postrad =&quot;#E69F00&quot;), labels = c(prerad = &#39;Baseline&#39;, postrad = &#39;Recurrence&#39;), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length(unique(df_scna$resistancy_group)))), shape = c(rep(19, length(unique(df_scna$resistancy_group))))))) + labs(x=expression(atop(&quot; &quot;)), y=expression(atop(&quot;SCNA count (per single cell)&quot;))) + theme(strip.background = element_rect( color=&quot;white&quot;, fill=&quot;white&quot;, linetype=&quot;solid&quot; ), legend.title=element_blank(), aspect.ratio = 5/3) + labs(title = &#39;Resistant&#39;) + theme(plot.title = element_text(hjust = 0.5, face = &#39;plain&#39;), legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 45, hjust = 1)) + scale_x_discrete(limits = c(&#39;fCNA&#39;, &#39;lCNA&#39;, &#39;arm&#39;), labels=c(&quot;fCNA&quot; = &quot;focal CNA&quot;, &quot;lCNA&quot; = &quot;large CNA&quot;, &quot;arm&quot; = &quot;arm/chromosome CNA&quot;)) + # adding P value to fSCNA annotate(linewidth = 0.25,&quot;segment&quot;, x = 0.8125, xend = 1.1875, y = y.post[2], yend = y.post[2]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 0.8125, xend = 0.8125, y = y.post[2], yend = (y.post[2]-0.7)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.1875, xend = 1.1875, y = y.post[2], yend = (y.post[2]-0.7)) + annotate( &#39;text&#39;, x = 1.2, y = y.post[2] * 1.0571, label = paste0(&quot;italic(P)==&quot;, stat$p[2]), parse = T ) + # adding P value to lSCNA annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.8125, xend = 2.1875, y = y.post[3], yend = y.post[3]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.8125, xend = 1.8125, y = y.post[3], yend = (y.post[3]-0.7)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.1875, xend = 2.1875, y = y.post[3], yend = (y.post[3]-0.7)) + annotate( &#39;text&#39;, x = 2, y = y.post[3] * 1.0571, label = paste0(&quot;italic(P)==&quot;, stat$p[3]), parse = T ) + # adding P value to arm annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.8125, xend = 3.1875, y = y.post[1], yend = y.post[1]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.8125, xend = 2.8125, y = y.post[1], yend = (y.post[1]-0.7)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 3.1875, xend = 3.1875, y = y.post[1], yend = (y.post[1]-0.7)) + annotate( &#39;text&#39;, x = 3, y = y.post[1] * 1.0571, label = paste0(&quot;italic(P)==&quot;, stat$p[1]), parse = T ) + coord_cartesian(clip = &#39;off&#39;) ### Sensitive ### ggplot(subset(df_scna, resistancy_group == &#39;Sensitive&#39;), aes(x= as.factor(scna), y = n, group = interaction(scna, rad))) + geom_jitter(aes(alpha= 0.8, col = rad), position=position_jitterdodge()) + guides(alpha = &#39;none&#39;, col = &#39;none&#39;) + scale_colour_manual(values=c(prerad = &quot;#999999&quot;, postrad =&quot;#E69F00&quot;)) + geom_boxplot(outlier.shape = NA, aes(fill = rad)) + stat_summary(alpha = 0.8, fun.y=mean, position = position_dodge(0.75), geom=&quot;point&quot;, shape=18, size=2, color=&quot;#2E3440&quot;, fill=&quot;#2E3440&quot;) + theme_cowplot() + scale_fill_manual(values=c(prerad = &quot;#999999&quot;, postrad =&quot;#E69F00&quot;), labels = c(prerad = &#39;Baseline&#39;, postrad = &#39;Recurrence&#39;), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length(unique(df_scna$resistancy_group)))), shape = c(rep(19, length(unique(df_scna$resistancy_group))))))) + labs(x=expression(atop(&quot; &quot;)), y=expression(atop(&quot;SCNA count (per single cell)&quot;))) + theme(legend.position = &quot;none&quot;, strip.background = element_rect( color=&quot;white&quot;, fill=&quot;white&quot;, linetype=&quot;solid&quot; ), legend.title=element_blank(), aspect.ratio = 5/3) + labs(title = &#39;Sensitive&#39;) + theme(plot.title = element_text(hjust = 0.5, face = &#39;plain&#39;),axis.text.x = element_text(angle = 45, hjust = 1)) + scale_x_discrete(limits = c(&#39;fCNA&#39;, &#39;lCNA&#39;, &#39;arm&#39;), labels=c(&quot;fCNA&quot; = &quot;focal CNA&quot;, &quot;lCNA&quot; = &quot;large CNA&quot;, &quot;arm&quot; = &quot;arm/chromosome CNA&quot;)) + # adding P value to fSCNA annotate(linewidth = 0.25,&quot;segment&quot;, x = 0.8125, xend = 1.1875, y = y.post[5], yend = y.post[5]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 0.8125, xend = 0.8125, y = y.post[5], yend = (y.post[5]-0.7)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.1875, xend = 1.1875, y = y.post[5], yend = (y.post[5]-0.7)) + annotate( &#39;text&#39;, x = 1.3, y = y.post[5] * 1.0571, label = paste0(&quot;italic(P)==&quot;, stat$p[5]), parse = T ) + # adding P value to lSCNA annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.8125, xend = 2.1875, y = y.post[6], yend = y.post[6]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 1.8125, xend = 1.8125, y = y.post[6], yend = (y.post[6]-0.7)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.1875, xend = 2.1875, y = y.post[6], yend = (y.post[6]-0.7)) + annotate( &#39;text&#39;, x = 2.2, y = y.post[6] * 1.0571, label = paste0(&quot;italic(P)==&quot;, stat$p[6]), parse = T ) + # adding P value to arm annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.8125, xend = 3.1875, y = y.post[4], yend = y.post[4]) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 2.8125, xend = 2.8125, y = y.post[4], yend = (y.post[4]-0.7)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 3.1875, xend = 3.1875, y = y.post[4], yend = (y.post[4]-0.7)) + annotate( &#39;text&#39;, x = 3.3, y = y.post[4] * 1.0571, label = paste0(&quot;italic(P)==&quot;, stat$p[4]), parse = T ) + coord_cartesian(clip = &#39;off&#39;) 5.2 CCLE analysis 5.2.1 Ploidy and whole genome duplication analysis # absolute calls df_absolute &lt;- read_excel(&quot;../cna_analysis/data/cna_analysis/CCLE_ABSOLUTE_combined_20181227.xlsx&quot;, sheet = &quot;ABSOLUTE_combined.table&quot;) # resistancy data load(&#39;../cna_analysis/rda/cna_analysis/ccle_rad_data.rda&#39;) ########### # PLOIDY # ########### # change column name depMapID in df_absolute to DepMap_ID so it matches the column # in rad_df names(df_absolute)[names(df_absolute) == &#39;depMapID&#39;] &lt;- &#39;DepMap_ID&#39; # bring two dataframes together comb_df &lt;- left_join(rad_df, df_absolute, by = &#39;DepMap_ID&#39;) # only resistant and sensitive groups comb_df &lt;- subset(comb_df, resistancy_group != &#39;Intermediate&#39;) # add a wgd_status column comb_df$wgd_status &lt;- ifelse(comb_df$Genome.doublings == 0, &#39;0&#39;, &#39;1&#39;) comb_df &lt;- comb_df[!is.na(comb_df$wgd_status),] comb_df &lt;- comb_df[!is.na(comb_df$primary_disease),] comb_df &lt;- comb_df[!is.na(comb_df$subtype_disease),] comb_df %&gt;% group_by(resistancy_group) %&gt;% summarize(mean_ploidy = mean(ploidy)) ## # A tibble: 2 × 2 ## resistancy_group mean_ploidy ## &lt;chr&gt; &lt;dbl&gt; ## 1 Resistant 2.71 ## 2 Sensitive 2.43 t &lt;- lm(as.numeric(comb_df$ploidy) ~ as.factor(comb_df$resistancy_group) + as.factor(comb_df$primary_disease) + as.factor(comb_df$subtype_disease)) t &lt;- summary(t) t_cof &lt;- t$coefficients # p value resistancy class t_cof[2,] ## Estimate Std. Error t value Pr(&gt;|t|) ## -0.2469465 0.1516792 -1.6280843 0.1057716 ####### # WGD # ####### tabol &lt;- table(comb_df$resistancy_group,comb_df$wgd_status) #radioresistant percentage with WGD tabol[1,2] / (tabol[1,1] + tabol[1,2])*100 ## [1] 64.7619 #radiosensitive percentage with WGD tabol[2,2] / (tabol[2,1] + tabol[2,2])*100 ## [1] 42.26804 # removing NAs comb_df &lt;- comb_df[!is.na(comb_df$wgd_status) | is.na(comb_df$primary_disease) | is.na(comb_df$subtype_disease),] t_wgd &lt;- glm(as.numeric(as.factor(comb_df$wgd_status)) ~ as.factor(comb_df$resistancy_group) + as.factor(comb_df$primary_disease) + as.factor(comb_df$subtype_disease)) t_wgd &lt;- summary(t_wgd) t_wgd_cof &lt;- t_wgd$coefficients # p value whole genome status. class t_wgd_cof[2,] ## Estimate Std. Error t value Pr(&gt;|t|) ## -0.08592444 0.08505858 -1.01017960 0.31416449 5.2.2 Run CIN signature ######## # Data # ######## # radiation data load(&#39;../cna_analysis/rda/cna_analysis/ccle_rad_data.rda&#39;) # metadata load(&#39;../cna_analysis/data/cna_analysis/22Q4_sample_info&#39;) # cnv data cnv_ccle &lt;- read.csv(&#39;../cna_analysis/data/cna_analysis/22Q4_CCLE_segment_cn.csv&#39;) ########### # Wrangle # ########### colnames(meta_df)[1] &lt;- &#39;DepMap_ID&#39; ####### # Run # ####### # run_cin_ccle for cells from which we have radiation sensitivity data cin_df &lt;- run_cin_ccle(cnv_ccle, rad_df) 5.2.3 Statistics CIN signature ############# # Statistics # ############## # Number of cell lines length(unique(cin_df$DepMap_ID)) ## [1] 529 # CX1 and CX7 are statistically different (including adjustment for primary disease and subtype). stat &lt;- bind_rows(lapply(unique(cin_df$cx_signature), function(cx_sig) { d &lt;- cin_df %&gt;% filter(resistancy_group %in% c(&#39;Resistant&#39;, &#39;Sensitive&#39;)) %&gt;% filter(cx_signature == cx_sig) # running lm so to control for primary_disease and subtype mean_cxscore_resistant &lt;- mean(subset(d, resistancy_group == &#39;Resistant&#39;)$cx_value) mean_cxscore_sensitive &lt;- mean(subset(d, resistancy_group == &#39;Sensitive&#39;)$cx_value) fc &lt;- mean_cxscore_resistant/mean_cxscore_sensitive lm_o &lt;- summary(lm(cx_value ~ resistancy_group + primary_disease + subtype_disease, data = d)) p_val &lt;- lm_o$coefficients[2,4] df &lt;- data.frame(cx_signature = cx_sig, mean_cxscore_resistant = mean_cxscore_resistant, mean_cxscore_sensitive = mean_cxscore_sensitive, fc = fc, p = p_val) return(df) }), .id = &quot;cx_signature&quot;) ########## # Excell # ########## # vector stating the cx_cause cx_cause &lt;- c( &#39;Chromosome missegregation via defective mitosis and/or telomere dysfunction&#39;, &#39;IHR&#39;, &#39;IHR with replication stress and impaired damage sensing&#39;, &#39;PI3K-AKT-mediated toleration of whole-genome duplication&#39;, &#39;IHR with replication stress&#39;, &#39;Chromosome missegragation via defective mitosis&#39;, &#39;Unkown&#39;, &#39;Replication stress&#39;, &#39;Replication stress&#39;, &#39;Impaired NHEJ with replication stress&#39;, &#39;Replication stress&#39;, &#39;Unknown&#39;, &#39;Replication stress&#39;, &#39;Chromosome missegregation via defective mitosis&#39;, &#39;Unknown&#39;, &#39;Unknown&#39;, &#39;Unknown&#39; ) stat$cx_cause &lt;- cx_cause # datatable showing p value of linear model adjusted for primary disease and subtype DT::datatable(stat) 5.2.4 Plot CX1 CIN signature stat &lt;- stat %&gt;% filter(p &lt; 0.05) %&gt;% mutate(p = format(p, digits = 2)) %&gt;% mutate(p = as.numeric(p)) %&gt;% mutate(p = format(p, scientific = T)) %&gt;% mutate(p = sub(&quot;e&quot;, &quot;%.% 10^&quot;, p)) # Function plot_ccle_cx &lt;- function(df, cx_sig, y.post, row) { #&#39; @param df is a dataframe #&#39; @param y.post where to put the p value label #&#39; @param cx_sig is the signature to output #&#39; @param which row in stat to take the p value from #&#39; @return a boxplot d &lt;- df %&gt;% filter(resistancy_group %in% c(&#39;Resistant&#39;, &#39;Sensitive&#39;)) %&gt;% filter(cx_signature == cx_sig) p &lt;- ggplot(data = d, aes(x = as.factor(resistancy_group), y = cx_value)) + geom_quasirandom(aes(alpha = 0.5, col = resistancy_group)) + guides(alpha = &#39;none&#39;) + geom_boxplot(outlier.shape = NA, aes(fill = resistancy_group)) + scale_colour_manual(values=c(Resistant = &#39;#DE3163&#39;, Sensitive =&#39;#5090CD&#39;)) + labs(x=expression(atop(&quot; &quot;)), y=expression(atop(&quot;CIN signature score&quot;,atop(&quot;CCLE cancer cell lines&quot;)))) + theme_cowplot() + scale_fill_manual(values=c(Resistant = &#39;#DE3163&#39;, Sensitive =&#39;#5090CD&#39;), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length(unique( d$resistancy_group)))), shape = c(rep(19, length(unique( d$resistancy_group))))))) + theme(axis.text.x = element_text(angle = 45, hjust=1), legend.title=element_blank(), aspect.ratio = 5/1.5) + labs(title = cx_sig)+ theme(plot.title = element_text(hjust = 0.5, face = &#39;plain&#39;)) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 1, xend = 2, y = y.post, yend = y.post) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 1, xend = 1, y = y.post, yend = y.post-max(d$cx_value)/20) + annotate(linewidth = 0.25,&quot;segment&quot;, x = 2, xend = 2, y = y.post, yend = y.post-max(d$cx_value)/20) + annotate( &#39;text&#39;, x = 1.5, y = y.post[1] + max(d$cx_value)/18, label = paste0(&quot;italic(P)==&quot;, stat$p[row]), parse = T ) p } ### CX1 ### plot_ccle_cx(cin_df, cx_sig = &#39;CX1&#39;, y.post = 0.9, row = 1) "],["source-code.html", "6 Source code 6.1 AUC_rad script: ‘AUC_fun’ function 6.2 fitter_rad script: ‘fitter’ function 6.3 ic50_rad script: ‘IC50_fun’ function 6.4 relativize_dr script: ‘relative’ function 6.5 quality_functions script: ‘quality_check’, ‘quality_select’ and ‘check_quality’ functions 6.6 plot_pca_kmeans script: ‘draw_pca’, ‘k_cluster’, ‘draw_pca_double’ and ‘k_cluster_double’ functions 6.7 divide_subclone_functions script: ‘extract_other_cells’, ‘extract_square’, ‘l_g’ and ‘subclone_classes_for_genomeheatmap’ functions 6.8 plot_genomeheatmap script: ‘genomeheatmap’ function 6.9 fisher_test script: ‘perform_fisher’ function 6.10 find_specific_cna_sc script: ‘find_specific_cna_sc’ function 6.11 get_cytoband_coverage script: ‘get_cytoband_coverage’ function 6.12 get_genes script: ‘get_genes’ functoin 6.13 get_oncogenes scripts: ‘get_oncogenes’ function 6.14 plot_genes_karyotype script: ‘plot_genes_karyotype’ function 6.15 shifters script: ‘create_cn_matrix’ and ‘cluster_and_shift_transitions’ functions 6.16 calculate_heterogeneity_score script: ‘calculate_heterogeneity_score’ function 6.17 cna_profiler script: ‘cna_profiler’ function 6.18 cin_signature_ccle script: ‘run_cin_ccle’ function", " 6 Source code The source code in this here is arranged in a loose chronological order, reflecting the sequence in which it is called in the scripts presented throughout this book. 6.1 AUC_rad script: ‘AUC_fun’ function # returns the AUC of the actual data. AUC_fun &lt;- function(df) { # defining variables to work with d &lt;- df lines &lt;- character() # for loop, checks if CF$cline is in vector lines, if so, do nothing, else append to vector. for (line in d$cline) ( ifelse(line %in% lines, NA, lines &lt;- c(lines, line))) # separate into dataframes according to cline per_line &lt;- split(d, f = d$cline, drop = TRUE) # define dose_vetor dose_vector &lt;- unique(d$dose) # computes AUC for given predicted survival and dose given by dose_vector AUC_calc &lt;- function(df) { # extract actual data rel_mean &lt;- df$relative_mean # extracts number of experiemnts n &lt;- length(unique(d$Exp)) #remove 2th and 3th number (are duplicates) rel_mean &lt;- rel_mean[seq(1, length(rel_mean), n)] # compute maximal max_AUC &lt;- max(dose_vector)*1 #compute AUC act_AUC &lt;- AUC(x=dose_vector, y = rel_mean) # make dataframe datafr &lt;- data.frame(max_AUC = max_AUC, act_AUC = act_AUC, rel_AUC = act_AUC/max_AUC, expcode = unique(df$expcode), cline= unique(df$cline), treatment = unique(df$treatment ) ) return(datafr) } # Store in vector AUC_vector &lt;- lapply(per_line, AUC_calc) #merge dataframes df = do.call(rbind, AUC_vector) return(df) } 6.2 fitter_rad script: ‘fitter’ function fitter &lt;- function(df) { # defining variables to work with d &lt;- df lines &lt;- character() # for loop, checks if CF$cline is in vector lines, if so, do nothing, else append to vector. for (line in d$cline) ( ifelse(line %in% lines, NA, lines &lt;- c(lines, line))) # separate into dataframes according to cline per_line &lt;- split(d, f = d$cline, drop = TRUE) # Function to make model for every line and dataframe with predicted data for each line. fit_model= function(line) { # line is a dataframe. Outputs the fits of norm and dose fit &lt;- drm(relative ~ dose, # define y -axis (ncolonies) and x-axis (dose) data = line, # defines dataframe fct = LL.4 (names = c(&#39;Slope&#39;, &quot;Lower Limit&quot;, &quot;Upper Limit&quot;, &quot;IC50&quot;))) # defines to fit a log-losistic model) newdata &lt;- expand.grid(dose=exp(seq(log(0.00000001), log(max(df$dose) + 1000), length=1000))) # new data with doses. Note: lowest dose is not # log 0 but log(&#39;very small number&#39;) because otherwise this will hamper the scaling in ggplot later on. pm &lt;- predict(fit, newdata=newdata, interval=&quot;confidence&quot;) # new data with predictions and confidence intervals newdata$pred &lt;- pm[,1] # add prediction values to new data. newdata$predmin &lt;- pm[,2] # add lower bounderies to new data newdata$predmax &lt;- pm[,3] # add upper bounderies to new data newdata$cline &lt;- line$cline[1] # add column with cline. newdata$expcode = unique(df$expcode) return(newdata) } # Store in vector data_frames &lt;- lapply(per_line, fit_model) #merge dataframes df = do.call(rbind, data_frames) return(df) } 6.3 ic50_rad script: ‘IC50_fun’ function IC50_fun &lt;- function(df, rad) { # defining variables to work with ifelse(is.null(rad), d&lt;-df, d &lt;- subset(df, rec_rad == rad)) lines &lt;- character() # for loop, checks if CF$cline is in vector lines, if so, do nothing, else append to vector. for (line in d$cline) ( ifelse(line %in% lines, NA, lines &lt;- c(lines, line))) # separate into dataframes according to cline per_line &lt;- split(d, f = d$cline, drop =TRUE) # Function to make model for every line and dataframe with predicted data for each line. ic50= function(line) { # line is a dataframe. Outputs the fits of norm and dose fit &lt;- drm(relative ~ dose, # define y -axis (ncolonies) and x-axis (dose) data = line, # defines dataframe fct = LL.4 (names = c(&#39;Slope&#39;, &quot;Lower Limit&quot;, &quot;Upper Limit&quot;, &quot;IC50&quot;))) # defines to fit a log-losistic model) return(coef(fit)[4]) } # Store in vector IC50_vector &lt;- lapply(per_line, ic50) #merge dataframes df = do.call(rbind, IC50_vector) return(df) } 6.4 relativize_dr script: ‘relative’ function relative &lt;- function(df, rad) { #&#39; @param df with dose response data and columns cline, dose, Exp, #&#39; rec_rad, expcode, ncolonies #&#39; @param rad if line received radiation (T or F), stored in column rec_rad #&#39; @return relativized data where dose = 0 is used as 100% # defining variables to work with ifelse(rad == T, d&lt;-subset(df, rec_rad == 1), d&lt;-subset(df, rec_rad == 0) ) # define ncolonies column &lt;- &quot;ncolonies&quot; # Extracts the column name. col &lt;- d[c(column)] # extracts number of experiemnts n &lt;- length(unique(d$Exp)) # Takes mean every nth row mean_fun &lt;- function(x) { m &lt;- mean(x, na.rm = TRUE) return(m) } mean &lt;- aggregate(col,list(rep(1:(nrow(col)%/%n+1),each=n,len=nrow(col))), mean_fun)[-1] # Duplicates (n=2) or triplicates (n=3) the rows. mean &lt;- mean[rep(seq_len(nrow(mean)), each = n), ] # Adds everything to the dataframe. d[&quot;mean&quot;] &lt;- mean # Select mean values of 0 concentration d &lt;- d %&gt;% group_by(cline) %&gt;% arrange(cline,dose) first &lt;- d[d$dose==0, ] %&gt;% dplyr::select(cline, value100=mean) # Make cline a factor d$cline&lt;-factor(d$cline) # Merge first original (d) d &lt;- d %&gt;% merge(first,by=c(&quot;cline&quot;)) # Extract only every nth row. d = d[seq(1, nrow(d), n), ] # make new column with relative, called relative d$relative = d$ncolonies/d$value100 d$relative_mean = d$mean/d$value100 d&lt;-subset(d, select=-c(mean,value100)) # compute relative standard error of the mean # define the column with sem in it column &lt;- &quot;relative&quot; # Extracts the column name. col &lt;- d[c(column)] sem_fun &lt;- function(x) { std &lt;- sd(x, na.rm = TRUE) vector &lt;- na.omit(x) sem &lt;- std/sqrt(length(vector)) return(sem) } sem &lt;- aggregate(col,list(rep(1:(nrow(col)%/%n+1),each=n,len=nrow(col))),sem_fun)[-1] sem &lt;- sem[rep(seq_len(nrow(sem)), each = n), ] d[&quot;relative_sem&quot;] &lt;- sem return(d) } 6.5 quality_functions script: ‘quality_check’, ‘quality_select’ and ‘check_quality’ functions quality_check &lt;- function(inputdir, model) { #&#39; @param inputdir is directory containing the standard aneufinder output for each plate #&#39; model is which model to use for the quality check: either dnacopy, edivisive or HMM #&#39; quality_check will make quality metrics for each plate #&#39; quality_check assumes that rdaBaseDirectory contains folder with models for each plate #&#39; each plate folder has to contain a MODEL folder and a method-&#39;dnacopy, edivisive, or HMM&#39; folder #&#39; @example quality_check(inputdir = rdaBaseDirectory, model = &#39;edivisive&#39;) # go to folder with appropiate files rda_folder &lt;- paste0(inputdir, &#39;/MODELS&#39;, &#39;/method-&#39;, model) # extract files rda_files &lt;- list.files(rda_folder, full.names = TRUE) # run quality check on each file cl &lt;- clusterByQuality( rda_files, measures = c( &#39;spikiness&#39;, &#39;num.segments&#39;, &#39;entropy&#39;, &#39;bhattacharyya&#39;, &#39;sos&#39; ) ) return(cl) } quality_select &lt;- function(cl, spik, bhat) { #&#39; selects all files that meets the defined quality requirements #&#39; @param cl output of the clusterByQuality function in AneuFinder #&#39; @param spik the spikiness treshhold. All clusters with spikiness above #&#39; the treshold will be removed #&#39; @param bhat the bhattacharrya score. All clusters with bhattacharrya below #&#39; the treshold will be removed #&#39; @return returns a vector of selected files paths # convert to df to allow easy wrangling cl_df &lt;- as.data.frame(cl$parameters) # remove higher than spik spik &lt;- subset(cl_df, spikiness &lt; spik) # remove lower than bhat spik_bhat &lt;- subset(spik, bhattacharyya &gt; bhat) cluster_n &lt;- nrow(spik_bhat) # create vector of selected files selected.files &lt;- unlist(cl$classification[0:cluster_n]) return(selected.files) } check_quality &lt;- function(cl) { return(cl$parameters) } } 6.6 plot_pca_kmeans script: ‘draw_pca’, ‘k_cluster’, ‘draw_pca_double’ and ‘k_cluster_double’ functions draw_pca &lt;- function(list_files1, list_files2, size, legend_position, baseline_kra, recurrence_kra, ssdna004 = F) { cells &lt;- c(list_files1, list_files2) df &lt;- plot_pca( cells, colorBy = classes, PC1 = 1, PC2 = 2, plot = F ) df$class &lt;- str_extract(rownames(df), &#39;KRA-0\\\\d+&#39;) num &lt;- str_extract(rownames(df), &#39;_\\\\d+\\\\.&#39;) num &lt;- str_remove_all(num, pattern = &#39;\\\\.&#39;) df$label &lt;- paste0(df$class, num) pc1 &lt;- colnames(df)[1] pc2 &lt;- colnames(df)[2] colnames(df) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;, &#39;class&#39;, &#39;label&#39;) col_vals &lt;- ifelse(ssdna004 == T, list(c(&quot;#D69C4E&quot;, &quot;#999999&quot;)), list(c(&quot;#999999&quot;, &quot;#D69C4E&quot;))) label_vals &lt;- ifelse(ssdna004 == T, list(c(&#39;Recurrence&#39;, &#39;Baseline&#39;)), list(c(&#39;Baseline&#39;, &#39;Recurrence&#39;))) p &lt;- ggplot(data = df, aes(label = label)) + geom_point(size = size, aes(x = PC1, y = PC2, col = class)) + # scale_color_manual(values = c(&quot;#FFDB6D&quot;, &quot;#00AFBB&quot;)) + scale_color_manual( name = &#39;&#39;, values = col_vals[[1]], labels = label_vals[[1]] ) + # or consider &#39;#9e1303&#39; for second cycle of recurrence theme_cowplot() + theme(legend.position = legend_position, text = element_text(size = 17), axis.text = element_text(size = 15)) + labs(x = pc1, y = pc2) p # ggplotly(p) } k_cluster &lt;- function(list_files1, list_files2, cluster_n, cols, labels, legend_position, normalize, return_elbow = F) { require(factoextra) cells &lt;- c(list_files1, list_files2) df12 &lt;- plot_pca( cells, colorBy = classes, PC1 = 1, PC2 = 2, plot = F ) df34 &lt;- plot_pca( cells, colorBy = classes, PC1 = 3, PC2 = 4, plot = F ) df56 &lt;- plot_pca( cells, colorBy = classes, PC1 = 5, PC2 = 6, plot = F ) df78 &lt;- plot_pca( cells, colorBy = classes, PC1 = 7, PC2 = 8, plot = F ) df910 &lt;- plot_pca( cells, colorBy = classes, PC1 = 9, PC2 = 10, plot = F ) df &lt;- cbind(df12, df34, df56, df78, df910) if (normalize) { # extract variance explained for each pca pca_var &lt;- as.numeric(str_match(colnames(df), &quot;\\\\(\\\\s*(.*?)\\\\s*%&quot;)[, 2]) for (i in 1:length(pca_var)) { # calculate normalized pca values norm_pca &lt;- df[, i] / 100 * pca_var[i] #repopulate the dataframe df[, i] &lt;- norm_pca } } #check best k for k-means clustering method if (return_elbow) { return(fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;) + labs(subtitle = &quot;Elbow method&quot;)) } # # # fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;)+ # labs(subtitle = &quot;Silhouette method&quot;) # # fviz_nbclust(df, kmeans, nstart = 25, method = &quot;gap_stat&quot;, nboot = 50)+ # labs(subtitle = &quot;Gap statistic method&quot;) # compute k-means clustering set.seed(1) res.km &lt;- kmeans(df, cluster_n, nstart = 1000) # change colnames so it works for our plot df12$class &lt;- str_extract(rownames(df12), &#39;KRA-0\\\\d+&#39;) num &lt;- str_extract(rownames(df), &#39;_\\\\d+\\\\.&#39;) num &lt;- str_remove_all(num, pattern = &#39;\\\\.&#39;) df12$label &lt;- paste0(df12$class, num) pc1 &lt;- colnames(df12)[1] pc2 &lt;- colnames(df12)[2] colnames(df12) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;, &#39;class&#39;, &#39;label&#39;) # plot nicely p &lt;- ggplot(data = df12, aes(label = label)) + geom_point(alpha = 1.0, aes( x = PC1, y = PC2, col = as.factor(res.km$cluster) )) + theme_cowplot() + labs(x = pc1, y = pc2) + scale_color_manual(labels = labels, values = cols, name = &quot;Clone&quot;) + theme(legend.position = legend_position, text = element_text(size = 17), axis.text = element_text(size = 15)) return(p) #ggplotly(p) } draw_pca_double &lt;- function(list_files1, list_files2, list_files3, size, legend_position) { cells &lt;- c(list_files1, list_files2, list_files3) df &lt;- plot_pca( cells, colorBy = classes, PC1 = 1, PC2 = 2, plot = F ) df$class &lt;- str_extract(rownames(df), &#39;KRA-0\\\\d+&#39;) num &lt;- str_extract(rownames(df), &#39;_\\\\d+\\\\.&#39;) num &lt;- str_remove_all(num, pattern = &#39;\\\\.&#39;) df$label &lt;- paste0(df$class, num) pc1 &lt;- colnames(df)[1] pc2 &lt;- colnames(df)[2] colnames(df) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;, &#39;class&#39;, &#39;label&#39;) p &lt;- ggplot(data = df, aes(label = label)) + geom_point(size = size, aes(x = PC1, y = PC2, col = class)) + # scale_color_manual(values = c(&quot;#FFDB6D&quot;, &quot;#00AFBB&quot;)) + scale_color_manual( name = &#39;&#39;, values = c(&quot;#999999&quot;, &quot;#D69C4E&quot;, &#39;#d65c4e&#39;), labels = c(&#39;Baseline&#39;, &#39;Recurrence Cycle 1&#39;, &#39;Recurrence Cycle 2&#39;) ) + # or consider &#39;#9e1303&#39; for second cycle of recurrence theme_cowplot() + theme(legend.position = legend_position, text = element_text(size = 17), axis.text = element_text(size = 15)) + labs(x = pc1, y = pc2) return(p) # ggplotly(p) } k_cluster_double &lt;- function(list_files1, list_files2, list_files3, cluster_n, cols, labels, legend_position, normalize, return_elbow = F) { require(factoextra) cells &lt;- c(list_files1, list_files2, list_files3) df12 &lt;- plot_pca( cells, colorBy = classes, PC1 = 1, PC2 = 2, plot = F ) df34 &lt;- plot_pca( cells, colorBy = classes, PC1 = 3, PC2 = 4, plot = F ) df56 &lt;- plot_pca( cells, colorBy = classes, PC1 = 5, PC2 = 6, plot = F ) df78 &lt;- plot_pca( cells, colorBy = classes, PC1 = 7, PC2 = 8, plot = F ) df910 &lt;- plot_pca( cells, colorBy = classes, PC1 = 9, PC2 = 10, plot = F ) df &lt;- cbind(df12, df34, df56, df78, df910) if (normalize) { # extract variance explained for each pca pca_var &lt;- as.numeric(str_match(colnames(df), &quot;\\\\(\\\\s*(.*?)\\\\s*%&quot;)[, 2]) for (i in 1:length(pca_var)) { # calculate normalized pca values norm_pca &lt;- df[, i] / 100 * pca_var[i] #repopulate the dataframe df[, i] &lt;- norm_pca } } #check best k for k-means clustering method if (return_elbow) { return(fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;) + labs(subtitle = &quot;Silhouette method&quot;)) } # # # fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;)+ # labs(subtitle = &quot;Silhouette method&quot;) # # fviz_nbclust(df, kmeans, nstart = 25, method = &quot;gap_stat&quot;, nboot = 50)+ # labs(subtitle = &quot;Gap statistic method&quot;) # compute k-means clustering set.seed(1) res.km &lt;- kmeans(df, cluster_n, nstart = 1000) # change colnames so it works for our plot df12$class &lt;- str_extract(rownames(df12), &#39;KRA-0\\\\d+&#39;) num &lt;- str_extract(rownames(df), &#39;_\\\\d+\\\\.&#39;) num &lt;- str_remove_all(num, pattern = &#39;\\\\.&#39;) df12$label &lt;- paste0(df12$class, num) pc1 &lt;- colnames(df12)[1] pc2 &lt;- colnames(df12)[2] colnames(df12) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;, &#39;class&#39;, &#39;label&#39;) # plot nicely p &lt;- ggplot(data = df12, aes(label = label)) + geom_point(alpha = 1.0, aes( x = PC1, y = PC2, col = as.factor(res.km$cluster) )) + theme_cowplot() + labs(x = pc1, y = pc2) + scale_color_manual(labels = labels, values = cols, name = &quot;Clone&quot;) + theme(legend.position = legend_position, text = element_text(size = 17), axis.text = element_text(size = 15)) p } } 6.7 divide_subclone_functions script: ‘extract_other_cells’, ‘extract_square’, ‘l_g’ and ‘subclone_classes_for_genomeheatmap’ functions extract_other_cells &lt;- function(kra_name, list_of_subclones) { i &lt;- which(names(man_select_files_edivisive) == kra_name) all &lt;- str_extract(man_select_files_edivisive[[i]], &#39;_\\\\d+\\\\.&#39;) %&gt;% str_remove(&#39;_&#39;) %&gt;% str_remove(&#39;\\\\.&#39;) rest &lt;- all[which(!all %in% list_of_subclones)] return(rest) } extract_square &lt;- function(list_files1, list_files2, square, x, y) { # extracts all cells that lie within a square of a pca plot defined by # user. For example square c(0.1, 0.0) will extract all cells with # pc1 lower or higher that 0.1 and pc2 lower or higher than 0.0. User has to rearange functon # if he wants x lower or higher than 0.1 cells &lt;- c(list_files1, list_files2) df12 &lt;- plot_pca(cells, colorBy = classes, PC1=1, PC2=2, plot = F) colnames(df12) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;) # extracting dataframe with correct square if(x == &#39;&lt;&#39; &amp; y == &#39;&lt;&#39;) { df12 &lt;- subset(df12, PC1 &lt; square[1] &amp; PC2 &lt; square[2]) } if(x == &#39;&lt;&#39; &amp; y == &#39;&gt;&#39;) { df12 &lt;- subset(df12, PC1 &lt; square[1] &amp; PC2 &gt; square[2]) } if(x == &#39;&gt;&#39; &amp; y == &#39;&lt;&#39;) { df12 &lt;- subset(df12, PC1 &gt; square[1] &amp; PC2 &lt; square[2]) } if(x == &#39;&gt;&#39; &amp; y == &#39;&gt;&#39;) { df12 &lt;- subset(df12, PC1 &gt; square[1] &amp; PC2 &gt; square[2]) } # numbers is: cell_id &lt;- str_extract(rownames(df12), &#39;_\\\\d+\\\\.&#39;) %&gt;% str_remove(&#39;_&#39;) %&gt;% str_remove(&#39;\\\\.&#39;) return(cell_id) } l_g &lt;- function(x, kra_num, list_cells) { select &lt;- grepl(paste0(kra_num,&#39;_&#39;,x,&quot;\\\\.&quot;), list_cells) i &lt;- which(select) return(list_cells[i]) } subclone_classes_for_genomeheatmap &lt;- function(list_of_subclones, cline) { #&#39; @param #&#39; list of subclones is the full list of rda files that have been assigned a subclone_classes_for_genomeheatmap #&#39; cline is the line (hub005, hub183 etc.) #&#39; rad is either prerad or rad #&#39; @return #&#39; returns a vector with that assigns a subclone extract_subclones &lt;- list_of_subclones[grepl(names(list_of_subclones), pattern = paste0(cline))] size_subclones &lt;- lapply(extract_subclones, length) classes &lt;- rep(names(size_subclones), size_subclones) df &lt;- data.frame(path = unlist(extract_subclones), class = classes) return(df) } 6.8 plot_genomeheatmap script: ‘genomeheatmap’ function genomeheatmap &lt;- function(selected.files, path, classes_daan = NULL, class.col = NULL, dendogram = F, daan_colours = T, name) { # This code was adapted from the AneuFinder package # plots and saves genome heatmap of selected.files # @param # selected.files: vector of location of selected files. # output path: path were plots should be saved. # name: how you want to name the plot # get platename platename &lt;- str_extract(selected.files[1], &#39;KRA-0\\\\d+&#39;) # AneuFinder functions: startTimedMessage &lt;- function(...) { x &lt;- paste0(..., collapse=&#39;&#39;) message(x, appendLF=FALSE) ptm &lt;- proc.time() return(ptm) } transCoord &lt;- function (gr) { cum.seqlengths &lt;- cumsum(as.numeric(seqlengths(gr))) cum.seqlengths.0 &lt;- c(0, cum.seqlengths[-length(cum.seqlengths)]) names(cum.seqlengths.0) &lt;- seqlevels(gr) gr$start.genome &lt;- start(gr) + cum.seqlengths.0[as.character(seqnames(gr))] gr$end.genome &lt;- end(gr) + cum.seqlengths.0[as.character(seqnames(gr))] return(gr) } stopTimedMessage &lt;- function(ptm) { time &lt;- proc.time() - ptm message(&quot; &quot;, round(time[3],2), &quot;s&quot;) } initializeStates &lt;- function (states) { somy.states &lt;- grep(&quot;somy&quot;, states, value = TRUE) somy.numbers &lt;- as.integer(sapply(strsplit(somy.states, &quot;-somy&quot;), &quot;[[&quot;, 1)) names(somy.numbers) &lt;- somy.states if (&quot;zero-inflation&quot; %in% states) { multiplicity &lt;- c(`zero-inflation` = 0, somy.numbers) } else { multiplicity &lt;- somy.numbers } levels.distributions &lt;- c(&quot;delta&quot;, &quot;dgeom&quot;, &quot;dnbinom&quot;, &quot;dbinom&quot;) distributions &lt;- rep(NA, length(states)) names(distributions) &lt;- states distributions[states == &quot;zero-inflation&quot;] &lt;- &quot;delta&quot; distributions[states == &quot;0-somy&quot;] &lt;- &quot;dgeom&quot; distributions[(states != &quot;zero-inflation&quot;) &amp; (states != &quot;0-somy&quot;)] &lt;- &quot;dnbinom&quot; states &lt;- factor(states, levels = states) distributions &lt;- factor(distributions, levels = levels.distributions) l &lt;- list(states = states, distributions = distributions, multiplicity = multiplicity) return(l) } # colours if (daan_colours) { stateColors &lt;- function(states = c(&quot;zero-inflation&quot;, paste0(0:10, &quot;-somy&quot;), &quot;total&quot;)) { state.colors &lt;- c(`zero-inflation` = &quot;#1d4661&quot;, `0-somy` = &quot;#1d4661&quot;, `1-somy` = &quot;#3787BA&quot;, `2-somy` = &quot;#95B8C5&quot;, `3-somy` = &quot;#F0ECEB&quot;, `4-somy` = &quot;#D7A290&quot;, `5-somy` = &quot;#BF583B&quot;, `6-somy` = &quot;#8D1128&quot;, `7-somy` = &quot;#3C0912&quot;, `8-somy` = &quot;black&quot;, total = &quot;black&quot;) states.with.color &lt;- intersect(states, names(state.colors)) cols &lt;- rep(&quot;black&quot;, length(states)) names(cols) &lt;- states cols[states.with.color] &lt;- state.colors[states.with.color] return(cols) } } # heatmapgenomewide adapted form AneuFinder package heatmapGenomewide_daan &lt;- function (hmms, ylabels = NULL, classes, reorder.by.class = TRUE, classes.color, file = NULL, cluster = TRUE, plot.breakpoints = FALSE, hotspots = NULL, exclude.regions = NULL) { if (!is.null(ylabels)) { if (length(ylabels) != length(hmms)) { stop(&quot;length(ylabels) must equal length(hmms)&quot;) } } if (!is.null(classes)) { if (length(classes) != length(hmms)) { stop(&quot;length(classes) must equal length(hmms)&quot;) } } if (length(classes.color) != length(unique(classes))) { stop(&quot;&#39;classes.color&#39; must have the same length as unique(classes)&quot;) } if (is.null(names(classes.color))) { names(classes.color) &lt;- unique(classes) } if (!setequal(names(classes.color), unique(classes))) { stop(&quot;The names of &#39;classes.color&#39; must be equal to the unique elements in &#39;classes&#39;&quot;) } if (length(hmms) == 1 &amp; cluster == TRUE) { cluster &lt;- FALSE warning(&quot;Cannot do clustering because only one object was given.&quot;) } hmms &lt;- loadFromFiles(hmms, check.class = c(&quot;aneuHMM&quot;, &quot;aneuBiHMM&quot;)) class.data &lt;- data.frame(ID = sapply(hmms, &quot;[[&quot;, &quot;ID&quot;)) class.data$ID &lt;- factor(class.data$ID, levels = class.data$ID) if (is.null(ylabels)) { class.data$ylabel &lt;- as.character(class.data$ID) } else { class.data$ylabel &lt;- as.character(ylabels) } class.data$class &lt;- classes mapping &lt;- class.data$ylabel names(mapping) &lt;- class.data$ID if (reorder.by.class) { cl &lt;- clusterHMMs(hmms, cluster = cluster, classes = classes, exclude.regions = exclude.regions) } else { cl &lt;- clusterHMMs(hmms, cluster = cluster, exclude.regions = exclude.regions) } hmms &lt;- hmms[cl$IDorder] class.data &lt;- class.data[cl$IDorder, ] class.data$ID &lt;- factor(class.data$ID, levels = class.data$ID) segments.list &lt;- GRangesList() for (i1 in 1:length(hmms)) { hmm &lt;- hmms[[i1]] if (is.null(hmm$segments)) { segments.list[[hmm$ID]] &lt;- GRanges() } else { segments.list[[hmm$ID]] &lt;- hmm$segments } } if (plot.breakpoints) { breakpoints &lt;- GRangesList() for (i1 in 1:length(hmms)) { hmm &lt;- hmms[[i1]] if (is.null(hmm$breakpoints)) { breakpoints[[hmm$ID]] &lt;- GRanges() } else { breakpoints[[hmm$ID]] &lt;- hmm$breakpoints } } if (length(breakpoints) == 0) { plot.breakpoints &lt;- FALSE } } ptm &lt;- startTimedMessage(&quot;Transforming coordinates ...&quot;) segments.list &lt;- endoapply(segments.list, transCoord) if (plot.breakpoints) { breakpoints &lt;- endoapply(breakpoints, transCoord) } stopTimedMessage(ptm) ptm &lt;- startTimedMessage(&quot;Making the plot ...&quot;) df &lt;- list() for (i1 in 1:length(segments.list)) { df[[length(df) + 1]] &lt;- data.frame(start = segments.list[[i1]]$start.genome, end = segments.list[[i1]]$end.genome, seqnames = seqnames(segments.list[[i1]]), ID = names(segments.list)[i1], state = segments.list[[i1]]$state) } df &lt;- do.call(rbind, df) df$ID &lt;- factor(df$ID, levels = levels(class.data$ID)) df$ylabel &lt;- mapping[as.character(df$ID)] if (plot.breakpoints) { df.breakpoints &lt;- list() for (i1 in 1:length(breakpoints)) { if (length(breakpoints[[i1]]) &gt; 0) { df.breakpoints[[length(df.breakpoints) + 1]] &lt;- data.frame(start = breakpoints[[i1]]$start.genome, end = breakpoints[[i1]]$end.genome, seqnames = seqnames(breakpoints[[i1]]), ID = names(segments.list)[i1], mid = (breakpoints[[i1]]$start.genome + breakpoints[[i1]]$end.genome)/2) } else { df.breakpoints[[length(df.breakpoints) + 1]] &lt;- data.frame(start = numeric(), end = numeric(), seqnames = character(), ID = character(), mid = numeric()) } } df.breakpoints &lt;- do.call(rbind, df.breakpoints) df.breakpoints$ID &lt;- factor(df.breakpoints$ID, levels = levels(class.data$ID)) df.breakpoints$ylabel &lt;- mapping[as.character(df.breakpoints$ID)] } cum.seqlengths &lt;- cumsum(as.numeric(seqlengths(segments.list[[1]]))) names(cum.seqlengths) &lt;- seqlevels(segments.list[[1]]) cum.seqlengths.0 &lt;- c(0, cum.seqlengths[-length(cum.seqlengths)]) names(cum.seqlengths.0) &lt;- seqlevels(segments.list[[1]]) label.pos &lt;- round(cum.seqlengths.0 + 0.5 * seqlengths(segments.list[[1]])) df.chroms &lt;- data.frame(y = c(0, cum.seqlengths), x = 1, xend = length(segments.list)) pltlist &lt;- list() widths &lt;- vector() df$state &lt;- factor(df$state, levels = names(sort(initializeStates(levels(df$state))$multiplicity))) df$x &lt;- as.numeric(df$ID) ggplt &lt;- ggplot(df) + geom_linerange(aes_string(ymin = &quot;start&quot;, ymax = &quot;end&quot;, x = &quot;x&quot;, col = &quot;state&quot;), size = 5) + scale_y_continuous(breaks = label.pos, labels = names(label.pos)) # ggplt &lt;- ggplt + scale_x_continuous(name = &quot;&quot;, # breaks = 1:length(unique(df$ylabel)), # labels = unique(df$ylabel)) ggplt &lt;- ggplt + scale_color_manual(values = stateColors(levels(df$state))) # adding custom colours # adjusintg x axis ggplt &lt;- ggplt + theme(panel.background = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank(), axis.line = element_blank(), axis.title.x = element_blank()) ggplt &lt;- ggplt + geom_segment(aes_string(x = &quot;x&quot;, xend = &quot;xend&quot;, y = &quot;y&quot;, yend = &quot;y&quot;), data = df.chroms, col = &quot;grey13&quot;) # adjusting y axis ggplt &lt;- ggplt + theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.line = element_blank(), axis.title.x = element_blank()) # removing legend ggplt &lt;- ggplt + theme(legend.position=&quot;none&quot;) ggplt &lt;- ggplt + coord_flip() # removing all axis names ggplt &lt;- ggplt + ylab(&quot;&quot;) + xlab(&quot;&quot;) # add numeber of cells sequenced text ggplt &lt;- ggplt + annotate(&quot;text&quot;, label = paste(length(hmms), &#39;cells&#39;), x = length(hmms)/2, y = 3100000000, angle = 270, size = 50) # decreasing plot margin ggplt &lt;- ggplt + theme(plot.margin = unit(c(0,0,0,0), &quot;cm&quot;)) if (plot.breakpoints) { df.breakpoints$x &lt;- as.numeric(df.breakpoints$ID) ggplt &lt;- ggplt + geom_linerange(data = df.breakpoints, mapping = aes_string(x = &quot;x&quot;, ymin = &quot;start&quot;, ymax = &quot;end&quot;), size = 2) + ylab(&quot;&quot;) + geom_point(data = df.breakpoints, mapping = aes_string(x = &quot;x&quot;, y = &quot;mid&quot;)) } if (!is.null(hotspots)) { if (length(hotspots) &gt; 0) { df.hot &lt;- as.data.frame(transCoord(hotspots)) df.hot$xmin &lt;- 0 df.hot$xmax &lt;- length(class.data$ID) + 1 ggplt &lt;- ggplt + geom_rect(data = df.hot, mapping = aes_string(xmin = &quot;xmin&quot;, xmax = &quot;xmax&quot;, ymin = &quot;start.genome&quot;, ymax = &quot;end.genome&quot;, alpha = &quot;num.events&quot;), fill = &quot;hotpink4&quot;) + scale_alpha_continuous(name = &quot;breakpoints&quot;, range = c(0.4, 0.8)) } } width.heatmap &lt;- sum(as.numeric(seqlengths(hmms[[1]]$bins)))/3e+09 * 150 height &lt;- max(length(hmms) * 0.5, 2) pltlist[[&quot;heatmap&quot;]] &lt;- ggplt widths[&quot;heatmap&quot;] &lt;- width.heatmap # adding class colors if (!is.null(classes)) { width.classes &lt;- 5 class.data$x &lt;- as.numeric(class.data$ID) ggclass &lt;- ggplot(class.data) + geom_linerange(aes_string(ymin = 0, ymax = 1, x = &quot;x&quot;, col = &quot;class&quot;), size = 5) + guides(col = FALSE) + xlab(&quot;&quot;) ggclass &lt;- ggclass + theme(panel.background = element_blank(), axis.ticks = element_blank(), axis.text = element_blank(), axis.line = element_blank(), axis.title.x = element_blank()) ggclass &lt;- ggclass + coord_flip() # decreasing plot margin ggclass &lt;- ggclass + theme(plot.margin = unit(c(0,0,0,0), &quot;cm&quot;)) if (!is.null(classes.color)) { ggclass &lt;- ggclass + scale_color_manual(breaks = names(classes.color), values = classes.color) } pltlist[[&quot;classbar&quot;]] &lt;- ggclass widths[&quot;classbar&quot;] &lt;- width.classes } # adding dendogram if (!is.null(cl$hclust) &amp; dendogram) { dhc &lt;- stats::as.dendrogram(cl$hclust) ddata &lt;- ggdendro::dendro_data(dhc, type = &quot;rectangle&quot;) ggdndr &lt;- ggplot(ddata$segments) + geom_segment(aes_string(x = &quot;x&quot;, xend = &quot;xend&quot;, y = &quot;y&quot;, yend = &quot;yend&quot;)) + scale_y_reverse() ggdndr &lt;- ggdndr + coord_flip() ggdndr &lt;- ggdndr + theme(panel.background = element_blank(), axis.ticks = element_blank(), axis.text = element_blank(), axis.line = element_blank(), axis.title = element_blank()) width.dendro &lt;- 20 pltlist[[&quot;dendro&quot;]] &lt;- ggdndr widths[&quot;dendro&quot;] &lt;- width.dendro } # alligning ggpllt with dendogram and classes cowplt &lt;- cowplot::plot_grid(plotlist = rev(pltlist), align = &quot;h&quot;, ncol = length(pltlist), rel_widths = rev(widths)) stopTimedMessage(ptm) if (!is.null(file)) { ptm &lt;- startTimedMessage(&quot;Plotting to file &quot;, file, &quot; ...&quot;) ggsave(file, cowplt, width = sum(widths), height = height, units = &quot;cm&quot;, limitsize = FALSE) stopTimedMessage(ptm) } else { return(cowplt) } } #make heatmap and safe suppressWarnings(heatmapGenomewide_daan(selected.files, classes = classes_daan, classes.color = class.col, file = paste0(path, &#39;/&#39;, name, &#39;_&#39;, platename, &#39;.pdf&#39;))) return(print(paste0(name, &#39; done.&#39;))) } 6.9 fisher_test script: ‘perform_fisher’ function perform_fisher &lt;- function(dataframe, population1, population2) { #&#39; @param #&#39; dataframe is a df with columns paths and class with values &#39;hub015_rad_a&#39;, &#39;hub015_prerad_a&#39; etc. #&#39; population 1 and population two are the two pops you want to compare, for example prerad vs rad #&#39; or prerad versus rad cycle 2 #&#39; @return #&#39; returns the p value of a Fisher&#39;s exact test. If the p value is above 0.05, the distributions #&#39; pre and post rad are the same. #&#39; dataframe$rad &lt;- ifelse(dataframe$class %in% population1, &#39;pop1&#39;, ifelse(dataframe$class %in% population2, &#39;pop2&#39;, NA)) org_id &lt;- unique(str_extract(unique(dataframe$class), &#39;hub\\\\d{3}&#39;)) # remove na dataframe &lt;- dataframe[which(!is.na(dataframe$rad)),] simple_fun &lt;- function(string) { return(tail(string,1)) } dataframe$clone &lt;- unlist(lapply(stringr::str_split(dataframe$class, pattern = &#39;_&#39;), simple_fun)) # in hub015 and hub005, we defined subclones. These are actually part of the same clone, so should be # analysed together if (org_id %in% c(&#39;hub005&#39;, &#39;hub015&#39;)){ dataframe$clone &lt;- str_replace_all(dataframe$clone, pattern = &#39;a.a|a.b&#39;, replacement = &#39;a&#39;) } tab &lt;- table(dataframe$clone, dataframe$rad) # df &lt;- data.frame(cline &lt;- org_id, p_val &lt;- fisher.test(tab)$p.value) # # return(df) return(fisher.test(tab)$p.value) } 6.10 find_specific_cna_sc script: ‘find_specific_cna_sc’ function find_specific_cna_sc &lt;- function(list_resistant, list_sensitive, perc_cutoff_within_subclone_resistant, perc_cutoff_within_subclone_sensitive, per_cutoff_across_subclone_resistant, per_cutoff_across_subclone_sensitive, return_cnas_per_subclone = F) { #&#39; @param list_resistant a list subclone names which itself contains a list of paths of paths to aneuHMM .Rda files. #&#39; @param list_sensitive a list subclone names which itself contains a list of paths of paths to aneuHMM .Rda files. #&#39; @param perc_cutoff_within_subclone_resistant user defined percentage cutoff to use (e.g. 0.6 means a certain CNA is shared by 60% of the cells #&#39; within a subclone). #&#39; @param perc_cutoff_within_subclone_senstive same as in perc_cutoff_within_subclone_resistant but for the sensitive group #&#39; @param per_cutoff_across_subclone_resistant user defined percentage cutoff to use (e.g. 0.7 means a certain CNA is shared in 70% of all subclones) #&#39; @param return_cnas_per_subclone boolean. If TRUE will return the shared by perc_cutoff_within_subclone CNAs for each list of each item within #&#39; list_resistant. Note list_sensitive should be set to NULL for proper results!! #&#39; @param per_cutoff_across_subclone_sensitive same as resistant but for the sensitive group #&#39; @example perc_cutoff_within_subclone = 0.6 and per_cutoff_across_subclone = 0.7 means the algorithm will find CNAs that are shared #&#39; by 60% of single cells within each subclone, and by 70% of all subclones. Important, a cutoff of 50% is the same as computing the median. #&#39; @return a list of GRanges showing unique to list_resistant amplifications and deletions and unique to list_sensitive #&#39; amplifications and deletions or, if return_cnas_per_subclone see param return_cnas_per_subclone above. #&#39; @details Note that this algorithm is NOT sensitive to the number of single cells within each subclone. ############# # Libraries # ############# require(plyranges) require(AneuFinder) ########### # Part 1. # ########### print(&#39;Computing (this may take some minutes)...&#39;) resistant_sc &lt;- lapply(list_resistant, loadFromFiles, check.class = c(&quot;aneuHMM&quot;, &quot;aneuBiHMM&quot;)) sensitive_sc &lt;- lapply(list_sensitive, loadFromFiles, check.class = c(&quot;aneuHMM&quot;, &quot;aneuBiHMM&quot;)) # find specific CNAs needs a list of GRanges where each GRange has columns # seqnames, ranges, strand (not necessary) and cn. wrangle_sc &lt;- function(list_lff) { # segments is the reduced bins GRange (so all equal CN bins put together) wrangle_within &lt;- function(list_lff_within) { segments &lt;- list_lff_within$segments # ugly way of adding a cn column segments$cn &lt;- segments$copy.number return(segments) # END of wrange_within function } within_subcl &lt;- lapply(list_lff, wrangle_within) # END OF wrangle_sc function } list_resistant &lt;- lapply(resistant_sc, wrangle_sc) list_sensitive &lt;- lapply(sensitive_sc, wrangle_sc) print(&#39;Extracted segment info from files&#39;) Sys.sleep(1) ########### # Part 2. # ########### # The Granges are now still arranged in bins. We are first going to # combine bins with similar copy number. print(&#39;Computing (this may take some minutes)...&#39;) combine_indels &lt;- function(subclone_consensus) { #&#39; @param subclone_consensus_list is a GRanges with seqnames, ranges, strand and cn #&#39; @returns list of Granges where each Granges has only CNA of cn2 or cn&gt;2 combine_within &lt;- function(subclone_consensus_within) { # subset subclone_consensus in cn &lt;2, cn = 2 and cn &gt; 2 cn_less_2 &lt;- subclone_consensus_within[subclone_consensus_within$cn &lt; 2,] cn_more_2 &lt;- subclone_consensus_within[subclone_consensus_within$cn &gt; 2,] # reduce each GRanges (joins consecutive ranges together) cn_less_2 &lt;- reduce(cn_less_2) cn_more_2 &lt;- reduce(cn_more_2) # reduce deletes metadata. # adding metadata cn_less_2$cn &lt;- rep(&#39;&lt;2&#39;, length(cn_less_2)) cn_more_2$cn &lt;- rep(&#39;&lt;2&#39;, length(cn_more_2)) # make list and rename items GR_list &lt;- GRangesList(cn_less_2, cn_more_2) names(GR_list) &lt;- c(&#39;&lt;2&#39;, &#39;&gt;2&#39;) # Return # return(GR_list) } combine_subcl &lt;- lapply(subclone_consensus, combine_within) } # run an apply function here on each Granges in list_resistant versus list_sensitive resistant_split &lt;- lapply(list_resistant, combine_indels) sensitive_split &lt;- lapply(list_sensitive, combine_indels) # splits deletions together within each subclone grouper_del &lt;- function(gr) { grouper_within &lt;- function(gr_within) { return(gr_within$&#39;&lt;2&#39;) } within_grouper &lt;- lapply(gr, grouper_within) } # splits amplifciations together within each subclone grouper_ampl &lt;- function(gr) { grouper_within &lt;- function(gr_within) { return(gr_within$&#39;&gt;2&#39;) } within_grouper &lt;- lapply(gr, grouper_within) } # run apply on each subclone resistant_split_del &lt;- lapply(resistant_split, grouper_del) resistant_split_ampl &lt;- lapply(resistant_split, grouper_ampl) sensitive_split_del &lt;- lapply(sensitive_split, grouper_del) sensitive_split_ampl &lt;- lapply(sensitive_split, grouper_ampl) ########### # Part 3. # ########### # Part 3A # ########### # Finding common CNAs within each subclone shared_cnas &lt;- function(list_GRanges, perc_cutoff_within_subclone) { #&#39; @param list_GRanges is a list of GRanges with seqnames, ranges, strand and cn #&#39; @param perc_cutoff_within_subclone user defined percentage cutoff to use (e.g. 0.6) #&#39; @returns Granges where each Granges is shared by =&gt; perc_cutoff_within_subclone # finding overlaps in x% of regions: wait for response community: # https://stackoverflow.com/questions/74900085/find-ranges-that-are-shared-by-80-or-more-of-10-granges-objects # https://support.bioconductor.org/p/9148540/ shared_cnas_within &lt;- function(list_GRanges_within) { n &lt;- length(list_GRanges_within) # number of range sets shared_cna &lt;- bind_ranges(list_GRanges_within, .id = &quot;origin&quot;) %&gt;% compute_coverage() %&gt;% mutate(fraction_cov = score / n) %&gt;% filter(fraction_cov &gt;= perc_cutoff_within_subclone) %&gt;% reduce_ranges() return(shared_cna) } lapply(list_GRanges, shared_cnas_within) } resistant_shared_del &lt;- shared_cnas(resistant_split_del, perc_cutoff_within_subclone = perc_cutoff_within_subclone_resistant) resistant_shared_ampl &lt;- shared_cnas(resistant_split_ampl, perc_cutoff_within_subclone = perc_cutoff_within_subclone_resistant) sensitive_shared_del &lt;- shared_cnas(sensitive_split_del, perc_cutoff_within_subclone = perc_cutoff_within_subclone_sensitive) sensitive_shared_ampl &lt;- shared_cnas(sensitive_split_ampl, perc_cutoff_within_subclone = perc_cutoff_within_subclone_sensitive) # END of function if return_cnas_per_subclone == T if (return_cnas_per_subclone == T) { cna_list &lt;- list (deletions = c(resistant_shared_del, sensitive_shared_del), amplifications = c(resistant_shared_ampl, sensitive_shared_del)) print( paste0( &#39;Extracted CNAs that are shared by &#39;, as.numeric(perc_cutoff_within_subclone_resistant) * 100, &#39;% of single cells within each resistant subclone, and by &#39;, as.numeric(perc_cutoff_within_subclone_sensitive) * 100, &#39;% of single cells within each sensitive subclone&#39; ) ) ########## # Unload # ########## suppressWarnings(invisible(lapply(paste0(&quot;package:&quot;, names(sessionInfo()$otherPkgs)), # Unload add-on packages detach, character.only = TRUE, unload = TRUE))) return(cna_list) } # Part 3B # ########### # Finding common CNAs across subclones shared_cnas_across_subclones &lt;- function(list_GRanges, per_cutoff_across_subclone) { #&#39; @param list_GRanges is a list of GRanges with seqnames, ranges, strand and cn #&#39; @param perc_cutoff user defined percentage cutoff to use (e.g. 0.6) #&#39; @returns Granges where each Granges is shared by =&gt; perc_cutoff_within_subclone # finding overlaps in x% of regions: wait for response community: # https://stackoverflow.com/questions/74900085/find-ranges-that-are-shared-by-80-or-more-of-10-granges-objects # https://support.bioconductor.org/p/9148540/ n &lt;- length(list_GRanges) # number of range sets shared_cna &lt;- bind_ranges(list_GRanges, .id = &quot;origin&quot;) %&gt;% compute_coverage() %&gt;% mutate(fraction_cov = score / n) %&gt;% filter(fraction_cov &gt;= per_cutoff_across_subclone) %&gt;% reduce_ranges() return(shared_cna) } resistant_shared_del_across &lt;- shared_cnas_across_subclones(resistant_shared_del, per_cutoff_across_subclone = per_cutoff_across_subclone_resistant) resistant_shared_ampl_across &lt;- shared_cnas_across_subclones(resistant_shared_ampl, per_cutoff_across_subclone = per_cutoff_across_subclone_resistant) sensitive_shared_del_across &lt;- shared_cnas_across_subclones(sensitive_shared_del, per_cutoff_across_subclone = per_cutoff_across_subclone_sensitive) sensitive_shared_ampl_across &lt;- shared_cnas_across_subclones(sensitive_shared_ampl, per_cutoff_across_subclone = per_cutoff_across_subclone_sensitive) print( paste0( &#39;Extracted CNAs that are shared by &#39;, as.numeric(perc_cutoff_within_subclone_resistant) * 100, &#39; and &#39;, as.numeric(perc_cutoff_within_subclone_sensitive) * 100, &#39;% of single cells within resistant and sensitive subclones, respectively, and that are shared by &#39;, as.numeric(per_cutoff_across_subclone_resistant) * 100, &#39; and &#39;, as.numeric(per_cutoff_across_subclone_sensitive) * 100, &#39;% across resistant and sensitive subclones, respectively.&#39; ) ) Sys.sleep(1) print(&#39;Computing (few seconds)...&#39;) Sys.sleep(2) ########### # Part 4. # ########### # Now that we have shared CNAs across subclones with the resistant and sensitive group, we need to extract # only those CNAs that are unique to the resistant group. # unique to resistant lines deletions: unique_resistant_del &lt;- setdiff(resistant_shared_del_across, sensitive_shared_del_across) # unique to resistant lines amplifications unique_resistant_ampl &lt;- setdiff(resistant_shared_ampl_across, sensitive_shared_ampl_across) # unique to sensitive lines deletions: unique_sensitive_del &lt;- setdiff(sensitive_shared_del_across, resistant_shared_del_across) # unique to sensitive lines amplifications: unique_sensitive_ampl &lt;- setdiff(sensitive_shared_ampl_across, resistant_shared_ampl_across) print( &#39;Identified amplifications and deletions that are unique to resistant or sensitive subclones&#39; ) ########## # Return # ########## returner &lt;- list( unique_resistant_del, unique_resistant_ampl, unique_sensitive_del, unique_sensitive_ampl ) names(returner) &lt;- c( &#39;unique_resistant_del&#39;, &#39;unique_resistant_ampl&#39;, &#39;unique_sensitive_del&#39;, &#39;unique_sensitive_ampl&#39; ) ########## # Unload # ########## suppressWarnings(invisible(lapply(paste0(&quot;package:&quot;, names(sessionInfo()$otherPkgs)), # Unload add-on packages detach, character.only = TRUE, unload = TRUE))) return(returner) } 6.11 get_cytoband_coverage script: ‘get_cytoband_coverage’ function get_cytoband_coverage &lt;- function(Grange) { #&#39; @param Grange a grange with seqnames and granges. #&#39; @returns returns a GRange with cytogenetic locations including #&#39; percentage of overlap and a dataframe containing information on how much of #&#39; the total arm was affected. ############# # Libraries # ############# require(tidyverse) require(plyranges) ######## # Data # ######## # Uncomment me, this is to download cytogenetic coordinates # library(biovizBase) # hg38IdeogramCyto &lt;- getIdeogram(&quot;hg38&quot;, cytobands = TRUE) # save(hg38IdeogramCyto, file = &#39;rda/cna_analysis/hg38IdeogramCyto.rda&#39;) # !!! ADDING ../cna_analysis for publication in GitHub !!! load(&#39;../cna_analysis/rda/cna_analysis/hg38IdeogramCyto.rda&#39;) ########### # Wrangle # ########### # Convert both GRanges to similar karyogram style seqlevelsStyle(Grange) &lt;- &quot;NCBI&quot; seqlevelsStyle(hg38IdeogramCyto) &lt;- &quot;NCBI&quot; Grange_list_cytoband &lt;- list() Grange_list_pq_affected &lt;- list() # return empty Grange and empty data.frame if Grange is empty if (length(Grange) == 0) { # return empty Grange return(list(GRanges( seqnames = character(0), IRanges(start = integer(0), end = integer(0)), cytobands_cov = character(0) ), data.frame(seqnames = character(), start_of_arm = numeric(), end_of_arm = numeric(), width_of_arm = numeric(), strand = character(), chromosome = character(), arm = character(), percentage_arm_affected = numeric(), stringsAsFactors = FALSE) )) } for (row in 1:length(Grange)) { for_range &lt;- Grange[row] ########## # Part 1 # ########## ## First find specific cytoband locations # finding overlaps hits &lt;- findOverlaps(for_range, hg38IdeogramCyto) # computing percentage overlap overlaps &lt;- pintersect(for_range[queryHits(hits)], hg38IdeogramCyto[subjectHits(hits)]) percentOverlap &lt;- width(overlaps) / width(hg38IdeogramCyto[subjectHits(hits)]) # extracting cytobands cytobands &lt;- paste0(seqnames(hg38IdeogramCyto[subjectHits(hits)]), hg38IdeogramCyto[subjectHits(hits)]$name) # replace &#39;chr&#39; cytobands &lt;- str_replace(cytobands, pattern = &#39;chr&#39;, replacement = &#39;&#39;) cytobands_cov &lt;- list(paste0(cytobands, &#39;;&#39;, round(percentOverlap, 2) * 100, &#39;%&#39;)) for_range$cytobands_cov &lt;- cytobands_cov Grange_list_cytoband[[row]] &lt;- for_range ########## # Part 2 # ########## # make dataframe that shows how much of an arm is affected # Grange with p and q IRanges p_q &lt;- hg38IdeogramCyto p_q$arm &lt;- str_extract(p_q$name, &#39;p|q&#39;) p_q &lt;- subset(p_q, seqnames %in% c(seq(1:22), &#39;X&#39;, &#39;Y&#39;)) p_q &lt;- p_q %&gt;% group_by(seqnames, arm) %&gt;% reduce_ranges() # finding overlaps hits_pq &lt;- findOverlaps(for_range, p_q) # computing percentage overlap overlaps &lt;- pintersect(for_range[queryHits(hits_pq)], p_q[subjectHits(hits_pq)]) percentOverlap &lt;- width(overlaps) / width(p_q[subjectHits(hits_pq)]) p_q_percentage &lt;- as.data.frame(p_q[subjectHits(hits_pq)]) p_q_percentage$percentage_arm_affected &lt;- percentOverlap * 100 colnames(p_q_percentage) &lt;- c( &#39;seqnames&#39;, &#39;start_of_arm&#39;, &#39;end_of_arm&#39;, &#39;width_of_arm&#39;, &#39;strand&#39;, &#39;chromosome&#39;, &#39;arm&#39;, &#39;percentage_arm_affected&#39; ) Grange_list_pq_affected[[row]] &lt;- p_q_percentage } Grange &lt;- bind_ranges(Grange_list_cytoband) pq_arm_affect &lt;- bind_rows(Grange_list_pq_affected) return(list(Grange, pq_arm_affect)) ### END of function ### } 6.12 get_genes script: ‘get_genes’ functoin get_genes &lt;- function(GRange) { #&#39; @param Grange a grange with seqnames and granges. #&#39; @returns returns df with all genes encoded within the GRange regions. require(GenomicRanges) require(biomaRt) # This code should be run only once and is therefore commented. # code from: https://www.biostars.org/p/311199/ # Set up an gene annotation template to use # mart &lt;- useMart(biomart=&quot;ensembl&quot;, dataset=&quot;hsapiens_gene_ensembl&quot;) # mart &lt;- useMart(biomart=&quot;ENSEMBL_MART_ENSEMBL&quot;, host=&quot;www.ensembl.org&quot;, path=&quot;/biomart/martservice&quot;, dataset=&quot;hsapiens_gene_ensembl&quot;) # genes &lt;- getBM(attributes=c(&quot;hgnc_symbol&quot;,&quot;chromosome_name&quot;,&quot;start_position&quot;,&quot;end_position&quot;), mart=mart) # genes &lt;- genes[genes[,1]!=&quot;&quot; &amp; genes[,2] %in% c(1:22,&quot;X&quot;,&quot;Y&quot;),] # xidx &lt;- which(genes[,2]==&quot;X&quot;) # yidx &lt;- which(genes[,2]==&quot;Y&quot;) # genes[xidx, 2] &lt;- 23 # genes[yidx, 2] &lt;- 24 # genes[,2] &lt;- sapply(genes[,2],as.integer) # genes &lt;- genes[order(genes[,3]),] # genes &lt;- genes[order(genes[,2]),] # save(genes, file = &#39;rda/cna_analysis/genes.rda&#39;) # colnames(genes) &lt;- c(&quot;GeneSymbol&quot;,&quot;Chr&quot;,&quot;Start&quot;,&quot;End&quot;) # genes_GR &lt;- makeGRangesFromDataFrame(genes,keep.extra.columns = TRUE) # save(genes_GR, file = &#39;rda/cna_analysis/genes_GR.rda&#39;) # loading genelist and genomic location load(&quot;../cna_analysis/rda/cna_analysis/genes_GR.rda&quot;, envir = .GlobalEnv) load(&#39;../cna_analysis/rda/cna_analysis/genes.rda&#39;, envir = .GlobalEnv ) # Convert both GRanges to similar karyogram style seqlevelsStyle(GRange) &lt;- &quot;UCSC&quot; GRange &lt;- renameSeqlevels(GRange, paste0(&#39;chr&#39;, c(1:23))) seqlevelsStyle(genes_GR) &lt;- &quot;UCSC&quot; # Finding hits with genes_GR and GRanges hits &lt;- findOverlaps(genes_GR, GRange, type=&quot;within&quot;) # constructing df &lt;- cbind(as.data.frame(GRange)[subjectHits(hits),],genes[queryHits(hits),]) return(df) } 6.13 get_oncogenes scripts: ‘get_oncogenes’ function get_oncogenes &lt;- function(GRange) { #&#39; @param Grange a grange with seqnames and granges. #&#39; @returns returns df with all genes encoded within the GRange regions. source(&#39;R/get_genes.R&#39;) # first finding all genes within GRange all_genes &lt;- get_genes(GRange) # change colnames so dataframes match colnames(all_genes)[which(names(all_genes) == &#39;hgnc_symbol&#39;)] &lt;- &quot;Gene Symbol&quot; # downloading oncogenes require(readr) oncogenes &lt;- read_csv(&quot;../cna_analysis/data/cna_analysis/Census_allMon May 30 12_43_01 2022.csv&quot;) # subset df_genes so to only have oncogenes require(tidyverse) oncogenes &lt;- inner_join(oncogenes, all_genes) return(oncogenes) } 6.14 plot_genes_karyotype script: ‘plot_genes_karyotype’ function plot_genes_karyotype &lt;- function(GRange, dist = -30, show_genes, show_chromosomes = c( &quot;chr1&quot;, &quot;chr2&quot;, &quot;chr3&quot;, &quot;chr4&quot;, &quot;chr5&quot;, &quot;chr6&quot;, &quot;chr7&quot;, &quot;chr8&quot;, &quot;chr9&quot;, &quot;chr10&quot;, &quot;chr11&quot;, &quot;chr12&quot;, &quot;chr13&quot;, &quot;chr14&quot;, &quot;chr15&quot;, &quot;chr16&quot;, &quot;chr17&quot;, &quot;chr18&quot;, &quot;chr19&quot;, &quot;chr20&quot;, &quot;chr21&quot;, &quot;chr22&quot;, &quot;chrX&quot; )) { #&#39; @param GRange a GRange with seqnames, ranges, strand and hgnc_symbol #&#39; @param dist How far away the genes should be plotted from the lines. #&#39; Between -40 and -70 seems to do the trick most of the times. #&#39; @param show_genes is a vector of gene symbols to show. #&#39; @param show_chromosomes is a vector indicating which chromosomes to show. #&#39; @return a karyotype with genes labeled #&#39; @details. Throws an error when the GRange does not contain either #&#39; ampflications or deletions. This can be ignored, the resulting plot #&#39; is correct ############# # Libraries # ############# require(karyoploteR) require(stringr) ########### # Wrangle # ########### # making sure seqlevels match seqlevelsStyle(GRange) &lt;- &#39;UCSC&#39; kp &lt;- plotKaryotype( &quot;hg38&quot;, plot.type = 5, labels.plotter = NULL, main = &quot;&quot;, cex = 4, chromosomes = show_chromosomes ) #renaming seqlevels seqlevels_grange_change &lt;- str_replace_all(seqlevels(GRange), pattern = &#39;chr23&#39;, replacement = &#39;chrX&#39;) GRange &lt;- renameSeqlevels(GRange, value = seqlevels_grange_change) kpAddChromosomeNames( kp, chr.names = str_remove_all(show_chromosomes, &#39;chr&#39;), cex = 1.3 ) # split into amplifications and deletions ampl &lt;- GRange[GRange$cn == &#39;amplified&#39;] ampl &lt;- ampl[ampl$hgnc_symbol %in% show_genes] del &lt;- GRange[GRange$cn == &#39;deleted&#39;] del &lt;- del[del$hgnc_symbol %in% show_genes] tryCatch( cor &lt;- cor.test(df$AUC, df$dependency, use = &quot;complete.obs&quot;), error = function(e) NULL ) tryCatch( kpPlotMarkers( kp, data = ampl, labels = ampl$hgnc_symbol, ignore.chromosome.ends = T, r0 = 1, r1 = 0.85, label.dist = 0.003, label.margin = dist, marker.parts = c(0.3, 0.1, 0.1), line.color = &#39;firebrick&#39;, label.color = &#39;firebrick&#39; ), error = function(e) NULL ) tryCatch( kpPlotMarkers( kp, data = del, labels = del$hgnc_symbol, ignore.chromosome.ends = T, r0 = 1, r1 = 0.4, label.dist = 0.003, cex = 8, label.margin = dist, marker.parts = c(0.3, 0.1, 0.1), line.color = &#39;steelblue&#39;, label.color = &#39;steelblue&#39; ), error = function(e) NULL ) } 6.15 shifters script: ‘create_cn_matrix’ and ‘cluster_and_shift_transitions’ functions For the ‘create_cn_matrix’ and ‘cluster_and_shift_transitions’ functions, please submit a code sharing request to the corresponding author of this paper: Bolhaqueiro, A.C.F., Ponsioen, B., Bakker, B. et al. Ongoing chromosomal instability and karyotype evolution in human colorectal cancer organoids. Nat Genet 51, 824–834 (2019). https://doi-org.proxy.library.uu.nl/10.1038/s41588-019-0399-6 6.16 calculate_heterogeneity_score script: ‘calculate_heterogeneity_score’ function For the ‘calculate_heterogeneity_score’ function, please submit a code sharing request to the corresponding author of this paper: Bolhaqueiro, A.C.F., Ponsioen, B., Bakker, B. et al. Ongoing chromosomal instability and karyotype evolution in human colorectal cancer organoids. Nat Genet 51, 824–834 (2019). https://doi-org.proxy.library.uu.nl/10.1038/s41588-019-0399-6 6.17 cna_profiler script: ‘cna_profiler’ function cna_profiler &lt;- function(df) { #&#39; @param df is a datafame containing all the copy number calls of all the files. #&#39; Columns: 01) seqnames #&#39; 02) start #&#39; 03) end #&#39; 04) width #&#39; 05) strand #&#39; 06) [copy.number cell 1] #&#39; 07) [copy.number cell 2], etc. #&#39; @return Outputs a dataframe that states the ratio (normalized to total cells) of #&#39; small, medium, large and whole chromosome CNAs require(tidyverse) require(GWASTools) # defining some parameters # number of cells n_cells &lt;- ncol(df) - 5 # extract centromere positions data(centromeres.hg38) centromeres.hg38 &lt;- subset(centromeres.hg38, chrom != &#39;Y&#39;) names(centromeres.hg38) &lt;- c(&#39;seqnames&#39;, &#39;start&#39;, &#39;end&#39;) # extract total length chromosomes total_length &lt;- df %&gt;% group_by(seqnames) %&gt;% summarize(sum(width)) # construct dataframe containing chromosome name, centromere position (start and end) and total length chromosome chrom_centro_total &lt;- inner_join(total_length, centromeres.hg38) # compute arm lengths chrom_centro_total$p_arm &lt;- chrom_centro_total$start + (chrom_centro_total$end-chrom_centro_total$start) chrom_centro_total$q_arm &lt;- chrom_centro_total$`sum(width)` - chrom_centro_total$p_arm ##### !!!!!!!! ###### # Check if this is still correct when using new assemblies ! # now all p_arms except for chromosome 1 are correct (for some reason the p-arm is the larger arm here). # I am going to swithc it. p_arm_1 &lt;- chrom_centro_total$q_arm[1] q_arm_1 &lt;- chrom_centro_total$p_arm[1] chrom_centro_total[1,5] &lt;- p_arm_1 chrom_centro_total[1,6] &lt;- q_arm_1 # function to extract CNA for each chromosome, run this function for each chromosome cna_extract &lt;- function(chromosome) { # @parama: chromosome is the chromosome (i.e., 1, 2,3, X, etc) df_chrom &lt;- subset(df, seqnames == chromosome) # run this function for each column in df_chrom cna_extract_cell &lt;- function(column_i) { # @ param column i is the integer of the column in df_chrom # from which to extract CNAs # extract rows that switch CNA value (for example from 2 to 3) CNA_change &lt;- which(c(FALSE, tail(df_chrom[,column_i],-1) != head(df_chrom[,column_i],-1))) # extract indices CNA_change_indices &lt;- unique(sort(c(1,CNA_change, (CNA_change-1), nrow(df_chrom)))) # construct dataframe containing end and start of each CNA CNA_change_df &lt;- df_chrom[CNA_change_indices,c(1,2,3,4,5, column_i)] names(CNA_change_df) &lt;- c(&#39;seqnames&#39;, &#39;start&#39;, &#39;end&#39;, &#39;width&#39;, &#39;strand&#39;, &#39;cna&#39;) start_list &lt;- list() end_list &lt;- list() i &lt;- 1 while(i&lt;=nrow(CNA_change_df)){ try(if(CNA_change_df[i+1, 6] == CNA_change_df[i, 6]){ start_list[[(length(start_list) + 1)]] &lt;- CNA_change_df[i,2] end_list[[(length(end_list) + 1)]] &lt;- CNA_change_df[i+1, 3] i &lt;- i+2 }) if(CNA_change_df[i+1, 6] != CNA_change_df[i, 6] || is.na(CNA_change_df[i+1, 6])){ start_list[[(length(start_list) + 1)]] &lt;- CNA_change_df[i,2] end_list[[(length(end_list) + 1)]] &lt;- CNA_change_df[i, 3] i &lt;- i+1 } } # constructing a dataframe cna_dataframe &lt;- data.frame(seqnames = chromosome, start = unlist(start_list), end = unlist(end_list)) # remove NA cna_dataframe &lt;- na.omit(cna_dataframe) # add column CNA cna_dataframe$cna &lt;- (CNA_change_df %&gt;% filter(cna!=lag(cna) | is.na(lag(cna))))$cna # remove columsn with cna == 2 (this is no CNA but normal diploid) cna_dataframe &lt;- subset(cna_dataframe, cna != 2) # add total number of CNAs in this cell as colunn num_cna try(cna_dataframe$num_cna &lt;- length(cna_dataframe$cna), silent = T) # add a width column of the CNA cna_dataframe$width &lt;- cna_dataframe$end - cna_dataframe$start + 1 # extract chromosome specifics chrom_df &lt;- subset(chrom_centro_total, seqnames == chromosome) # in the next of code, we are going to compute the fraction of SCNA # Important: using this measure, a fraction of 1 means that a region the size of one arm # was affected. A fraction of 2 means the whole chromosome is affected. Note that these CNA # can cross centromeres, so we are unable to easily assign if it is the p-arm or q-arm that is # affected. cna_dataframe$fraction &lt;- ifelse(cna_dataframe$end &lt; chrom_df$p_arm, (cna_dataframe$width / chrom_df$p_arm), ifelse(cna_dataframe$start &gt; chrom_df$p_arm, cna_dataframe$width / chrom_df$q_arm, (((chrom_df$p_arm - cna_dataframe$start) / chrom_df$p_arm) + ((cna_dataframe$end - chrom_df$p_arm) / chrom_df$q_arm)))) # adding cellname try(cna_dataframe$cell_id &lt;- colnames(df_chrom)[column_i], silent = T) return(cna_dataframe) } # running for each cell. cna_list &lt;- lapply(6:ncol(df), cna_extract_cell) # constructing single dataframe cna_df &lt;- bind_rows(cna_list, .id = &quot;cell_num_scar&quot;) # removing cell_num scar cna_df &lt;- cna_df[, 2:ncol(cna_df)] return(cna_df) } cna_df_per_chrom_list &lt;- list() for(chrom in unique(df$seqnames)) { cna_df_per_chrom_list[[chrom]] &lt;- cna_extract(chrom) } # constructing single dataframe cna_df_per_chrom_df &lt;- bind_rows(cna_df_per_chrom_list, .id = &quot;chrom_scar&quot;) # removing cell_num scar cna_df_per_chrom_df &lt;- cna_df_per_chrom_df[, 2:ncol(cna_df_per_chrom_df)] } 6.18 cin_signature_ccle script: ‘run_cin_ccle’ function run_cin_ccle &lt;- function(cnv, d) { #&#39; @param cnv is segmental data to input in CINSignatureQuantification #&#39; @param d is a dataframe with sample metadata that is joined with cnv #&#39; @return outputs CIN signature values. ############# # Libraries # ############# require(CINSignatureQuantification) require(tidyverse) ########### # Wrangle # ########### wrangler_cin_signature_ccle &lt;- function(df) { #&#39; @param df: A dataframe containing all the copy number calls of all the files. #&#39; @return a dataframe in the format https://github.com/markowetzlab/CINSignatureQuantification # remove unwanted column names keep_columns &lt;- c(&#39;Chromosome&#39;, &#39;Start&#39;, &#39;End&#39;, &#39;Segment_Mean&#39;, &#39;DepMap_ID&#39;) new_df &lt;- subset(df, select = keep_columns) # reorder columns col_order &lt;- c(&#39;Chromosome&#39;, &#39;Start&#39;, &#39;End&#39;, &#39;Segment_Mean&#39;, &#39;DepMap_ID&#39;) new_df &lt;- new_df[, col_order] # define new column names column_names &lt;- c(&#39;chromosome&#39;, &#39;start&#39;, &#39;end&#39;, &#39;segVal&#39;, &#39;sample&#39;) colnames(new_df) &lt;- column_names return(new_df) } # Subset cnv to only include samples where radiation sensitivity is known cnv &lt;- cnv[cnv$DepMap_ID %in% d$DepMap_ID,] # Wrangle cnv &lt;- wrangler_cin_signature_ccle(cnv) # The CIN algorithm (run with quantifyCNSignatures) does not support Y chromosome, we have to get rid of those. cnv &lt;- cnv[cnv$chromosome != &#39;Y&#39;, ] ####### # Run # ####### # Running the CIN scores cin_scores &lt;- quantifyCNSignatures(cnv, build = &#39;hg38&#39;) # Extracting the values. cin_values &lt;- getActivities(cin_scores) ########### # Wrangle # ########### cin_df &lt;- as.data.frame(cin_values) cin_df$DepMap_ID &lt;- rownames(cin_df) cin_df &lt;- gather(cin_df, cx_signature, cx_value, CX1:CX17, factor_key = T) # add some metadata cin_df &lt;- inner_join(cin_df, d) ########## # Return # ########## return(cin_df) } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
