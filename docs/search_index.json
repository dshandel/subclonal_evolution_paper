[["index.html", "Pre-existing Radioresistant Subclones Determine Radioresistance in Rectal Cancer Organoids 1 Introduction", " Pre-existing Radioresistant Subclones Determine Radioresistance in Rectal Cancer Organoids Daan Andel 2023-07-20 1 Introduction This book includes all the scripts used to generate the statistics and plots presented in the paper “Pre-existing Radioresistant Subclones Determine Radioresistance in Rectal Cancer Organoids.” The scripts are arranged in a loose chronological order, corresponding to the flow of the paper. The source code referenced within the scripts can be located in the ‘R’ folder on the associated Github page and also in the final chapter of this book. Paper: https://doi-org.proxy.library.uu.nl/10.1002/bjs.11828 Github: https://github.com/dshandel/subclonal_evolution_paper "],["in-vitro-radiation-response-and-clinical-data.html", "2 In vitro radiation response and clinical data 2.1 Progression-free survival 2.2 In vitro dose-response", " 2 In vitro radiation response and clinical data 2.1 Progression-free survival # Libraries and sources library(readxl) library(tidyverse) library(ggplot2) library(ggfortify) library(survival) library(survminer) library(survMisc) library(cowplot) ######## # Data # ######## # Loading survival data from time of surgery surg_surv &lt;- as.data.frame(read_excel(&quot;../cna_analysis/data/clinical_and_dr/data_survival_progression.xlsx&quot;, sheet = &quot;surg_surv&quot;)) # Loading progression data from time of surgery surg_prog &lt;- as.data.frame(read_excel(&quot;../cna_analysis/data/clinical_and_dr/data_survival_progression.xlsx&quot;, sheet = &quot;surg_prog&quot;)) ####### # Run # ####### ## Survival from time of surgery ## surg_surv_sum &lt;- Surv(time = surg_surv$time, event = surg_surv$status == 2) # Fit without strata (~1) surg_surv_fit &lt;- survfit(surg_surv_sum ~ 1) # Median survival from time of surgery surv_median(surg_surv_fit)[1,2] ## [1] 1857 ## Progression from time of surgery ## surg_prog_sum &lt;- Surv(time = surg_prog$time, event = surg_prog$status == 2) # Fit without strata (~1) surg_prog_fit &lt;- survfit(surg_prog_sum ~ 1) # Median progression from time of surgery surv_median(surg_prog_fit)[1,2] ## [1] NA ######## # Plot # ######## # Constructing a dataframe for annotating labels anno_df_prog &lt;- data.frame(label = surg_prog$organoid, time = surg_prog$time) # make temp df with survival/prob data temp_df_prob_prog &lt;- data.frame(time = surg_prog_fit$time, prob = surg_prog_fit$surv ) # join together anno_df_prog &lt;- left_join(anno_df_prog, temp_df_prob_prog) # sort by time anno_df_prog &lt;- anno_df_prog[order(anno_df_prog$time),] # Plotting progression free survival prog_p &lt;- ggsurvplot(surg_prog_fit, data = surg_prog, conf.int = F, palette = c(&quot;#00887d&quot;), ggtheme = theme_cowplot(), legend = &#39;none&#39;, censor.size = 8, xlim = c(0,2200), ylab = &#39;Progression-free survival probability&#39;, xlab = &#39;Time from surgery (days)&#39;) # adding labels prog_p$plot &lt;- prog_p$plot + annotate(&quot;text&quot;, x = anno_df_prog$time + c(350, 350, 350, -150,50,250,0,0), y = anno_df_prog$prob + c(0.1,0.1,0.1, -0.05, 0.05, -0.05, 0.05,-0.05), label = anno_df_prog$label) + theme(aspect.ratio = 5/3) + coord_cartesian(clip = &#39;off&#39;) prog_p 2.2 In vitro dose-response # Libraries and sources library(tidyverse) # for wrangling data library(readxl) # for reading excel files library(DescTools) # for computing AUCs with AUC() function) library(drc) # for fitting dose response library(cowplot) library(wesanderson) source(&#39;R/auc_rad.R&#39;) source(&#39;R/fitter_rad.R&#39;) source(&#39;R/ic50_rad.R&#39;) source(&#39;R/relativize_dr.R&#39;) 2.2.1 Dose-response plot ################ # Loading data # ################ d &lt;- data.frame(read_excel(&#39;../cna_analysis/data/clinical_and_dr/resistancy_organoids.xlsx&#39;)) # remove fluke experiment (can&#39;t be fitted by the drc package in metricsandfits.R) d &lt;- subset(d, expcode != &#39;cva0028&#39;) # remove dose 1, 10,12 d &lt;- subset(d, dose %in% c(0,2,4,6,8)) # only include organoids that were not radiated d &lt;- subset(d, rec_rad == 0) ############## # Relativize # ############## # Relativizing the data # split per experiment per_exp &lt;- split(d, f = d$expcode, drop = TRUE) # apply relative function to every instance in per_exp rel_vector_unrad &lt;- lapply(per_exp, relative, rad = F) # join the dataframes togheter d_nonrad = do.call(rbind, rel_vector_unrad) #remove rownames rownames(d_nonrad) &lt;- NULL # pool d_rad and d_nonrad, if not possible, make d d_nonrad # try to bind d_rad and d_nonrad. If d_rad is empty (this is the case when # rec_rad does not have ones, make d the same as d_nonrad) d &lt;- d_nonrad ################ # Loading data # ################ load(&quot;../cna_analysis/rda/clinical_and_dr/wrangled-data.rda&quot;) # load the wrangled data, data is saved under &#39;d&#39; # defining experiment number for reference exp_numb &lt;- unique(d$expcode) exp_numb &lt;- paste(unlist(exp_numb), collapse=&#39;&#39;) ################## ### Metric AUC ### ################## # split per experiment per_exp &lt;- split(d, f = d$expcode, drop = TRUE) # apply relative function to every instance in per_exp AUC_vector &lt;- lapply(per_exp, AUC_fun) # join the dataframes togheter AUC = do.call(rbind, AUC_vector) # remove rownames rownames(AUC) &lt;- NULL ####### # Fit # ####### # apply fit function to every instance in per_exp fit_vector &lt;- lapply(per_exp, fitter) # join the dataframes toghether fit = do.call(rbind, fit_vector) # remove rownames rownames(fit) &lt;- NULL fit$rec_rad = 0 # remove rownames rownames(fit) &lt;- NULL ################## # relative IC50s # ################## ## relative under curve for unrad # apply relative function to every instance in per_exp IC50_vector &lt;- lapply(per_exp, IC50_fun, rad = 0) # join the dataframes togheter IC50= do.call(rbind, IC50_vector) metrics = cbind(AUC, IC50) metrics$rec_rad &lt;- 0 # compute mean of rel_AUC metrics_pooled &lt;- metrics %&gt;% group_by(cline) %&gt;% summarise_at(vars(rel_AUC), funs(mean(., na.rm=TRUE))) metrics_pooled$expcode &lt;- exp_numb # compute mean of rel_AUC metrics_pooled &lt;- metrics %&gt;% group_by(cline) %&gt;% summarise_at(vars(rel_AUC), funs(mean(., na.rm=TRUE))) # summary statistics median(metrics$rel_AUC) ## [1] 0.5758785 min(metrics$rel_AUC) ## [1] 0.304031 max(metrics$rel_AUC) ## [1] 0.8152938 ######## # Data # ######## load(&quot;../cna_analysis/rda/clinical_and_dr/wrangled-data.rda&quot;) # load the wrangled data, data is saved under &#39;d&#39; load(&quot;../cna_analysis/rda/clinical_and_dr/fitted-data.rda&quot;) # load the wrangled data, data is saved under &#39;fit&#39; load(&#39;../cna_analysis/rda/clinical_and_dr/metrics_data.rda&#39;) # load the metrics data ########### # Wrangle # ########### ### define two dataframes, one from rad one without rad: fit &lt;- subset(fit, rec_rad == 0) exp_numb &lt;- unique(d$expcode) exp_numb &lt;- paste(unlist(exp_numb), collapse=&#39;&#39;) # new data with doses. Note: lowest dose is not # log 0 but log(&#39;very small number&#39;) because otherwise this will hamper the scaling in ggplot later on. d$dose0 &lt;- d$dose d$dose0[d$dose0 == 0] &lt;- 0.00000001 # representative expcodes # makeing helper column to extract representative expcodes d$cline_expcode &lt;- paste0(d$cline, &#39;_&#39;, d$expcode) fit$cline_expcode &lt;- paste0(fit$cline, &#39;_&#39;, fit$expcode) # subsetting cline_expcode_pick &lt;- c( &#39;HUB005_cva0025&#39;, &#39;HUB183_cva0025&#39;, &#39;HUB015_cva0023&#39;, &#39;HUB175_cva0024&#39;, &#39;HUB181I_cva0021&#39;, &#39;HUB197_cva0030&#39;, &#39;HUB106_cva0020&#39;, &#39;HUB062_cva0023&#39;, &#39;HUB112_cva0112&#39;) d &lt;- subset(d, cline_expcode %in% cline_expcode_pick) fit &lt;- subset(fit, cline_expcode %in% cline_expcode_pick) # add resistantcy group for colour coding resistant &lt;- c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB015&#39;) sensitive &lt;- c(&#39;HUB197&#39;, &#39;HUB106&#39;, &#39;HUB062&#39;) d$resistancy_group &lt;- ifelse( d$cline %in% resistant, &#39;Resistant&#39;, ifelse(d$cline %in% sensitive, &#39;Sensitive&#39;, &#39;Intermediate&#39;) ) fit$resistancy_group &lt;- ifelse( fit$cline %in% resistant, &#39;Resistant&#39;, ifelse(fit$cline %in% sensitive, &#39;Sensitive&#39;, &#39;Intermediate&#39;) ) # Make cline a factor and specify order by decreasing AUC mean d$cline &lt;- factor(d$cline, levels = c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB015&#39;, &#39;HUB112&#39;, &#39;HUB175&#39;, &#39;HUB181I&#39;, &#39;HUB106&#39;, &#39;HUB197&#39;, &#39;HUB062&#39;)) d$resistancy_group &lt;- factor(d$resistancy_group, levels = c(&#39;Resistant&#39;, &#39;Intermediate&#39;, &#39;Sensitive&#39;)) ggplot(NULL, aes(x = dose0, y = relative_mean, group = cline, col = resistancy_group)) + geom_point(data= d, size =3, aes(shape = cline)) + geom_errorbar(data = d, aes(ymin=relative_mean-relative_sem,ymax=relative_mean+relative_sem), width=0.1) + geom_line(data = d) + # geom_line(data=fit, aes(x=dose, y=pred), # size = 1) + # adding log x-axis coord_trans(#x=&quot;log10&quot;, xlim = c(0.00000001, 8), ylim = c(0, 1.1)) + scale_x_continuous(breaks = c(0, 2,4,6,8)) + scale_y_continuous(expand = c(0,0)) + theme_cowplot() + ylab(&#39;Normalized viability&#39;) + xlab(&#39;Dose (Gy)&#39;) + theme( legend.title = element_blank(), aspect.ratio = 5 / 3) + scale_shape_manual(values=seq(0,8)) + scale_colour_manual( values = c( Resistant = &#39;#DE3163&#39;, Sensitive = &#39;#5090CD&#39;, Intermediate = &#39;grey75&#39; ), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length( unique(d$resistancy_group) ))), shape = c(rep(19, length( unique(d$resistancy_group) ))) )) ) 2.2.2 rAUC across multiple experiments ######## # Data # ######## load(&#39;../cna_analysis/rda/clinical_and_dr/metrics_data.rda&#39;) # load the wrangled data, data is saved under &#39;metrics&#39; exp_numb &lt;- unique(metrics$expcode) exp_numb &lt;- paste(unlist(exp_numb), collapse = &#39;&#39;) ########### # Wrangle # ########### # Make cline a factor and specify order by decreasing AUC mean metrics$cline &lt;- factor( metrics$cline, levels = metrics %&gt;% group_by(cline) %&gt;% summarize(mean_auc = mean(rel_AUC)) %&gt;% arrange(-mean_auc) %&gt;% pull(cline) ) # add resistantcy group for colour coding resistant &lt;- c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB015&#39;) sensitive &lt;- c(&#39;HUB197&#39;, &#39;HUB106&#39;, &#39;HUB062&#39;) metrics$resistancy_group &lt;- ifelse( metrics$cline %in% resistant, &#39;Resistant&#39;, ifelse(metrics$cline %in% sensitive, &#39;Sensitive&#39;, &#39;Intermediate&#39;) ) # changing order of resistancy_group metrics$resistancy_group &lt;- factor(metrics$resistancy_group, levels = c(&quot;Resistant&quot;, &quot;Intermediate&quot;, &quot;Sensitive&quot;)) ######## # Plot # ######## ggplot(metrics, aes(x = cline, y = rel_AUC, group = cline)) + geom_boxplot(aes(fill = resistancy_group)) + geom_jitter(height = 0, width = 0.1, size = 2) + theme_cowplot() + scale_fill_manual( values = c( Resistant = &#39;#DE3163&#39;, Sensitive = &#39;#5090CD&#39;, Intermediate = &#39;grey75&#39; ), guide = guide_legend(override.aes = list( linetype = c(rep(&quot;blank&quot;, length( unique(metrics$resistancy_group) ))), shape = c(rep(19, length( unique(metrics$resistancy_group) ))) )) ) + xlab(&#39;&#39;) + ylab(&#39;Relative AUC&#39;) + theme( legend.title = element_blank(), aspect.ratio = 5 / 3, axis.text.x = element_text(angle = 45, hjust = 1) ) + coord_cartesian(clip = &#39;off&#39;) + scale_y_continuous(limits = c(0,1)) 2.2.3 Flow cytometry-based measurement of (apoptotic) cells with sub-G1 DNA content ########### # Wrangle # ########### d &lt;- data.frame(read_excel(&quot;../cna_analysis/data/clinical_and_dr/nicoletti_data.xlsx&quot;)) # defining experiment number for referenc exp_numb &lt;- unique(d$expcode) exp_numb &lt;- paste(unlist(exp_numb), collapse = &#39;&#39;) # defining apoptosis percentage d$apop_perc &lt;- d$subg1 / d$singlets * 100 d_zero &lt;- d %&gt;% group_by(cline, expcode) %&gt;% arrange(cline, expcode) %&gt;% filter(dose == 0) d_five &lt;- d %&gt;% group_by(cline, expcode) %&gt;% arrange(cline, expcode) %&gt;% filter(dose == 5) df_fc_apop &lt;- data.frame( cline = d_zero$cline, expcode = d_zero$expcode, fc_apop = d_five$apop_perc / d_zero$apop_perc ) %&gt;% group_by(cline) %&gt;% summarize(mean_apop_fc = mean(fc_apop), sd_apop_fc = sd(fc_apop)) df_fc_apop$cline &lt;- factor(df_fc_apop$cline, levels = c(&#39;HUB005&#39;, &#39;HUB183&#39;, &#39;HUB062&#39;, &#39;HUB106&#39;)) df_fc_apop ## # A tibble: 4 × 3 ## cline mean_apop_fc sd_apop_fc ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 HUB005 1.31 0.538 ## 2 HUB062 5.88 0.903 ## 3 HUB106 11.8 0.714 ## 4 HUB183 2.93 0.0548 ######## # Plot # ######## ggplot(df_fc_apop, aes(x= cline, y = mean_apop_fc, fill = cline)) + geom_bar(aes(group = cline), stat = &#39;identity&#39;, position=position_dodge(), col = &#39;black&#39;) + geom_linerange(aes(ymin=mean_apop_fc, ymax=mean_apop_fc + sd_apop_fc), position=position_dodge(0.65), size = 1, alpha = 0.8) + theme_cowplot() + scale_fill_manual( values = c(HUB181I = &quot;#8491B4FF&quot;, HUB005 = &quot;#E64B35FF&quot;, HUB062 = &quot;#91D1C2FF&quot;, HUB015 = &#39;#FADA5E&#39;, HUB106 = &quot;#3C5488FF&quot;, HUB183 = &quot;#F39B7FFF&quot;, HUB175 = &quot;#00A087FF&quot;, HUB197 = &#39;grey&#39;)) + scale_y_continuous(expand = c(0,0,0.01,0)) + theme_cowplot() + ylab(&#39;Fold change (% apoptotic cells)&#39;) + xlab(&#39;&#39;) + guides(fill=&quot;none&quot;) + theme( aspect.ratio = 5 / 3, axis.text.x = element_text(angle = 45, hjust=1)) 2.2.4 Recovery statistics after 10 Gy radiation ######## # Data # ######## df &lt;- as.data.frame(read_excel(&quot;../cna_analysis/data/clinical_and_dr/ 10gy_recovery_data.xlsx&quot;)) ########### # Wrangle # ########### df_res &lt;- subset(df, resistancy_group == &#39;Resistant&#39;) df_sens &lt;- subset(df, resistancy_group == &#39;Sensitive&#39;) ############## # Statistics # ############## # Resistant mean_days_res &lt;- mean(as.numeric(df_res$days_to_full_recovery), na.rm = T) mean_days_res ## [1] 30.66667 sd_days_res &lt;- sd(as.numeric(df_res$days_to_full_recovery), na.rm = T) sd_days_res ## [1] 11.54701 # Sensitive mean_days_sens &lt;- mean(as.numeric(df_sens$days_to_full_recovery), na.rm = T) mean_days_sens ## [1] 49 sd_days_sens &lt;- sd(as.numeric(df_sens$days_to_full_recovery), na.rm = T) sd_days_sens ## [1] 23.64318 "],["subclonal-dynamics.html", "3 Subclonal dynamics 3.1 AneuFinder run 3.2 Quality selection 3.3 Summary statistics of copy number alterations 3.4 PCA and K-means plots 3.5 Subclone selection 3.6 Single cell copy number heatmap plots 3.7 Fisher’s test", " 3 Subclonal dynamics # Libraries and sources library(tidyverse) library(AneuFinder) library(GenomeInfoDb) library(BSgenome.Hsapiens.UCSC.hg38) library(stringr) source(&#39;R/plot_pca_kmeans.R&#39;) source(&#39;R/quality_functions.R&#39;) source(&#39;R/divide_subclone_functions.R&#39;) source(&#39;R/plot_genomeheatmap.R&#39;) source(&#39;R/fisher_test.R&#39;) 3.1 AneuFinder run 3.2 Quality selection ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/cl_list_edivisive_paired.rda&#39;) ################# # Quality check # ################# qual_summary &lt;- lapply(cl_list_edivisive, check_quality) ####### # Run # ####### select_files_edivisive &lt;- lapply(cl_list_edivisive, quality_select, spik = 0.7, bhat = 0) ######## # Save # ######## save(select_files_edivisive, file = &#39;../cna_analysis/rda/subclonal_dynamics/select_files_edivisive.rda&#39;) ############### # Description # ############### # After AneuFinder&#39;s inbuild quaility selection, there are still some evident # noisy single cells, that appear on the heatmap as if having very high and # unstructured ploidy. These single cell&#39;s will be removed manually here. The cells # were selected by inspecting standard AneuFinder heatmaps on the post-quality # selected files (code not shown). ######## # Data # ######## # loading files after quality selection load(&#39;../cna_analysis/rda/subclonal_dynamics/select_files_edivisive.rda&#39;) ########## # Select # ########## # removing karyotypes that are clearly artefacts. The karyotypes are # selected based on the figures in figs -&gt; genomeheatmap_afterqc -&gt; edivisive kra003_remove &lt;- as.character(c( 272, 122 , 33 , 198 , 372, 116 , 105 , 104, 175 , 341 , 30, 12 , 280 , 215 , 31 , 139 , 295 , 370 , 337 , 307 , 170 ,80 , 357 , 34, 21 , 60 , 129 , 318 , 39 , 365, 113 , 89 , 4 , 57 , 162 , 20 , 135 , 235 , 377 , 181 , 46 , 84 , 186 , 81, 257 , 225 , 191 , 269)) kra004_remove &lt;- as.character(c(266, 251, 375, 256, 303, 179, 160, 290, 368, 28, 334, 211, 261, 58, 133, 115, 161, 20, 162, 112, 314, 181, 264, 268, 268, 30, 127, 98, 191, 383, 232, 104, 350, 163, 377, 323, 333, 224, 242, 184, 244, 277, 102, 21, 93, 149, 101, 332, 188, 225, 135)) kra005_remove &lt;- as.character(c(89, 159, 61, 155, 146, 141, 30, 174, 95, 262, 264, 48, 152, 103, 92, 116, 297, 333)) kra006_remove &lt;- as.character(c(380, 176, 328, 255, 4, 60, 264, 111, 173)) kra007_remove &lt;- as.character(c(37, 366, 213, 262, 83, 78, 10, 351)) ## diploid subclone91, 363, 275)) kra008_remove &lt;- as.character(c(70, 143, 77, 144, 146, 189, 35, 170, 30, 119, 65, 51, 107, 362, 58 ,125, 66 ,210 ,160 ,186, 102, 37, 226, 183, 59, 159, 46, 87, 118, 285, 69, 109)) # diploid subclone # 287, 302, 212, 15, # 115, 166, 126, 17, 95, 231, 19, 104, # 86, 138, 105, 116, 81 ,130, 88, 61)) kra009_remove &lt;- as.character(c(239, 347, 94, 65, 91, 163, 246, 6 ,116, 330, 126, 76, 54, 57, 107 ,181, 154, 137, 60, 114, 55, 81, 179, 241, 75, 142, 329, 323)) # diploid subclone kra009 74, 59, 375, 112, 92, 99, # 105 kra010_remove &lt;- as.character(c(363, 217, 242, 238, 27, 46, 189, 28, 216, 84, 234, 71, 95, 60, 86, 181, 172, 42, 355, 58, 43, 132, 262, 176, 143,311, 203, 297,307, 3, 227, 72, 177, 115, 54, 258)) kra022_remove &lt;- as.character(c(5, 31, 161)) # kra003_subclone&lt;- as.character(c(372, 173, 274, 108, 39, 289)) kra023_remove &lt;- as.character(c(96, 199, 246, 135, 104, 5)) # kra004_subclone&lt;- as.character(c(92, 102, 252, 181, # 264, 258, 290, 268) kra024_remove &lt;- as.character(c(193, 344, 337, 356, 85,86,309,52, 188,374, 176,53, 87,169,36,115, 45,281,66)) # kra005_subclone &lt;- as.character(c(297, 92, 113, 103, # 152, 48, 333)) kra025_remove &lt;- as.character(c(141, 257,85,183,127)) # kra006_subclone &lt;- as.character(c(380)) kra026_remove &lt;- as.character(c(318, 287, 260, 208, 247, 75, 285, 376, 238, 200, 215, 362, 49)) # kra007_subclone &lt;- as.character(c(318, 292, 381, 319, # 198, 208, 351, 353, # 285, 379)) kra027_remove &lt;- as.character(c(339, 375, 141, 126, 346, 204, 69, 343, 377, 364, 298, 79)) # kra008_subclone &lt;- as.character(c(69, 87, 60, 61, # 143, 35, 241, 202)) kra028_remove &lt;- as.character(c(37, 178, 167, 225, 125, 90, 249, 50,66, 327 )) # kra009_subclone1 &lt;- as.character(c(375)) kra029_remove &lt;- as.character(c(14, 277, 353, 203, 137 )) kra030_remove &lt;- as.character(c(341, 177, 111, 157, 226, 209, 150, 301, 158, 121, 273, 190, 47, 18 )) kra031_remove &lt;- as.character(c(159, 217, 261, 122, 60, 201, 153)) kra032_remove &lt;- as.character(c(349, 347, 58, 370, 284, 366, 326, 373, 306, 27, 138, 113, 348, 22, 24, 103, 218, 181)) # kra010 has three subclones!! # kra010_subclone1 &lt;- as.character(c(355,34,166,139, # 19, 213, 357, 57, # 72)) # kra010_subclone2 &lt;- 317 t/m 304 # kra010_subclone2 &lt; 235 t/m 176 ########## # Remove # ########## kra003 &lt;- remove_selection(select_files_edivisive$kra003, kra003_remove) kra004 &lt;- remove_selection(select_files_edivisive$kra004, kra004_remove) kra005 &lt;- remove_selection(select_files_edivisive$kra005, kra005_remove) kra006 &lt;- remove_selection(select_files_edivisive$kra006, kra006_remove) kra007 &lt;- remove_selection(select_files_edivisive$kra007, kra007_remove) kra008 &lt;- remove_selection(select_files_edivisive$kra008, kra008_remove) kra009 &lt;- remove_selection(select_files_edivisive$kra009, kra009_remove) kra010 &lt;- remove_selection(select_files_edivisive$kra010, kra010_remove) kra022 &lt;- remove_selection(select_files_edivisive$kra022, kra022_remove) kra023 &lt;- remove_selection(select_files_edivisive$kra023, kra023_remove) kra024 &lt;- remove_selection(select_files_edivisive$kra024, kra024_remove) kra025 &lt;- remove_selection(select_files_edivisive$kra025, kra025_remove) kra026 &lt;- remove_selection(select_files_edivisive$kra026, kra026_remove) kra027 &lt;- remove_selection(select_files_edivisive$kra027, kra027_remove) kra028 &lt;- remove_selection(select_files_edivisive$kra028, kra028_remove) kra029 &lt;- remove_selection(select_files_edivisive$kra029, kra029_remove) kra030 &lt;- remove_selection(select_files_edivisive$kra030, kra030_remove) kra031 &lt;- remove_selection(select_files_edivisive$kra031, kra031_remove) kra032 &lt;- remove_selection(select_files_edivisive$kra032, kra032_remove) man_select_files_edivisive &lt;- list(kra003 = kra003, kra004 = kra004, kra005 = kra005, kra006 = kra006, kra007 = kra007, kra008 = kra008, kra009 = kra009, kra010 = kra010, kra022 = kra022, kra023 = kra023, kra024 = kra024, kra025 = kra025, kra026 = kra026, kra027 = kra027, kra028 = kra028, kra029 = kra029, kra030 = kra030, kra031 = kra031, kra032 = kra032 ) ######## # Save # ######## save(man_select_files_edivisive, file = &#39;../cna_analysis/rda/subclonal_dynamics/man_select_files_edivisive.rda&#39; ) 3.3 Summary statistics of copy number alterations ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/man_select_files_edivisive.rda&#39; ) ########### # Wrangle # ########### # removing HUB181I kra024 en kra025 man_select_files_edivisive &lt;- man_select_files_edivisive[!names(man_select_files_edivisive) %in% c(&#39;kra024&#39;, &#39;kra025&#39;)] # !!! GITHUB SPECIFIC CODE !!! # # adding &#39;../cna_analysis/&#39; to each path within man_select_files_edivisive man_select_files_edivisive &lt;- lapply(man_select_files_edivisive, function(x) paste0(&quot;../cna_analysis/&quot;, x)) ####### # Run # ####### # loading segment data from files files_loaded &lt;- loadFromFiles(unlist(man_select_files_edivisive), check.class=c(&#39;GRanges&#39;, &#39;GRangesList&#39;, &#39;aneuHMM&#39;, &#39;aneuBiHMM&#39;)) # Computing the total number of cells sequenced length(files_loaded) ## [1] 2944 # computing the total sum of unique CNAs per single cell and store in a vector cna_vector &lt;- sapply(files_loaded, function(file) { seg_grange &lt;- file$segments cnas_grange &lt;- seg_grange[seg_grange$copy.number != 2,] return(length(cnas_grange)) }) # Computing the mean CNA per single cell mean(cna_vector) ## [1] 26.98709 # Computing the standard deviation of CNAs per single cell. sd(cna_vector) ## [1] 11.74091 3.4 PCA and K-means plots ######## # Plot # ######## # HUB183 # ###################################################################### # PCA # hub183_pca &lt;- draw_pca( man_select_files_edivisive$kra003, man_select_files_edivisive$kra004, size = 1, legend_position = c(0.65, 0.8) ) hub183_pca # K-means # hub183_kmeans &lt;- k_cluster( man_select_files_edivisive$kra003, man_select_files_edivisive$kra004, cluster = 1, cols = c(&quot;#C6CDF7&quot;), labels = c(&#39;A&#39;), legend_position = c(0.8, 0.85), normalize = T, return_elbow = F ) hub183_kmeans # HUB005 # ###################################################################### # PCA # hub005_pca &lt;- draw_pca( man_select_files_edivisive$kra005, man_select_files_edivisive$kra006, size = 1, legend_position = c(0.65, 0.85) ) hub005_pca # K-means # hub005_kmeans &lt;- k_cluster( man_select_files_edivisive$kra005, man_select_files_edivisive$kra006, cluster = 3, cols = c(&#39;#809aa6&#39;, # greyblue &quot;#D69C4E&quot;, # brown, &quot;#046C9A&quot;), #darkblue labels = c(&#39;A.b&#39;, &#39;B&#39;, &#39;A.a&#39;), legend_position = c(0.8, 0.85), normalize = T, return_elbow = F ) hub005_kmeans # HUB106 # ###################################################################### # PCA # hub106_pca &lt;- draw_pca( man_select_files_edivisive$kra007, man_select_files_edivisive$kra008, size = 1, legend_position = c(0.65, 0.95) ) hub106_pca # K-means # hub106_kmeans &lt;- k_cluster( man_select_files_edivisive$kra007, man_select_files_edivisive$kra008, cluster = 3, cols = c(&quot;#E6A0C4&quot;, # pink &quot;#D8A499&quot;, #brownpink &quot;#7294D4&quot;), # blue labels = c(&#39;A&#39;, &#39;C&#39;, &#39;B&#39;), legend_position = c(0.8, 0.85), normalize = T, return_elbow = F ) hub106_kmeans # HUB062 # ###################################################################### ### Biological replicate 1 ### # PCA # hub062_pca_double &lt;- draw_pca_double( man_select_files_edivisive$kra009, man_select_files_edivisive$kra010, man_select_files_edivisive$kra030, size = 1, legend_position = c(0.05, 0.2) ) hub062_pca_double # &#39;zoom&#39; hub062_pca_double_zoom &lt;- draw_pca_double( man_select_files_edivisive$kra009, man_select_files_edivisive$kra010, man_select_files_edivisive$kra030, size = 15, legend_position = c(-0.05, 0.25) ) + coord_cartesian(xlim = c(-0.016, 0.030), ylim = c(0, 0.06)) + theme( axis.line = element_blank(), axis.text.x = element_blank(), axis.text.y = element_blank(), axis.ticks = element_blank(), axis.title.x = element_blank(), axis.title.y = element_blank(), legend.position = &quot;none&quot;, panel.background = element_blank(), panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.background = element_blank() ) hub062_pca_double_zoom # K-means # hub062_kmeans_double &lt;- k_cluster_double( man_select_files_edivisive$kra009, man_select_files_edivisive$kra010, man_select_files_edivisive$kra030, cluster = 3, cols = c(&quot;#F1BB7B&quot;, #orange like &quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;), #brownish labels = c(&#39;C&#39;, &#39;A&#39;, &#39;B&#39;), legend_position = c(0.05, 0.2), normalize = T, return_elbow = F ) hub062_kmeans_double ### Biological replicate 2 ### # PCA # hub062_pca_rep2 &lt;- draw_pca( man_select_files_edivisive$kra028, man_select_files_edivisive$kra032, size = 1, legend_position = c(0.05, 0.9) ) hub062_pca_rep2 # K-means # hub062_kmeans_rep2 &lt;- k_cluster( man_select_files_edivisive$kra028, man_select_files_edivisive$kra032, cluster = 3, cols = c(&quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;, #brownish &quot;#F1BB7B&quot;), #orange like labels = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;), legend_position = c(0.05, 0.9), normalize = T ) hub062_kmeans_rep2 # HUB015 # ###################################################################### # PCA # hub015_pca &lt;- draw_pca( man_select_files_edivisive$kra022, # 10 gy radiated man_select_files_edivisive$kra023, # 0 gy control size = 1, legend_position = c(0.05, 0.8), ssdna004 = T ) # coordinates do not correspond with coordinates in pc1 and pc2! hub015_pca # K-means # hub015_kmeans &lt;- k_cluster( man_select_files_edivisive$kra022, man_select_files_edivisive$kra023, cluster = 3, cols = c(&quot;#f5de90&quot;, &#39;#E1AF00&#39;, &#39;#F21A00&#39;), # red labels = c( &#39;A.a&#39;,&#39;A.b&#39;, &#39;B&#39;), legend_position = c(0.05, 0.8), normalize = T, return_elbow = F ) hub015_kmeans # HUB197 # ###################################################################### # PCA # hub197_pca &lt;- draw_pca( man_select_files_edivisive$kra026, # 10 gy man_select_files_edivisive$kra027, # 0 gy # 0 Gy size = 1, legend_position = c(0.7, 0.8), ssdna004 = T ) hub197_pca # K-means # hub197_kmeans &lt;- k_cluster( man_select_files_edivisive$kra026, man_select_files_edivisive$kra027, cluster = 3, cols = c(&quot;#0B775E&quot;, &#39;#E1BD6D&#39;, &#39;#35274A&#39; ), labels = c(&#39;C&#39;, &#39;B&#39;, &#39;A&#39;), legend_position = c(0.7, 0.8), normalize = T ) hub197_kmeans ####### # END # ####### 3.5 Subclone selection 3.5.1 Selecting subclones #################### # Define subclones # #################### # volgorde: HUB183, 005, 106, 062, 015, 197, 181i # HUB183 # ###################################################################### # Pre-rad # ########### # (kra003) has one clones hub183_prerad_a &lt;- man_select_files_edivisive$kra003 # post-rad # ############ hub183_postrad_a &lt;- man_select_files_edivisive$kra004 # HUB005 # ###################################################################### # pre-rad # ########### hub005_prerad_a.a &lt;- extract_square(man_select_files_edivisive$kra005, NULL, square = c(0.037, -0.0096), x = &#39;&gt;&#39;, y = &#39;&lt;&#39;) # 161 is added erroneously here hub005_prerad_a.a &lt;- hub005_prerad_a.a[hub005_prerad_a.a != 161] hub005_prerad_b &lt;- extract_square(man_select_files_edivisive$kra005, NULL, square = c(0.037, 0.2), x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub005_prerad_a.b &lt;- as.numeric(extract_other_cells(&#39;kra005&#39;, c(hub005_prerad_a.a, hub005_prerad_b))) # here we are going to locate the single cell bam files belonging to one clone. hub005_prerad_a.a &lt;- unlist(sapply(hub005_prerad_a.a, l_g, kra_num = &#39;KRA-005&#39;, list_cells = man_select_files_edivisive$kra005)) hub005_prerad_a.b &lt;- unlist(sapply(hub005_prerad_a.b, l_g, kra_num = &#39;KRA-005&#39;, list_cells = man_select_files_edivisive$kra005)) hub005_prerad_b &lt;- unlist(sapply(hub005_prerad_b, l_g, kra_num = &#39;KRA-005&#39;, list_cells = man_select_files_edivisive$kra005)) # quick check if we did alright (should be TRUE) length(man_select_files_edivisive$kra005) == length(hub005_prerad_a.a) + length(hub005_prerad_a.b) + length(hub005_prerad_b) # postrad # ########### hub005_postrad_b &lt;- extract_square(man_select_files_edivisive$kra006, NULL, square = c(-0.06, 0.25), # groter # kleiner x = &#39;&gt;&#39;, y = &#39;&lt;&#39;) hub005_postrad_a.b &lt;- c(238, 260) hub005_postrad_a.a &lt;- as.numeric(extract_other_cells(&#39;kra006&#39;, c(hub005_postrad_b, hub005_postrad_a.b))) # here we are going to locate the single cell bam files belonging to one clone. hub005_postrad_b &lt;- unlist(sapply(hub005_postrad_b, l_g, kra_num = &#39;KRA-006&#39;, list_cells = man_select_files_edivisive$kra006)) hub005_postrad_a.a &lt;- unlist(sapply(hub005_postrad_a.a, l_g, kra_num = &#39;KRA-006&#39;, list_cells = man_select_files_edivisive$kra006)) hub005_postrad_a.b &lt;- unlist(sapply(hub005_postrad_a.b, l_g, kra_num = &#39;KRA-006&#39;, list_cells = man_select_files_edivisive$kra006)) # quick check if we did it alright length(man_select_files_edivisive$kra006) == length(hub005_postrad_b) + length(hub005_postrad_a.a) + length(hub005_postrad_a.b) # HUB106 # ###################################################################### # prerad # ########## hub106_prerad_a &lt;- extract_square(man_select_files_edivisive$kra007, NULL, square = c(-0.006, 0.2), x = &#39;&gt;&#39;, y = &#39;&lt;&#39;) hub106_prerad_b &lt;- extract_square(man_select_files_edivisive$kra007, NULL, square = c(-0.006, 0.2), x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub106_prerad_c &lt;- extract_square(man_select_files_edivisive$kra007, NULL, square = c(-0.3, 0.2), x = &#39;&gt;&#39;, y = &#39;&gt;&#39;) hub106_prerad_a &lt;- unlist(sapply(hub106_prerad_a, l_g, kra_num = &#39;KRA-007&#39;, list_cells = man_select_files_edivisive$kra007)) hub106_prerad_b &lt;- unlist(sapply(hub106_prerad_b, l_g, kra_num = &#39;KRA-007&#39;, list_cells = man_select_files_edivisive$kra007)) hub106_prerad_c &lt;- unlist(sapply(hub106_prerad_c, l_g, kra_num = &#39;KRA-007&#39;, list_cells = man_select_files_edivisive$kra007)) # quick check length(man_select_files_edivisive$kra007) == length(hub106_prerad_a) + length(hub106_prerad_b) + length(hub106_prerad_c) # postrad # ########### hub106_postrad_c &lt;- extract_square(man_select_files_edivisive$kra008, NULL, square = c(-0.1, 0.2), x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub106_postrad_a &lt;- extract_square(man_select_files_edivisive$kra008, NULL, square = c(-0.1, -0.014), x = &#39;&gt;&#39;, y = &#39;&lt;&#39;) remove_a &lt;- c(349, 164) add_a &lt;- c(382, 12, 16) hub106_postrad_a &lt;- hub106_postrad_a[!hub106_postrad_a %in% remove_a] hub106_postrad_a &lt;- c(hub106_postrad_a, add_a) hub106_postrad_b &lt;- extract_square(man_select_files_edivisive$kra008, NULL, square = c(-0.1, -0.014), x = &#39;&gt;&#39;, y = &#39;&gt;&#39;) remove_b &lt;- add_a add_b &lt;- remove_a hub106_postrad_b &lt;- hub106_postrad_b[!hub106_postrad_b %in% remove_b] hub106_postrad_b &lt;- c(hub106_postrad_b, add_b) hub106_postrad_a &lt;- unlist(sapply(hub106_postrad_a, l_g, kra_num = &#39;KRA-008&#39;, list_cells = man_select_files_edivisive$kra008)) hub106_postrad_b &lt;- unlist(sapply(hub106_postrad_b, l_g, kra_num = &#39;KRA-008&#39;, list_cells = man_select_files_edivisive$kra008)) hub106_postrad_c &lt;- unlist(sapply(hub106_postrad_c, l_g, kra_num = &#39;KRA-008&#39;, list_cells = man_select_files_edivisive$kra008)) length(man_select_files_edivisive$kra008) == length(hub106_postrad_a) + length(hub106_postrad_b) + length(hub106_postrad_c) # HUB106 # ###################################################################### ########################## # biological replicate 1 # ########################## # prerad # ########## hub062_prerad_a &lt;- c(257, 352) hub062_prerad_c &lt;- c(59, 99, 74, 105, 375, 112, 92) hub062_prerad_b &lt;- as.numeric(extract_other_cells(&#39;kra009&#39;, c(hub062_prerad_a, hub062_prerad_c))) hub062_prerad_a &lt;- unlist(sapply(hub062_prerad_a, l_g, kra_num = &#39;KRA-009&#39;, list_cells = man_select_files_edivisive$kra009)) hub062_prerad_b &lt;- unlist(sapply(hub062_prerad_b, l_g, kra_num = &#39;KRA-009&#39;, list_cells = man_select_files_edivisive$kra009)) hub062_prerad_c &lt;- unlist(sapply(hub062_prerad_c, l_g, kra_num = &#39;KRA-009&#39;, list_cells = man_select_files_edivisive$kra009)) length(man_select_files_edivisive$kra009) == length(hub062_prerad_a) + length(hub062_prerad_b) + length(hub062_prerad_c) # counting percentage of subclone a length(hub062_prerad_a) / (length(hub062_prerad_a) + length(hub062_prerad_b) + length(hub062_prerad_c)) *100 # postrad cycle 1 # ################### hub062_postrad_c &lt;- c(57, 19, 69, 139, 17, 160, 244) hub062_postrad_b &lt;- extract_square(man_select_files_edivisive$kra010, NULL, square = c(0.2, 0), x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub062_postrad_a &lt;- as.numeric(extract_other_cells(&#39;kra010&#39;, c(hub062_postrad_c, hub062_postrad_b))) hub062_postrad_a &lt;- unlist(sapply(hub062_postrad_a, l_g, kra_num = &#39;KRA-010&#39;, list_cells = man_select_files_edivisive$kra010)) hub062_postrad_b &lt;- unlist(sapply(hub062_postrad_b, l_g, kra_num = &#39;KRA-010&#39;, list_cells = man_select_files_edivisive$kra010)) hub062_postrad_c &lt;- unlist(sapply(hub062_postrad_c, l_g, kra_num = &#39;KRA-010&#39;, list_cells = man_select_files_edivisive$kra010)) length(man_select_files_edivisive$kra010) == length(hub062_postrad_a) + length(hub062_postrad_b) + length(hub062_postrad_c) # counting percentage of subclone a length(hub062_postrad_a) / (length(hub062_postrad_b) + length(hub062_postrad_b) + length(hub062_postrad_c)) *100 # postrad cycle 2 # ################### hub062_postrad_c2_c &lt;- c(221) hub062_postrad_c2_a &lt;- as.numeric(extract_other_cells(&#39;kra030&#39;, c(hub062_postrad_c2_c))) hub062_postrad_c2_c &lt;- unlist(sapply(hub062_postrad_c2_c, l_g, kra_num = &#39;KRA-030&#39;, list_cells = man_select_files_edivisive$kra030)) hub062_postrad_c2_a &lt;- unlist(sapply(hub062_postrad_c2_a, l_g, kra_num = &#39;KRA-030&#39;, list_cells = man_select_files_edivisive$kra030)) length(man_select_files_edivisive$kra030) == length(hub062_postrad_c2_c) + length(hub062_postrad_c2_a) ########################## # biological replicate 2 # ########################## # prerad # ######### hub062biological_prerad_b &lt;- extract_square(man_select_files_edivisive$kra028, NULL, square = c(0.1, -0.1), x = &#39;&lt;&#39;, y = &#39;&gt;&#39; ) hub062biological_prerad_c &lt;- extract_square(man_select_files_edivisive$kra028, NULL, square = c(0.1, 0.2), x = &#39;&gt;&#39;, y = &#39;&lt;&#39; ) hub062biological_prerad_a &lt;- extract_square(man_select_files_edivisive$kra028, NULL, square = c(0.1, -0.1), x = &#39;&lt;&#39;, y = &#39;&lt;&#39; ) hub062biological_prerad_a &lt;- unlist(sapply(hub062biological_prerad_a, l_g, kra_num = &#39;KRA-028&#39;, list_cells = man_select_files_edivisive$kra028)) hub062biological_prerad_b &lt;- unlist(sapply(hub062biological_prerad_b, l_g, kra_num = &#39;KRA-028&#39;, list_cells = man_select_files_edivisive$kra028)) hub062biological_prerad_c &lt;- unlist(sapply(hub062biological_prerad_c, l_g, kra_num = &#39;KRA-028&#39;, list_cells = man_select_files_edivisive$kra028)) length(man_select_files_edivisive$kra028) == length(hub062biological_prerad_a)+ length(hub062biological_prerad_b)+length(hub062biological_prerad_c) # postrad # ########### hub062biological_postrad_a &lt;- man_select_files_edivisive$kra032 # HUB106 # ###################################################################### # pre-rad # ########### hub015_prerad_b &lt;- c(233) hub015_prerad_a.b &lt;- extract_other_cells(&#39;kra023&#39;, c(hub015_prerad_b)) hub015_prerad_a.b &lt;- unlist(sapply(hub015_prerad_a.b, l_g, kra_num = &#39;KRA-023&#39;, list_cells = man_select_files_edivisive$kra023)) hub015_prerad_b &lt;- unlist(sapply(hub015_prerad_b, l_g, kra_num = &#39;KRA-023&#39;, list_cells = man_select_files_edivisive$kra023)) length(man_select_files_edivisive$kra023) == length(hub015_prerad_a.b) + length(hub015_prerad_b) # post-rad # ############ hub015_postrad_b &lt;- extract_square(man_select_files_edivisive$kra022, NULL, square = c(-0.1, 0.15), # kleiner # kleiner x = &#39;&lt;&#39;, y = &#39;&lt;&#39;) hub015_postrad_a.a &lt;- extract_square(man_select_files_edivisive$kra022, NULL, square = c(-0.1, 0), x = &#39;&gt;&#39;, # groter # kleiner y = &#39;&lt;&#39; ) hub015_postrad_a.b &lt;- extract_other_cells(&#39;kra022&#39;, c(hub015_postrad_b, hub015_postrad_a.a)) hub015_postrad_a.a &lt;- unlist(sapply(hub015_postrad_a.a, l_g, kra_num = &#39;KRA-022&#39;, list_cells = man_select_files_edivisive$kra022)) hub015_postrad_a.b &lt;- unlist(sapply(hub015_postrad_a.b, l_g, kra_num = &#39;KRA-022&#39;, list_cells = man_select_files_edivisive$kra022)) hub015_postrad_b &lt;- unlist(sapply(hub015_postrad_b, l_g, kra_num = &#39;KRA-022&#39;, list_cells = man_select_files_edivisive$kra022)) length(man_select_files_edivisive$kra022) == length(hub015_postrad_a.a) + length(hub015_postrad_a.b) + length(hub015_postrad_b) # HUB197 # ###################################################################### # prerad # ########## hub197_prerad_a &lt;- c(279, 240, 7, 242, 177, 372, 338, 255, 308, 209, 334, 153, 266, 181, 284, 238, 370, 275, 272, 362, 231, 355, 226, 269) hub197_prerad_b &lt;- c(364, 298, 47, 111, 74, 341, 369, 179, 371, 363, 270, 374, 368, 235, 259, 79, 197, 316, 365, 167) hub197_prerad_c &lt;- as.numeric(extract_other_cells(&#39;kra027&#39;, c(hub197_prerad_a, hub197_prerad_b))) hub197_prerad_a &lt;- unlist(sapply(hub197_prerad_a, l_g, kra_num = &#39;KRA-027&#39;, list_cells = man_select_files_edivisive$kra027)) hub197_prerad_b &lt;- unlist(sapply(hub197_prerad_b, l_g, kra_num = &#39;KRA-027&#39;, list_cells = man_select_files_edivisive$kra027)) hub197_prerad_c &lt;- unlist(sapply(hub197_prerad_c, l_g, kra_num = &#39;KRA-027&#39;, list_cells = man_select_files_edivisive$kra027)) length(man_select_files_edivisive$kra027) == length(hub197_prerad_a) + length(hub197_prerad_b) + length(hub197_prerad_c) # postrad # hub197_postrad_a &lt;- man_select_files_edivisive$kra026 # HUB181I # ###################################################################### # prerad # ########## hub181i_prerad_a &lt;- extract_square(man_select_files_edivisive$kra025, NULL, square = c(0, 0.1), # kleiner # kleiner x = &#39;&lt;&#39;, # groter # kleiner y = &#39;&lt;&#39; ) hub181i_prerad_b &lt;- extract_other_cells(&#39;kra025&#39;, c(hub181i_prerad_a)) hub181i_prerad_a &lt;- unlist(sapply(hub181i_prerad_a, l_g, kra_num = &#39;KRA-025&#39;, list_cells = man_select_files_edivisive$kra025)) hub181i_prerad_b &lt;- unlist(sapply(hub181i_prerad_b, l_g, kra_num = &#39;KRA-025&#39;, list_cells = man_select_files_edivisive$kra025)) length(man_select_files_edivisive$kra025) == length(hub181i_prerad_a) + length(hub181i_prerad_b) # postrad # ########### hub181i_postrad_a &lt;- extract_square(man_select_files_edivisive$kra024, NULL, square = c(-0.05, 0.15), # kleiner # kleiner x = &#39;&lt;&#39;, # groter # kleiner y = &#39;&lt;&#39; ) hub181i_postrad_b &lt;- as.numeric(extract_other_cells(&#39;kra024&#39;, c(hub181i_postrad_a))) hub181i_postrad_a &lt;- unlist(sapply(hub181i_postrad_a, l_g, kra_num = &#39;KRA-024&#39;, list_cells = man_select_files_edivisive$kra024)) hub181i_postrad_b &lt;- unlist(sapply(hub181i_postrad_b, l_g, kra_num = &#39;KRA-024&#39;, list_cells = man_select_files_edivisive$kra024)) length(man_select_files_edivisive$kra024) == length(hub181i_postrad_a) + length(hub181i_postrad_b) #################### # Subclone listing # #################### subclone_list &lt;- list(hub183_prerad_a, hub183_postrad_a, hub005_prerad_a.a, hub005_prerad_a.b, hub005_prerad_b, hub005_postrad_a.a, hub005_postrad_a.b, hub005_postrad_b, hub106_prerad_a, hub106_prerad_b, hub106_prerad_c, hub106_postrad_a, hub106_postrad_b, hub106_postrad_c, hub062_prerad_a, hub062_prerad_b,hub062_prerad_c, hub062_postrad_a, hub062_postrad_b,hub062_postrad_c, hub062_postrad_c2_a, hub062_postrad_c2_c, hub015_prerad_a.b, hub015_prerad_b, hub015_postrad_a.a, hub015_postrad_a.b, hub015_postrad_b, hub181i_prerad_a, hub181i_prerad_b, hub181i_postrad_a, hub181i_postrad_b, hub197_prerad_a, hub197_prerad_b, hub197_prerad_c, hub197_postrad_a, hub062biological_prerad_a,hub062biological_prerad_b,hub062biological_prerad_c, hub062biological_postrad_a ) names(subclone_list) &lt;- c(&#39;hub183_prerad_a&#39;, &#39;hub183_postrad_a&#39;, &#39;hub005_prerad_a.a&#39;, &#39;hub005_prerad_a.b&#39;, &#39;hub005_prerad_b&#39;, &#39;hub005_postrad_a.a&#39;, &#39;hub005_postrad_a.b&#39;, &#39;hub005_postrad_b&#39;, &#39;hub106_prerad_a&#39;, &#39;hub106_prerad_b&#39;, &#39;hub106_prerad_c&#39;, &#39;hub106_postrad_a&#39;, &#39;hub106_postrad_b&#39;, &#39;hub106_postrad_c&#39;, &#39;hub062_prerad_a&#39;, &#39;hub062_prerad_b&#39;, &#39;hub062_prerad_c&#39;, &#39;hub062_postrad_a&#39;, &#39;hub062_postrad_b&#39;, &#39;hub062_postrad_c&#39;, &#39;hub062_postrad_c2_a&#39;,&#39;hub062_postrad_c2_c&#39;, &#39;hub015_prerad_a.b&#39;, &#39;hub015_prerad_b&#39;, &#39;hub015_postrad_a.a&#39;, &#39;hub015_postrad_a.b&#39;, &#39;hub015_postrad_b&#39;, &quot;hub181i_prerad_a&quot;, &quot;hub181i_prerad_b&quot;, &quot;hub181i_postrad_a&quot;, &quot;hub181i_postrad_b&quot;, &quot;hub197_prerad_a&quot;, &quot;hub197_prerad_b&quot;, &quot;hub197_prerad_c&quot;, &quot;hub197_postrad_a&quot;, &#39;hub062biological_prerad_a&#39;,&#39;hub062biological_prerad_b&#39;,&#39;hub062biological_prerad_c&#39;, &#39;hub062biological_postrad_a&#39; ) 3.5.2 Subclone statistics # !!! This code was slightly adjusted so to run in Rmarkdown #################### # Subclone listing # #################### subclone_list &lt;- c(&#39;hub183_prerad_a&#39;, &#39;hub183_postrad_a&#39;, &#39;hub005_prerad_a.a&#39;, &#39;hub005_prerad_a.b&#39;, &#39;hub005_prerad_b&#39;, &#39;hub005_postrad_a.a&#39;, &#39;hub005_postrad_a.b&#39;, &#39;hub005_postrad_b&#39;, &#39;hub106_prerad_a&#39;, &#39;hub106_prerad_b&#39;, &#39;hub106_prerad_c&#39;, &#39;hub106_postrad_a&#39;, &#39;hub106_postrad_b&#39;, &#39;hub106_postrad_c&#39;, &#39;hub062_prerad_a&#39;, &#39;hub062_prerad_b&#39;, &#39;hub062_prerad_c&#39;, &#39;hub062_postrad_a&#39;, &#39;hub062_postrad_b&#39;, &#39;hub062_postrad_c&#39;, &#39;hub062_postrad_c2_a&#39;,&#39;hub062_postrad_c2_c&#39;, &#39;hub015_prerad_a.b&#39;, &#39;hub015_prerad_b&#39;, &#39;hub015_postrad_a.a&#39;, &#39;hub015_postrad_a.b&#39;, &#39;hub015_postrad_b&#39;, &quot;hub181i_prerad_a&quot;, &quot;hub181i_prerad_b&quot;, &quot;hub181i_postrad_a&quot;, &quot;hub181i_postrad_b&quot;, &quot;hub197_prerad_a&quot;, &quot;hub197_prerad_b&quot;, &quot;hub197_prerad_c&quot;, &quot;hub197_postrad_a&quot;, &#39;hub062biological_prerad_a&#39;,&#39;hub062biological_prerad_b&#39;,&#39;hub062biological_prerad_c&#39;, &#39;hub062biological_postrad_a&#39; ) ############## # Statistics # ############## # extract only prerad subclones bl &lt;- subclone_list[grep(pattern = &#39;prerad&#39;, subclone_list)] # remove biological replicate bl &lt;- bl[1:(length(bl)-3)] # cell line list cline &lt;- c(&#39;hub183&#39;, &#39;hub005&#39;, &#39;hub106&#39;, &#39;hub062&#39;, &#39;hub015&#39;, &#39;hub197&#39;) subclones_per_organoids &lt;- unlist(lapply(cline, function(x){ length(grep(x, bl)) })) # note that 005 and 015 have sub sub clone (variance less than 5%) so we should see them as one. # hub005 subclones_per_organoids[2] &lt;- subclones_per_organoids[2] - 1 # computing mean number of clones per organoid mean(subclones_per_organoids) ## [1] 2.333333 # computing standard deviation of clones per organoids sd(subclones_per_organoids) ## [1] 0.8164966 3.6 Single cell copy number heatmap plots ######## # Data # ######## load(&#39;..cna/analysis/rda/subclonal_dynamics/subclone_list.rda&#39;) ####### # Run # ####### # list of patterns to grepl unique sets clines &lt;- c(&#39;hub183&#39;, &#39;hub005&#39;, &#39;hub106&#39;, &#39;hub062_&#39;, &#39;hub015&#39;, &#39;hub181i&#39;,&#39;hub197&#39;, &#39;hub062biological&#39;) subclone_classes &lt;- lapply(clines, subclone_classes_for_genomeheatmap, list_of_subclones = subclone_list) ######## # Save # ######## save(subclone_classes, file = &#39;../cna_analysis/rda/subclonal_dynamics/subclone_classes.rda&#39;) ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/man_select_files_edivisive.rda&#39;) load(&#39;../cna_analysis/rda/subclonal_dynamics/subclone_classes.rda&#39;) ######### # Paths # ######### paths &lt;- &#39;figs/subclonal_dynamics&#39; # HUB183 # ###################################################################### # prerad # hub183_prerad &lt;- subclone_classes[[1]][grepl(subclone_classes[[1]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub183_prerad$path, path = paths, classes_daan = hub183_prerad$class, class.col = c(&quot;#C6CDF7&quot;), name = &#39;hub183_gwh_prerad&#39; ) HUB183 baseline hub183_postrad &lt;- subclone_classes[[1]][grepl(subclone_classes[[1]]$class, pattern = &#39;postrad&#39;), ] # postrad # genomeheatmap( selected.files = hub183_postrad$path, path = paths, classes_daan = hub183_postrad$class, class.col = c(&quot;#C6CDF7&quot;), name = &#39;hub183_gwh_postrad&#39; ) HUB183 recurrence # HUB005 # ###################################################################### # prerad # hub005_prerad &lt;- subclone_classes[[2]][grepl(subclone_classes[[2]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub005_prerad$path, path = paths, classes_daan = hub005_prerad$class, name = &#39;hub005_gwh_prerad&#39;, class.col = c(&quot;#046C9A&quot;, #darkblue &#39;#809aa6&#39;, # greyblue &quot;#D69C4E&quot;) # brown ) HUB005 baseline # postrad # hub005_postrad &lt;- subclone_classes[[2]][grepl(subclone_classes[[2]]$class, pattern = &#39;postrad&#39;), ] genomeheatmap( selected.files = hub005_postrad$path, path = paths, classes_daan = hub005_postrad$class, name = &#39;hub005_gwh_postrad&#39;, class.col = c(&#39;#046C9A&#39;, &#39;#809aa6&#39;, &#39;#D69C4E&#39; )) HUB005 recurrence # HUB106 # ###################################################################### # prerad # hub106_prerad &lt;- subclone_classes[[3]][grepl(subclone_classes[[3]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub106_prerad$path, path = paths, classes_daan = hub106_prerad$class, name = &#39;hub106_gwh_prerad&#39;, class.col = c(&quot;#E6A0C4&quot;, # pink &quot;#7294D4&quot;, # blue &quot;#D8A499&quot;) #brownpink ) HUB106 baseline # postrad # hub106_postrad &lt;- subclone_classes[[3]][grepl(subclone_classes[[3]]$class, pattern = &#39;postrad&#39;), ] genomeheatmap( selected.files = hub106_postrad$path, path = paths, classes_daan = hub106_postrad$class, name = &#39;hub106_gwh_postrad&#39;, class.col = c(&quot;#E6A0C4&quot;, # pink &quot;#7294D4&quot;, # blue &quot;#D8A499&quot;) #brownpink) ) HUB106 recurrence # HUB062 # ###################################################################### ### Biological replicate 1 ### # prerad # hub062_prerad &lt;- subclone_classes[[4]][grepl(subclone_classes[[4]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub062_prerad$path, path = paths, classes_daan = hub062_prerad$class, name = &#39;hub062_gwh_prerad&#39;, class.col = c(&quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;, #brownish &quot;#F1BB7B&quot;) # orange ) HUB062 baseline # postrad cycle 1 # hub062_postrad &lt;- subclone_classes[[4]][grepl(subclone_classes[[4]]$class, pattern = &#39;postrad&#39;), ] # remove postrad_c2 hub062_postrad &lt;- hub062_postrad[!grepl(hub062_postrad$class, pattern = &#39;postrad_c2&#39;), ] genomeheatmap( selected.files = hub062_postrad$path, path = paths, name = &#39;hub062_gwh_postrad_c1&#39;, classes_daan = hub062_postrad$class, class.col = c(&quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;, #brownish &quot;#F1BB7B&quot;) # orange ) HUB062 recurrence hub062_postrad_c2 &lt;- subclone_classes[[4]][grepl(subclone_classes[[4]]$class, pattern = &#39;postrad_c2&#39;), ] # postrad cycle 2 # genomeheatmap( selected.files = hub062_postrad_c2$path, path = paths, name = &#39;hub062_gwh_postrad_c2&#39;, classes_daan = hub062_postrad_c2$class, class.col = c(&quot;#FD6467&quot;, # pinkish red &quot;#F1BB7B&quot;) # orange ) HUB062 recurrence Cycle 2 # prerad # hub062_biological_prerad &lt;- subclone_classes[[8]][grepl(subclone_classes[[8]]$class, pattern = &#39;prerad&#39;),] genomeheatmap(selected.files = hub062_biological_prerad$path, path = paths, classes_daan= hub062_biological_prerad$class, name = &#39;hub062_gwh_prerad_rep2&#39;, class.col = c( &quot;#FD6467&quot;, # pinkish red &quot;#5B1A18&quot;, #brownish &quot;#F1BB7B&quot; #orange like )) HUB062 baseline rep2 # postrad # hub062_biological_postrad &lt;- subclone_classes[[8]][grepl(subclone_classes[[8]]$class, pattern = &#39;postrad&#39;),] genomeheatmap(selected.files = hub062_biological_postrad$path, path = paths, name = &#39;hub062_gwh_postrad_rep2&#39;, classes_daan= hub062_biological_postrad$class, class.col = c( &quot;#FD6467&quot; )) HUB062 recurrence rep2 # HUB015 # ###################################################################### # prerad # hub015_prerad &lt;- subclone_classes[[5]][grepl(subclone_classes[[5]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub015_prerad$path, path = paths, classes_daan = hub015_prerad$class, name = &#39;hub015_gwh_prerad&#39;, class.col = c(&#39;#E1AF00&#39;, &#39;#F21A00&#39;) ) HUB015 baseline # postrad hub015_postrad &lt;- subclone_classes[[5]][grepl(subclone_classes[[5]]$class, pattern = &#39;postrad&#39;), ] genomeheatmap( selected.files = hub015_postrad$path, path = paths, classes_daan = hub015_postrad$class, name = &#39;hub015_gwh_postrad&#39;, class.col = c(&#39;#f5de90&#39;, &#39;#E1AF00&#39;, &#39;#F21A00&#39;)) HUB015 recurrence # HUB197 # ###################################################################### # prerad # hub197_prerad &lt;- subclone_classes[[7]][grepl(subclone_classes[[7]]$class, pattern = &#39;prerad&#39;), ] genomeheatmap( selected.files = hub197_prerad$path, path = paths, classes_daan = hub197_prerad$class, name = &#39;hub197_gwh_prerad&#39;, class.col = c(&quot;#35274A&quot;, # purp &quot;#E1BD6D&quot;, # sand &#39;#0B775E&#39; # green ) ) HUB197 baseline # postrad # hub197_postrad &lt;- subclone_classes[[7]][grepl(subclone_classes[[7]]$class, pattern = &#39;postrad&#39;), ] genomeheatmap( selected.files = hub197_postrad$path, path = paths, name = &#39;hub197_gwh_postrad&#39;, classes_daan = hub197_postrad$class, class.col = c(&quot;#35274A&quot;) ) HUB197 recurrence 3.7 Fisher’s test ######## # Data # ######## load(&#39;../cna_analysis/rda/subclonal_dynamics/subclone_classes.rda&#39;) ####### # Run # ####### # For HUB183, Fisher&#39;s test will produces an error, because HUB183 has only 1 subclone before and after treatment # Computing Fisher&#39;s exact test to compare HUB005 prerad versus postrad HUB005 &lt;- perform_fisher( subclone_classes[[2]], population1 = unique(subclone_classes[[2]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[2]]$class))], population2 = unique(subclone_classes[[2]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[2]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB106 prerad versus postrad HUB106 &lt;- perform_fisher( subclone_classes[[3]], population1 = unique(subclone_classes[[3]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[3]]$class))], population2 = unique(subclone_classes[[3]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[3]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB062 prerad versus HUB062 postrad cycle 1 HUB062_cycle1 &lt;- perform_fisher( subclone_classes[[4]], population1 = unique(subclone_classes[[4]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[4]]$class))], population2 = unique(subclone_classes[[4]]$class)[!grepl(&#39;prerad|postrad_c2&#39;, unique(subclone_classes[[4]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB062 postrad cycle 1 versus HUB062 postrad cycle 1 HUB062_cycle2 &lt;- perform_fisher( subclone_classes[[4]], population1 = unique(subclone_classes[[4]]$class)[!grepl(&#39;prerad|postrad_c2&#39;, unique(subclone_classes[[4]]$class))], population2 = unique(subclone_classes[[4]]$class)[grepl(&#39;postrad_c2&#39;, unique(subclone_classes[[4]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB015 prerad versus postrad HUB015 &lt;- perform_fisher( subclone_classes[[5]], population1 = unique(subclone_classes[[5]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[5]]$class))], population2 = unique(subclone_classes[[5]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[5]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB197 prerad versus postrad HUB197 &lt;- perform_fisher( subclone_classes[[7]], population1 = unique(subclone_classes[[7]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[7]]$class))], population2 = unique(subclone_classes[[7]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[7]]$class))] ) # Computing Fisher&#39;s exact test to compare HUB062 prerad versus postrad in biological replicate 2 HUB062_replicate2 &lt;- perform_fisher( subclone_classes[[7]], population1 = unique(subclone_classes[[7]]$class)[grepl(&#39;prerad&#39;, unique(subclone_classes[[7]]$class))], population2 = unique(subclone_classes[[7]]$class)[grepl(&#39;postrad&#39;, unique(subclone_classes[[7]]$class))] ) ############################ # Multiple test correction # ############################ # comparing pre and post rad for all the rest p_val_rest &lt;- c(NA, HUB005, HUB106, HUB062_cycle1, HUB062_cycle2, HUB015, HUB197, HUB062_replicate2) org_names &lt;- c(&#39;HUB183&#39;, &#39;HUB005&#39;, &#39;HUB106&#39;, &#39;HUB062_cycle1&#39;, &#39;HUB062_cycle2&#39;, &#39;HUB015&#39;, &#39;HUB197&#39;, &#39;HUB062_replicate2&#39;) p_val_adjust &lt;- p.adjust(p_val_rest, method = &#39;bonferroni&#39;, n = length(p_val_rest)) names(p_val_adjust) &lt;- org_names p_val_adjust ## HUB183 HUB005 HUB106 HUB062_cycle1 HUB062_cycle2 HUB015 HUB197 ## NA 1.000000e+00 2.015762e-02 1.564551e-17 1.162420e-26 6.787625e-03 1.989615e-71 ## HUB062_replicate2 ## 1.989615e-71 ####### # END # ####### "],["copy-number-analyses.html", "4 Copy number analyses", " 4 Copy number analyses "],["copy-number-pattern-analyses.html", "5 Copy number pattern analyses", " 5 Copy number pattern analyses "],["source-code.html", "6 Source code 6.1 AUC_rad script: ‘AUC_fun’ function 6.2 fitter_rad script: ‘fitter’ function 6.3 ic50_rad script: ‘IC50_fun’ function 6.4 relativize_dr script: ‘relative’ function 6.5 quality_functions script: ‘quality_check’, ‘quality_select’ and ‘check_quality’ functions 6.6 plot_pca_kmeans script: ‘draw_pca’, ‘k_cluster’, ‘draw_pca_double’ and ‘k_cluster_double’ functions 6.7 divide_subclone_functions script: ‘extract_other_cells’, ‘extract_square’, ‘l_g’ and ‘subclone_classes_for_genomeheatmap’ functions 6.8 plot_genomeheatmap script: ‘genomeheatmap’ function 6.9 fisher_test script: ‘perform_fisher’ function", " 6 Source code The source code in this here is arranged in a loose chronological order, reflecting the sequence in which it is called in the scripts presented throughout this book. 6.1 AUC_rad script: ‘AUC_fun’ function # returns the AUC of the actual data. AUC_fun &lt;- function(df) { # defining variables to work with d &lt;- df lines &lt;- character() # for loop, checks if CF$cline is in vector lines, if so, do nothing, else append to vector. for (line in d$cline) ( ifelse(line %in% lines, NA, lines &lt;- c(lines, line))) # separate into dataframes according to cline per_line &lt;- split(d, f = d$cline, drop = TRUE) # define dose_vetor dose_vector &lt;- unique(d$dose) # computes AUC for given predicted survival and dose given by dose_vector AUC_calc &lt;- function(df) { # extract actual data rel_mean &lt;- df$relative_mean # extracts number of experiemnts n &lt;- length(unique(d$Exp)) #remove 2th and 3th number (are duplicates) rel_mean &lt;- rel_mean[seq(1, length(rel_mean), n)] # compute maximal max_AUC &lt;- max(dose_vector)*1 #compute AUC act_AUC &lt;- AUC(x=dose_vector, y = rel_mean) # make dataframe datafr &lt;- data.frame(max_AUC = max_AUC, act_AUC = act_AUC, rel_AUC = act_AUC/max_AUC, expcode = unique(df$expcode), cline= unique(df$cline), treatment = unique(df$treatment ) ) return(datafr) } # Store in vector AUC_vector &lt;- lapply(per_line, AUC_calc) #merge dataframes df = do.call(rbind, AUC_vector) return(df) } 6.2 fitter_rad script: ‘fitter’ function fitter &lt;- function(df) { # defining variables to work with d &lt;- df lines &lt;- character() # for loop, checks if CF$cline is in vector lines, if so, do nothing, else append to vector. for (line in d$cline) ( ifelse(line %in% lines, NA, lines &lt;- c(lines, line))) # separate into dataframes according to cline per_line &lt;- split(d, f = d$cline, drop = TRUE) # Function to make model for every line and dataframe with predicted data for each line. fit_model= function(line) { # line is a dataframe. Outputs the fits of norm and dose fit &lt;- drm(relative ~ dose, # define y -axis (ncolonies) and x-axis (dose) data = line, # defines dataframe fct = LL.4 (names = c(&#39;Slope&#39;, &quot;Lower Limit&quot;, &quot;Upper Limit&quot;, &quot;IC50&quot;))) # defines to fit a log-losistic model) newdata &lt;- expand.grid(dose=exp(seq(log(0.00000001), log(max(df$dose) + 1000), length=1000))) # new data with doses. Note: lowest dose is not # log 0 but log(&#39;very small number&#39;) because otherwise this will hamper the scaling in ggplot later on. pm &lt;- predict(fit, newdata=newdata, interval=&quot;confidence&quot;) # new data with predictions and confidence intervals newdata$pred &lt;- pm[,1] # add prediction values to new data. newdata$predmin &lt;- pm[,2] # add lower bounderies to new data newdata$predmax &lt;- pm[,3] # add upper bounderies to new data newdata$cline &lt;- line$cline[1] # add column with cline. newdata$expcode = unique(df$expcode) return(newdata) } # Store in vector data_frames &lt;- lapply(per_line, fit_model) #merge dataframes df = do.call(rbind, data_frames) return(df) } 6.3 ic50_rad script: ‘IC50_fun’ function IC50_fun &lt;- function(df, rad) { # defining variables to work with ifelse(is.null(rad), d&lt;-df, d &lt;- subset(df, rec_rad == rad)) lines &lt;- character() # for loop, checks if CF$cline is in vector lines, if so, do nothing, else append to vector. for (line in d$cline) ( ifelse(line %in% lines, NA, lines &lt;- c(lines, line))) # separate into dataframes according to cline per_line &lt;- split(d, f = d$cline, drop =TRUE) # Function to make model for every line and dataframe with predicted data for each line. ic50= function(line) { # line is a dataframe. Outputs the fits of norm and dose fit &lt;- drm(relative ~ dose, # define y -axis (ncolonies) and x-axis (dose) data = line, # defines dataframe fct = LL.4 (names = c(&#39;Slope&#39;, &quot;Lower Limit&quot;, &quot;Upper Limit&quot;, &quot;IC50&quot;))) # defines to fit a log-losistic model) return(coef(fit)[4]) } # Store in vector IC50_vector &lt;- lapply(per_line, ic50) #merge dataframes df = do.call(rbind, IC50_vector) return(df) } 6.4 relativize_dr script: ‘relative’ function relative &lt;- function(df, rad) { #&#39; @param df with dose response data and columns cline, dose, Exp, #&#39; rec_rad, expcode, ncolonies #&#39; @param rad if line received radiation (T or F), stored in column rec_rad #&#39; @return relativized data where dose = 0 is used as 100% # defining variables to work with ifelse(rad == T, d&lt;-subset(df, rec_rad == 1), d&lt;-subset(df, rec_rad == 0) ) # define ncolonies column &lt;- &quot;ncolonies&quot; # Extracts the column name. col &lt;- d[c(column)] # extracts number of experiemnts n &lt;- length(unique(d$Exp)) # Takes mean every nth row mean_fun &lt;- function(x) { m &lt;- mean(x, na.rm = TRUE) return(m) } mean &lt;- aggregate(col,list(rep(1:(nrow(col)%/%n+1),each=n,len=nrow(col))), mean_fun)[-1] # Duplicates (n=2) or triplicates (n=3) the rows. mean &lt;- mean[rep(seq_len(nrow(mean)), each = n), ] # Adds everything to the dataframe. d[&quot;mean&quot;] &lt;- mean # Select mean values of 0 concentration d &lt;- d %&gt;% group_by(cline) %&gt;% arrange(cline,dose) first &lt;- d[d$dose==0, ] %&gt;% dplyr::select(cline, value100=mean) # Make cline a factor d$cline&lt;-factor(d$cline) # Merge first original (d) d &lt;- d %&gt;% merge(first,by=c(&quot;cline&quot;)) # Extract only every nth row. d = d[seq(1, nrow(d), n), ] # make new column with relative, called relative d$relative = d$ncolonies/d$value100 d$relative_mean = d$mean/d$value100 d&lt;-subset(d, select=-c(mean,value100)) # compute relative standard error of the mean # define the column with sem in it column &lt;- &quot;relative&quot; # Extracts the column name. col &lt;- d[c(column)] sem_fun &lt;- function(x) { std &lt;- sd(x, na.rm = TRUE) vector &lt;- na.omit(x) sem &lt;- std/sqrt(length(vector)) return(sem) } sem &lt;- aggregate(col,list(rep(1:(nrow(col)%/%n+1),each=n,len=nrow(col))),sem_fun)[-1] sem &lt;- sem[rep(seq_len(nrow(sem)), each = n), ] d[&quot;relative_sem&quot;] &lt;- sem return(d) } 6.5 quality_functions script: ‘quality_check’, ‘quality_select’ and ‘check_quality’ functions quality_check &lt;- function(inputdir, model) { #&#39; @param inputdir is directory containing the standard aneufinder output for each plate #&#39; model is which model to use for the quality check: either dnacopy, edivisive or HMM #&#39; quality_check will make quality metrics for each plate #&#39; quality_check assumes that rdaBaseDirectory contains folder with models for each plate #&#39; each plate folder has to contain a MODEL folder and a method-&#39;dnacopy, edivisive, or HMM&#39; folder #&#39; @example quality_check(inputdir = rdaBaseDirectory, model = &#39;edivisive&#39;) # go to folder with appropiate files rda_folder &lt;- paste0(inputdir, &#39;/MODELS&#39;, &#39;/method-&#39;, model) # extract files rda_files &lt;- list.files(rda_folder, full.names = TRUE) # run quality check on each file cl &lt;- clusterByQuality( rda_files, measures = c( &#39;spikiness&#39;, &#39;num.segments&#39;, &#39;entropy&#39;, &#39;bhattacharyya&#39;, &#39;sos&#39; ) ) return(cl) } quality_select &lt;- function(cl, spik, bhat) { #&#39; selects all files that meets the defined quality requirements #&#39; @param cl output of the clusterByQuality function in AneuFinder #&#39; @param spik the spikiness treshhold. All clusters with spikiness above #&#39; the treshold will be removed #&#39; @param bhat the bhattacharrya score. All clusters with bhattacharrya below #&#39; the treshold will be removed #&#39; @return returns a vector of selected files paths # convert to df to allow easy wrangling cl_df &lt;- as.data.frame(cl$parameters) # remove higher than spik spik &lt;- subset(cl_df, spikiness &lt; spik) # remove lower than bhat spik_bhat &lt;- subset(spik, bhattacharyya &gt; bhat) cluster_n &lt;- nrow(spik_bhat) # create vector of selected files selected.files &lt;- unlist(cl$classification[0:cluster_n]) return(selected.files) } check_quality &lt;- function(cl) { return(cl$parameters) } } 6.6 plot_pca_kmeans script: ‘draw_pca’, ‘k_cluster’, ‘draw_pca_double’ and ‘k_cluster_double’ functions draw_pca &lt;- function(list_files1, list_files2, size, legend_position, baseline_kra, recurrence_kra, ssdna004 = F) { cells &lt;- c(list_files1, list_files2) df &lt;- plot_pca( cells, colorBy = classes, PC1 = 1, PC2 = 2, plot = F ) df$class &lt;- str_extract(rownames(df), &#39;KRA-0\\\\d+&#39;) num &lt;- str_extract(rownames(df), &#39;_\\\\d+\\\\.&#39;) num &lt;- str_remove_all(num, pattern = &#39;\\\\.&#39;) df$label &lt;- paste0(df$class, num) pc1 &lt;- colnames(df)[1] pc2 &lt;- colnames(df)[2] colnames(df) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;, &#39;class&#39;, &#39;label&#39;) col_vals &lt;- ifelse(ssdna004 == T, list(c(&quot;#D69C4E&quot;, &quot;#999999&quot;)), list(c(&quot;#999999&quot;, &quot;#D69C4E&quot;))) label_vals &lt;- ifelse(ssdna004 == T, list(c(&#39;Recurrence&#39;, &#39;Baseline&#39;)), list(c(&#39;Baseline&#39;, &#39;Recurrence&#39;))) p &lt;- ggplot(data = df, aes(label = label)) + geom_point(size = size, aes(x = PC1, y = PC2, col = class)) + # scale_color_manual(values = c(&quot;#FFDB6D&quot;, &quot;#00AFBB&quot;)) + scale_color_manual( name = &#39;&#39;, values = col_vals[[1]], labels = label_vals[[1]] ) + # or consider &#39;#9e1303&#39; for second cycle of recurrence theme_cowplot() + theme(legend.position = legend_position, text = element_text(size = 17), axis.text = element_text(size = 15)) + labs(x = pc1, y = pc2) p # ggplotly(p) } k_cluster &lt;- function(list_files1, list_files2, cluster_n, cols, labels, legend_position, normalize, return_elbow = F) { require(factoextra) cells &lt;- c(list_files1, list_files2) df12 &lt;- plot_pca( cells, colorBy = classes, PC1 = 1, PC2 = 2, plot = F ) df34 &lt;- plot_pca( cells, colorBy = classes, PC1 = 3, PC2 = 4, plot = F ) df56 &lt;- plot_pca( cells, colorBy = classes, PC1 = 5, PC2 = 6, plot = F ) df78 &lt;- plot_pca( cells, colorBy = classes, PC1 = 7, PC2 = 8, plot = F ) df910 &lt;- plot_pca( cells, colorBy = classes, PC1 = 9, PC2 = 10, plot = F ) df &lt;- cbind(df12, df34, df56, df78, df910) if (normalize) { # extract variance explained for each pca pca_var &lt;- as.numeric(str_match(colnames(df), &quot;\\\\(\\\\s*(.*?)\\\\s*%&quot;)[, 2]) for (i in 1:length(pca_var)) { # calculate normalized pca values norm_pca &lt;- df[, i] / 100 * pca_var[i] #repopulate the dataframe df[, i] &lt;- norm_pca } } #check best k for k-means clustering method if (return_elbow) { return(fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;) + labs(subtitle = &quot;Elbow method&quot;)) } # # # fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;)+ # labs(subtitle = &quot;Silhouette method&quot;) # # fviz_nbclust(df, kmeans, nstart = 25, method = &quot;gap_stat&quot;, nboot = 50)+ # labs(subtitle = &quot;Gap statistic method&quot;) # compute k-means clustering set.seed(1) res.km &lt;- kmeans(df, cluster_n, nstart = 1000) # change colnames so it works for our plot df12$class &lt;- str_extract(rownames(df12), &#39;KRA-0\\\\d+&#39;) num &lt;- str_extract(rownames(df), &#39;_\\\\d+\\\\.&#39;) num &lt;- str_remove_all(num, pattern = &#39;\\\\.&#39;) df12$label &lt;- paste0(df12$class, num) pc1 &lt;- colnames(df12)[1] pc2 &lt;- colnames(df12)[2] colnames(df12) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;, &#39;class&#39;, &#39;label&#39;) # plot nicely p &lt;- ggplot(data = df12, aes(label = label)) + geom_point(alpha = 1.0, aes( x = PC1, y = PC2, col = as.factor(res.km$cluster) )) + theme_cowplot() + labs(x = pc1, y = pc2) + scale_color_manual(labels = labels, values = cols, name = &quot;Clone&quot;) + theme(legend.position = legend_position, text = element_text(size = 17), axis.text = element_text(size = 15)) return(p) #ggplotly(p) } draw_pca_double &lt;- function(list_files1, list_files2, list_files3, size, legend_position) { cells &lt;- c(list_files1, list_files2, list_files3) df &lt;- plot_pca( cells, colorBy = classes, PC1 = 1, PC2 = 2, plot = F ) df$class &lt;- str_extract(rownames(df), &#39;KRA-0\\\\d+&#39;) num &lt;- str_extract(rownames(df), &#39;_\\\\d+\\\\.&#39;) num &lt;- str_remove_all(num, pattern = &#39;\\\\.&#39;) df$label &lt;- paste0(df$class, num) pc1 &lt;- colnames(df)[1] pc2 &lt;- colnames(df)[2] colnames(df) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;, &#39;class&#39;, &#39;label&#39;) p &lt;- ggplot(data = df, aes(label = label)) + geom_point(size = size, aes(x = PC1, y = PC2, col = class)) + # scale_color_manual(values = c(&quot;#FFDB6D&quot;, &quot;#00AFBB&quot;)) + scale_color_manual( name = &#39;&#39;, values = c(&quot;#999999&quot;, &quot;#D69C4E&quot;, &#39;#d65c4e&#39;), labels = c(&#39;Baseline&#39;, &#39;Recurrence Cycle 1&#39;, &#39;Recurrence Cycle 2&#39;) ) + # or consider &#39;#9e1303&#39; for second cycle of recurrence theme_cowplot() + theme(legend.position = legend_position, text = element_text(size = 17), axis.text = element_text(size = 15)) + labs(x = pc1, y = pc2) return(p) # ggplotly(p) } k_cluster_double &lt;- function(list_files1, list_files2, list_files3, cluster_n, cols, labels, legend_position, normalize, return_elbow = F) { require(factoextra) cells &lt;- c(list_files1, list_files2, list_files3) df12 &lt;- plot_pca( cells, colorBy = classes, PC1 = 1, PC2 = 2, plot = F ) df34 &lt;- plot_pca( cells, colorBy = classes, PC1 = 3, PC2 = 4, plot = F ) df56 &lt;- plot_pca( cells, colorBy = classes, PC1 = 5, PC2 = 6, plot = F ) df78 &lt;- plot_pca( cells, colorBy = classes, PC1 = 7, PC2 = 8, plot = F ) df910 &lt;- plot_pca( cells, colorBy = classes, PC1 = 9, PC2 = 10, plot = F ) df &lt;- cbind(df12, df34, df56, df78, df910) if (normalize) { # extract variance explained for each pca pca_var &lt;- as.numeric(str_match(colnames(df), &quot;\\\\(\\\\s*(.*?)\\\\s*%&quot;)[, 2]) for (i in 1:length(pca_var)) { # calculate normalized pca values norm_pca &lt;- df[, i] / 100 * pca_var[i] #repopulate the dataframe df[, i] &lt;- norm_pca } } #check best k for k-means clustering method if (return_elbow) { return(fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;) + labs(subtitle = &quot;Silhouette method&quot;)) } # # # fviz_nbclust(df, kmeans, method = &quot;silhouette&quot;)+ # labs(subtitle = &quot;Silhouette method&quot;) # # fviz_nbclust(df, kmeans, nstart = 25, method = &quot;gap_stat&quot;, nboot = 50)+ # labs(subtitle = &quot;Gap statistic method&quot;) # compute k-means clustering set.seed(1) res.km &lt;- kmeans(df, cluster_n, nstart = 1000) # change colnames so it works for our plot df12$class &lt;- str_extract(rownames(df12), &#39;KRA-0\\\\d+&#39;) num &lt;- str_extract(rownames(df), &#39;_\\\\d+\\\\.&#39;) num &lt;- str_remove_all(num, pattern = &#39;\\\\.&#39;) df12$label &lt;- paste0(df12$class, num) pc1 &lt;- colnames(df12)[1] pc2 &lt;- colnames(df12)[2] colnames(df12) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;, &#39;class&#39;, &#39;label&#39;) # plot nicely p &lt;- ggplot(data = df12, aes(label = label)) + geom_point(alpha = 1.0, aes( x = PC1, y = PC2, col = as.factor(res.km$cluster) )) + theme_cowplot() + labs(x = pc1, y = pc2) + scale_color_manual(labels = labels, values = cols, name = &quot;Clone&quot;) + theme(legend.position = legend_position, text = element_text(size = 17), axis.text = element_text(size = 15)) p } } 6.7 divide_subclone_functions script: ‘extract_other_cells’, ‘extract_square’, ‘l_g’ and ‘subclone_classes_for_genomeheatmap’ functions extract_other_cells &lt;- function(kra_name, list_of_subclones) { i &lt;- which(names(man_select_files_edivisive) == kra_name) all &lt;- str_extract(man_select_files_edivisive[[i]], &#39;_\\\\d+\\\\.&#39;) %&gt;% str_remove(&#39;_&#39;) %&gt;% str_remove(&#39;\\\\.&#39;) rest &lt;- all[which(!all %in% list_of_subclones)] return(rest) } extract_square &lt;- function(list_files1, list_files2, square, x, y) { # extracts all cells that lie within a square of a pca plot defined by # user. For example square c(0.1, 0.0) will extract all cells with # pc1 lower or higher that 0.1 and pc2 lower or higher than 0.0. User has to rearange functon # if he wants x lower or higher than 0.1 cells &lt;- c(list_files1, list_files2) df12 &lt;- plot_pca(cells, colorBy = classes, PC1=1, PC2=2, plot = F) colnames(df12) &lt;- c(&#39;PC1&#39;, &#39;PC2&#39;) # extracting dataframe with correct square if(x == &#39;&lt;&#39; &amp; y == &#39;&lt;&#39;) { df12 &lt;- subset(df12, PC1 &lt; square[1] &amp; PC2 &lt; square[2]) } if(x == &#39;&lt;&#39; &amp; y == &#39;&gt;&#39;) { df12 &lt;- subset(df12, PC1 &lt; square[1] &amp; PC2 &gt; square[2]) } if(x == &#39;&gt;&#39; &amp; y == &#39;&lt;&#39;) { df12 &lt;- subset(df12, PC1 &gt; square[1] &amp; PC2 &lt; square[2]) } if(x == &#39;&gt;&#39; &amp; y == &#39;&gt;&#39;) { df12 &lt;- subset(df12, PC1 &gt; square[1] &amp; PC2 &gt; square[2]) } # numbers is: cell_id &lt;- str_extract(rownames(df12), &#39;_\\\\d+\\\\.&#39;) %&gt;% str_remove(&#39;_&#39;) %&gt;% str_remove(&#39;\\\\.&#39;) return(cell_id) } l_g &lt;- function(x, kra_num, list_cells) { select &lt;- grepl(paste0(kra_num,&#39;_&#39;,x,&quot;\\\\.&quot;), list_cells) i &lt;- which(select) return(list_cells[i]) } subclone_classes_for_genomeheatmap &lt;- function(list_of_subclones, cline) { #&#39; @param #&#39; list of subclones is the full list of rda files that have been assigned a subclone_classes_for_genomeheatmap #&#39; cline is the line (hub005, hub183 etc.) #&#39; rad is either prerad or rad #&#39; @return #&#39; returns a vector with that assigns a subclone extract_subclones &lt;- list_of_subclones[grepl(names(list_of_subclones), pattern = paste0(cline))] size_subclones &lt;- lapply(extract_subclones, length) classes &lt;- rep(names(size_subclones), size_subclones) df &lt;- data.frame(path = unlist(extract_subclones), class = classes) return(df) } 6.8 plot_genomeheatmap script: ‘genomeheatmap’ function genomeheatmap &lt;- function(selected.files, path, classes_daan = NULL, class.col = NULL, dendogram = F, daan_colours = T, name) { # This code was adapted from the AneuFinder package # plots and saves genome heatmap of selected.files # @param # selected.files: vector of location of selected files. # output path: path were plots should be saved. # name: how you want to name the plot # get platename platename &lt;- str_extract(selected.files[1], &#39;KRA-0\\\\d+&#39;) # AneuFinder functions: startTimedMessage &lt;- function(...) { x &lt;- paste0(..., collapse=&#39;&#39;) message(x, appendLF=FALSE) ptm &lt;- proc.time() return(ptm) } transCoord &lt;- function (gr) { cum.seqlengths &lt;- cumsum(as.numeric(seqlengths(gr))) cum.seqlengths.0 &lt;- c(0, cum.seqlengths[-length(cum.seqlengths)]) names(cum.seqlengths.0) &lt;- seqlevels(gr) gr$start.genome &lt;- start(gr) + cum.seqlengths.0[as.character(seqnames(gr))] gr$end.genome &lt;- end(gr) + cum.seqlengths.0[as.character(seqnames(gr))] return(gr) } stopTimedMessage &lt;- function(ptm) { time &lt;- proc.time() - ptm message(&quot; &quot;, round(time[3],2), &quot;s&quot;) } initializeStates &lt;- function (states) { somy.states &lt;- grep(&quot;somy&quot;, states, value = TRUE) somy.numbers &lt;- as.integer(sapply(strsplit(somy.states, &quot;-somy&quot;), &quot;[[&quot;, 1)) names(somy.numbers) &lt;- somy.states if (&quot;zero-inflation&quot; %in% states) { multiplicity &lt;- c(`zero-inflation` = 0, somy.numbers) } else { multiplicity &lt;- somy.numbers } levels.distributions &lt;- c(&quot;delta&quot;, &quot;dgeom&quot;, &quot;dnbinom&quot;, &quot;dbinom&quot;) distributions &lt;- rep(NA, length(states)) names(distributions) &lt;- states distributions[states == &quot;zero-inflation&quot;] &lt;- &quot;delta&quot; distributions[states == &quot;0-somy&quot;] &lt;- &quot;dgeom&quot; distributions[(states != &quot;zero-inflation&quot;) &amp; (states != &quot;0-somy&quot;)] &lt;- &quot;dnbinom&quot; states &lt;- factor(states, levels = states) distributions &lt;- factor(distributions, levels = levels.distributions) l &lt;- list(states = states, distributions = distributions, multiplicity = multiplicity) return(l) } # colours if (daan_colours) { stateColors &lt;- function(states = c(&quot;zero-inflation&quot;, paste0(0:10, &quot;-somy&quot;), &quot;total&quot;)) { state.colors &lt;- c(`zero-inflation` = &quot;#1d4661&quot;, `0-somy` = &quot;#1d4661&quot;, `1-somy` = &quot;#3787BA&quot;, `2-somy` = &quot;#95B8C5&quot;, `3-somy` = &quot;#F0ECEB&quot;, `4-somy` = &quot;#D7A290&quot;, `5-somy` = &quot;#BF583B&quot;, `6-somy` = &quot;#8D1128&quot;, `7-somy` = &quot;#3C0912&quot;, `8-somy` = &quot;black&quot;, total = &quot;black&quot;) states.with.color &lt;- intersect(states, names(state.colors)) cols &lt;- rep(&quot;black&quot;, length(states)) names(cols) &lt;- states cols[states.with.color] &lt;- state.colors[states.with.color] return(cols) } } # heatmapgenomewide adapted form AneuFinder package heatmapGenomewide_daan &lt;- function (hmms, ylabels = NULL, classes, reorder.by.class = TRUE, classes.color, file = NULL, cluster = TRUE, plot.breakpoints = FALSE, hotspots = NULL, exclude.regions = NULL) { if (!is.null(ylabels)) { if (length(ylabels) != length(hmms)) { stop(&quot;length(ylabels) must equal length(hmms)&quot;) } } if (!is.null(classes)) { if (length(classes) != length(hmms)) { stop(&quot;length(classes) must equal length(hmms)&quot;) } } if (length(classes.color) != length(unique(classes))) { stop(&quot;&#39;classes.color&#39; must have the same length as unique(classes)&quot;) } if (is.null(names(classes.color))) { names(classes.color) &lt;- unique(classes) } if (!setequal(names(classes.color), unique(classes))) { stop(&quot;The names of &#39;classes.color&#39; must be equal to the unique elements in &#39;classes&#39;&quot;) } if (length(hmms) == 1 &amp; cluster == TRUE) { cluster &lt;- FALSE warning(&quot;Cannot do clustering because only one object was given.&quot;) } hmms &lt;- loadFromFiles(hmms, check.class = c(&quot;aneuHMM&quot;, &quot;aneuBiHMM&quot;)) class.data &lt;- data.frame(ID = sapply(hmms, &quot;[[&quot;, &quot;ID&quot;)) class.data$ID &lt;- factor(class.data$ID, levels = class.data$ID) if (is.null(ylabels)) { class.data$ylabel &lt;- as.character(class.data$ID) } else { class.data$ylabel &lt;- as.character(ylabels) } class.data$class &lt;- classes mapping &lt;- class.data$ylabel names(mapping) &lt;- class.data$ID if (reorder.by.class) { cl &lt;- clusterHMMs(hmms, cluster = cluster, classes = classes, exclude.regions = exclude.regions) } else { cl &lt;- clusterHMMs(hmms, cluster = cluster, exclude.regions = exclude.regions) } hmms &lt;- hmms[cl$IDorder] class.data &lt;- class.data[cl$IDorder, ] class.data$ID &lt;- factor(class.data$ID, levels = class.data$ID) segments.list &lt;- GRangesList() for (i1 in 1:length(hmms)) { hmm &lt;- hmms[[i1]] if (is.null(hmm$segments)) { segments.list[[hmm$ID]] &lt;- GRanges() } else { segments.list[[hmm$ID]] &lt;- hmm$segments } } if (plot.breakpoints) { breakpoints &lt;- GRangesList() for (i1 in 1:length(hmms)) { hmm &lt;- hmms[[i1]] if (is.null(hmm$breakpoints)) { breakpoints[[hmm$ID]] &lt;- GRanges() } else { breakpoints[[hmm$ID]] &lt;- hmm$breakpoints } } if (length(breakpoints) == 0) { plot.breakpoints &lt;- FALSE } } ptm &lt;- startTimedMessage(&quot;Transforming coordinates ...&quot;) segments.list &lt;- endoapply(segments.list, transCoord) if (plot.breakpoints) { breakpoints &lt;- endoapply(breakpoints, transCoord) } stopTimedMessage(ptm) ptm &lt;- startTimedMessage(&quot;Making the plot ...&quot;) df &lt;- list() for (i1 in 1:length(segments.list)) { df[[length(df) + 1]] &lt;- data.frame(start = segments.list[[i1]]$start.genome, end = segments.list[[i1]]$end.genome, seqnames = seqnames(segments.list[[i1]]), ID = names(segments.list)[i1], state = segments.list[[i1]]$state) } df &lt;- do.call(rbind, df) df$ID &lt;- factor(df$ID, levels = levels(class.data$ID)) df$ylabel &lt;- mapping[as.character(df$ID)] if (plot.breakpoints) { df.breakpoints &lt;- list() for (i1 in 1:length(breakpoints)) { if (length(breakpoints[[i1]]) &gt; 0) { df.breakpoints[[length(df.breakpoints) + 1]] &lt;- data.frame(start = breakpoints[[i1]]$start.genome, end = breakpoints[[i1]]$end.genome, seqnames = seqnames(breakpoints[[i1]]), ID = names(segments.list)[i1], mid = (breakpoints[[i1]]$start.genome + breakpoints[[i1]]$end.genome)/2) } else { df.breakpoints[[length(df.breakpoints) + 1]] &lt;- data.frame(start = numeric(), end = numeric(), seqnames = character(), ID = character(), mid = numeric()) } } df.breakpoints &lt;- do.call(rbind, df.breakpoints) df.breakpoints$ID &lt;- factor(df.breakpoints$ID, levels = levels(class.data$ID)) df.breakpoints$ylabel &lt;- mapping[as.character(df.breakpoints$ID)] } cum.seqlengths &lt;- cumsum(as.numeric(seqlengths(segments.list[[1]]))) names(cum.seqlengths) &lt;- seqlevels(segments.list[[1]]) cum.seqlengths.0 &lt;- c(0, cum.seqlengths[-length(cum.seqlengths)]) names(cum.seqlengths.0) &lt;- seqlevels(segments.list[[1]]) label.pos &lt;- round(cum.seqlengths.0 + 0.5 * seqlengths(segments.list[[1]])) df.chroms &lt;- data.frame(y = c(0, cum.seqlengths), x = 1, xend = length(segments.list)) pltlist &lt;- list() widths &lt;- vector() df$state &lt;- factor(df$state, levels = names(sort(initializeStates(levels(df$state))$multiplicity))) df$x &lt;- as.numeric(df$ID) ggplt &lt;- ggplot(df) + geom_linerange(aes_string(ymin = &quot;start&quot;, ymax = &quot;end&quot;, x = &quot;x&quot;, col = &quot;state&quot;), size = 5) + scale_y_continuous(breaks = label.pos, labels = names(label.pos)) # ggplt &lt;- ggplt + scale_x_continuous(name = &quot;&quot;, # breaks = 1:length(unique(df$ylabel)), # labels = unique(df$ylabel)) ggplt &lt;- ggplt + scale_color_manual(values = stateColors(levels(df$state))) # adding custom colours # adjusintg x axis ggplt &lt;- ggplt + theme(panel.background = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank(), axis.line = element_blank(), axis.title.x = element_blank()) ggplt &lt;- ggplt + geom_segment(aes_string(x = &quot;x&quot;, xend = &quot;xend&quot;, y = &quot;y&quot;, yend = &quot;y&quot;), data = df.chroms, col = &quot;grey13&quot;) # adjusting y axis ggplt &lt;- ggplt + theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.line = element_blank(), axis.title.x = element_blank()) # removing legend ggplt &lt;- ggplt + theme(legend.position=&quot;none&quot;) ggplt &lt;- ggplt + coord_flip() # removing all axis names ggplt &lt;- ggplt + ylab(&quot;&quot;) + xlab(&quot;&quot;) # add numeber of cells sequenced text ggplt &lt;- ggplt + annotate(&quot;text&quot;, label = paste(length(hmms), &#39;cells&#39;), x = length(hmms)/2, y = 3100000000, angle = 270, size = 50) # decreasing plot margin ggplt &lt;- ggplt + theme(plot.margin = unit(c(0,0,0,0), &quot;cm&quot;)) if (plot.breakpoints) { df.breakpoints$x &lt;- as.numeric(df.breakpoints$ID) ggplt &lt;- ggplt + geom_linerange(data = df.breakpoints, mapping = aes_string(x = &quot;x&quot;, ymin = &quot;start&quot;, ymax = &quot;end&quot;), size = 2) + ylab(&quot;&quot;) + geom_point(data = df.breakpoints, mapping = aes_string(x = &quot;x&quot;, y = &quot;mid&quot;)) } if (!is.null(hotspots)) { if (length(hotspots) &gt; 0) { df.hot &lt;- as.data.frame(transCoord(hotspots)) df.hot$xmin &lt;- 0 df.hot$xmax &lt;- length(class.data$ID) + 1 ggplt &lt;- ggplt + geom_rect(data = df.hot, mapping = aes_string(xmin = &quot;xmin&quot;, xmax = &quot;xmax&quot;, ymin = &quot;start.genome&quot;, ymax = &quot;end.genome&quot;, alpha = &quot;num.events&quot;), fill = &quot;hotpink4&quot;) + scale_alpha_continuous(name = &quot;breakpoints&quot;, range = c(0.4, 0.8)) } } width.heatmap &lt;- sum(as.numeric(seqlengths(hmms[[1]]$bins)))/3e+09 * 150 height &lt;- max(length(hmms) * 0.5, 2) pltlist[[&quot;heatmap&quot;]] &lt;- ggplt widths[&quot;heatmap&quot;] &lt;- width.heatmap # adding class colors if (!is.null(classes)) { width.classes &lt;- 5 class.data$x &lt;- as.numeric(class.data$ID) ggclass &lt;- ggplot(class.data) + geom_linerange(aes_string(ymin = 0, ymax = 1, x = &quot;x&quot;, col = &quot;class&quot;), size = 5) + guides(col = FALSE) + xlab(&quot;&quot;) ggclass &lt;- ggclass + theme(panel.background = element_blank(), axis.ticks = element_blank(), axis.text = element_blank(), axis.line = element_blank(), axis.title.x = element_blank()) ggclass &lt;- ggclass + coord_flip() # decreasing plot margin ggclass &lt;- ggclass + theme(plot.margin = unit(c(0,0,0,0), &quot;cm&quot;)) if (!is.null(classes.color)) { ggclass &lt;- ggclass + scale_color_manual(breaks = names(classes.color), values = classes.color) } pltlist[[&quot;classbar&quot;]] &lt;- ggclass widths[&quot;classbar&quot;] &lt;- width.classes } # adding dendogram if (!is.null(cl$hclust) &amp; dendogram) { dhc &lt;- stats::as.dendrogram(cl$hclust) ddata &lt;- ggdendro::dendro_data(dhc, type = &quot;rectangle&quot;) ggdndr &lt;- ggplot(ddata$segments) + geom_segment(aes_string(x = &quot;x&quot;, xend = &quot;xend&quot;, y = &quot;y&quot;, yend = &quot;yend&quot;)) + scale_y_reverse() ggdndr &lt;- ggdndr + coord_flip() ggdndr &lt;- ggdndr + theme(panel.background = element_blank(), axis.ticks = element_blank(), axis.text = element_blank(), axis.line = element_blank(), axis.title = element_blank()) width.dendro &lt;- 20 pltlist[[&quot;dendro&quot;]] &lt;- ggdndr widths[&quot;dendro&quot;] &lt;- width.dendro } # alligning ggpllt with dendogram and classes cowplt &lt;- cowplot::plot_grid(plotlist = rev(pltlist), align = &quot;h&quot;, ncol = length(pltlist), rel_widths = rev(widths)) stopTimedMessage(ptm) if (!is.null(file)) { ptm &lt;- startTimedMessage(&quot;Plotting to file &quot;, file, &quot; ...&quot;) ggsave(file, cowplt, width = sum(widths), height = height, units = &quot;cm&quot;, limitsize = FALSE) stopTimedMessage(ptm) } else { return(cowplt) } } #make heatmap and safe suppressWarnings(heatmapGenomewide_daan(selected.files, classes = classes_daan, classes.color = class.col, file = paste0(path, &#39;/&#39;, name, &#39;_&#39;, platename, &#39;.pdf&#39;))) return(print(paste0(name, &#39; done.&#39;))) } 6.9 fisher_test script: ‘perform_fisher’ function perform_fisher &lt;- function(dataframe, population1, population2) { #&#39; @param #&#39; dataframe is a df with columns paths and class with values &#39;hub015_rad_a&#39;, &#39;hub015_prerad_a&#39; etc. #&#39; population 1 and population two are the two pops you want to compare, for example prerad vs rad #&#39; or prerad versus rad cycle 2 #&#39; @return #&#39; returns the p value of a Fisher&#39;s exact test. If the p value is above 0.05, the distributions #&#39; pre and post rad are the same. #&#39; dataframe$rad &lt;- ifelse(dataframe$class %in% population1, &#39;pop1&#39;, ifelse(dataframe$class %in% population2, &#39;pop2&#39;, NA)) org_id &lt;- unique(str_extract(unique(dataframe$class), &#39;hub\\\\d{3}&#39;)) # remove na dataframe &lt;- dataframe[which(!is.na(dataframe$rad)),] simple_fun &lt;- function(string) { return(tail(string,1)) } dataframe$clone &lt;- unlist(lapply(stringr::str_split(dataframe$class, pattern = &#39;_&#39;), simple_fun)) # in hub015 and hub005, we defined subclones. These are actually part of the same clone, so should be # analysed together if (org_id %in% c(&#39;hub005&#39;, &#39;hub015&#39;)){ dataframe$clone &lt;- str_replace_all(dataframe$clone, pattern = &#39;a.a|a.b&#39;, replacement = &#39;a&#39;) } tab &lt;- table(dataframe$clone, dataframe$rad) # df &lt;- data.frame(cline &lt;- org_id, p_val &lt;- fisher.test(tab)$p.value) # # return(df) return(fisher.test(tab)$p.value) } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
